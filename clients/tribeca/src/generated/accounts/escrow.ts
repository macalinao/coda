/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  Account,
  Address,
  EncodedAccount,
  FetchAccountConfig,
  FetchAccountsConfig,
  FixedSizeCodec,
  FixedSizeDecoder,
  FixedSizeEncoder,
  MaybeAccount,
  MaybeEncodedAccount,
  ReadonlyUint8Array,
} from "@solana/kit";
import type { EscrowSeeds } from "../pdas/index.js";
import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
} from "@solana/kit";
import { findEscrowPda } from "../pdas/index.js";

export const ESCROW_DISCRIMINATOR: ReadonlyUint8Array = new Uint8Array([
  31, 213, 123, 187, 186, 22, 218, 155,
]);

export function getEscrowDiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(ESCROW_DISCRIMINATOR);
}

export interface Escrow {
  discriminator: ReadonlyUint8Array;
  locker: Address;
  owner: Address;
  bump: number;
  tokens: Address;
  amount: bigint;
  escrowStartedAt: bigint;
  escrowEndsAt: bigint;
  voteDelegate: Address;
}

export interface EscrowArgs {
  locker: Address;
  owner: Address;
  bump: number;
  tokens: Address;
  amount: number | bigint;
  escrowStartedAt: number | bigint;
  escrowEndsAt: number | bigint;
  voteDelegate: Address;
}

export function getEscrowEncoder(): FixedSizeEncoder<EscrowArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["locker", getAddressEncoder()],
      ["owner", getAddressEncoder()],
      ["bump", getU8Encoder()],
      ["tokens", getAddressEncoder()],
      ["amount", getU64Encoder()],
      ["escrowStartedAt", getI64Encoder()],
      ["escrowEndsAt", getI64Encoder()],
      ["voteDelegate", getAddressEncoder()],
    ]),
    (value) => ({ ...value, discriminator: ESCROW_DISCRIMINATOR }),
  );
}

export function getEscrowDecoder(): FixedSizeDecoder<Escrow> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["locker", getAddressDecoder()],
    ["owner", getAddressDecoder()],
    ["bump", getU8Decoder()],
    ["tokens", getAddressDecoder()],
    ["amount", getU64Decoder()],
    ["escrowStartedAt", getI64Decoder()],
    ["escrowEndsAt", getI64Decoder()],
    ["voteDelegate", getAddressDecoder()],
  ]);
}

export function getEscrowCodec(): FixedSizeCodec<EscrowArgs, Escrow> {
  return combineCodec(getEscrowEncoder(), getEscrowDecoder());
}

export function decodeEscrow<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<Escrow, TAddress>;
export function decodeEscrow<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<Escrow, TAddress>;
export function decodeEscrow<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<Escrow, TAddress> | MaybeAccount<Escrow, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getEscrowDecoder(),
  );
}

export async function fetchEscrow<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<Escrow, TAddress>> {
  const maybeAccount = await fetchMaybeEscrow(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeEscrow<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<Escrow, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeEscrow(maybeAccount);
}

export async function fetchAllEscrow(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<Account<Escrow>[]> {
  const maybeAccounts = await fetchAllMaybeEscrow(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeEscrow(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<Escrow>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeEscrow(maybeAccount));
}

export async function fetchEscrowFromSeeds(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  seeds: EscrowSeeds,
  config: FetchAccountConfig & { programAddress?: Address } = {},
): Promise<Account<Escrow>> {
  const maybeAccount = await fetchMaybeEscrowFromSeeds(rpc, seeds, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeEscrowFromSeeds(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  seeds: EscrowSeeds,
  config: FetchAccountConfig & { programAddress?: Address } = {},
): Promise<MaybeAccount<Escrow>> {
  const { programAddress, ...fetchConfig } = config;
  const [address] = await findEscrowPda(seeds, { programAddress });
  return await fetchMaybeEscrow(rpc, address, fetchConfig);
}
