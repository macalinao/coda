/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type { Address, ReadonlyUint8Array } from "@solana/kit";
import type {
  ParsedActivateProposalInstruction,
  ParsedApproveProgramLockPrivilegeInstruction,
  ParsedCastVoteInstruction,
  ParsedExitInstruction,
  ParsedLockInstruction,
  ParsedLockPermissionlessInstruction,
  ParsedLockWithWhitelistEntryInstruction,
  ParsedLockWithWhitelistInstruction,
  ParsedNewEscrowInstruction,
  ParsedNewLockerInstruction,
  ParsedRevokeProgramLockPrivilegeInstruction,
  ParsedSetLockerParamsInstruction,
  ParsedSetVoteDelegateInstruction,
} from "../instructions/index.js";
import { containsBytes, fixEncoderSize, getBytesEncoder } from "@solana/kit";

export const LOCKED_VOTER_PROGRAM_ADDRESS =
  "LocktDzaV1W2Bm9DeZeiyz4J9zs4fRqNiYqQyracRXw" as Address<"LocktDzaV1W2Bm9DeZeiyz4J9zs4fRqNiYqQyracRXw">;

export enum LockedVoterAccount {
  Locker = 0,
  LockerWhitelistEntry = 1,
  Escrow = 2,
}

export function identifyLockedVoterAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): LockedVoterAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([74, 246, 6, 113, 249, 228, 75, 169]),
      ),
      0,
    )
  ) {
    return LockedVoterAccount.Locker;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([128, 245, 238, 138, 226, 48, 216, 63]),
      ),
      0,
    )
  ) {
    return LockedVoterAccount.LockerWhitelistEntry;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([31, 213, 123, 187, 186, 22, 218, 155]),
      ),
      0,
    )
  ) {
    return LockedVoterAccount.Escrow;
  }
  throw new Error(
    "The provided account could not be identified as a lockedVoter account.",
  );
}

export enum LockedVoterInstruction {
  NewLocker = 0,
  NewEscrow = 1,
  Lock = 2,
  LockWithWhitelist = 3,
  LockWithWhitelistEntry = 4,
  LockPermissionless = 5,
  Exit = 6,
  ActivateProposal = 7,
  CastVote = 8,
  SetVoteDelegate = 9,
  SetLockerParams = 10,
  ApproveProgramLockPrivilege = 11,
  RevokeProgramLockPrivilege = 12,
}

export function identifyLockedVoterInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): LockedVoterInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([177, 133, 32, 90, 229, 216, 131, 47]),
      ),
      0,
    )
  ) {
    return LockedVoterInstruction.NewLocker;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([216, 182, 143, 11, 220, 38, 86, 185]),
      ),
      0,
    )
  ) {
    return LockedVoterInstruction.NewEscrow;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([21, 19, 208, 43, 237, 62, 255, 87]),
      ),
      0,
    )
  ) {
    return LockedVoterInstruction.Lock;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([138, 141, 28, 193, 7, 211, 181, 69]),
      ),
      0,
    )
  ) {
    return LockedVoterInstruction.LockWithWhitelist;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([138, 248, 185, 79, 3, 115, 115, 57]),
      ),
      0,
    )
  ) {
    return LockedVoterInstruction.LockWithWhitelistEntry;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([146, 106, 208, 36, 187, 241, 122, 2]),
      ),
      0,
    )
  ) {
    return LockedVoterInstruction.LockPermissionless;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([234, 32, 12, 71, 126, 5, 219, 160]),
      ),
      0,
    )
  ) {
    return LockedVoterInstruction.Exit;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([90, 186, 203, 234, 70, 185, 191, 21]),
      ),
      0,
    )
  ) {
    return LockedVoterInstruction.ActivateProposal;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([20, 212, 15, 189, 69, 180, 69, 151]),
      ),
      0,
    )
  ) {
    return LockedVoterInstruction.CastVote;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([46, 236, 241, 243, 251, 108, 156, 12]),
      ),
      0,
    )
  ) {
    return LockedVoterInstruction.SetVoteDelegate;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([106, 39, 132, 84, 254, 77, 161, 169]),
      ),
      0,
    )
  ) {
    return LockedVoterInstruction.SetLockerParams;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([75, 202, 1, 4, 122, 110, 102, 148]),
      ),
      0,
    )
  ) {
    return LockedVoterInstruction.ApproveProgramLockPrivilege;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([170, 151, 7, 88, 194, 86, 245, 112]),
      ),
      0,
    )
  ) {
    return LockedVoterInstruction.RevokeProgramLockPrivilege;
  }
  throw new Error(
    "The provided instruction could not be identified as a lockedVoter instruction.",
  );
}

export type ParsedLockedVoterInstruction<
  TProgram extends string = "LocktDzaV1W2Bm9DeZeiyz4J9zs4fRqNiYqQyracRXw",
> =
  | ({
      instructionType: LockedVoterInstruction.NewLocker;
    } & ParsedNewLockerInstruction<TProgram>)
  | ({
      instructionType: LockedVoterInstruction.NewEscrow;
    } & ParsedNewEscrowInstruction<TProgram>)
  | ({
      instructionType: LockedVoterInstruction.Lock;
    } & ParsedLockInstruction<TProgram>)
  | ({
      instructionType: LockedVoterInstruction.LockWithWhitelist;
    } & ParsedLockWithWhitelistInstruction<TProgram>)
  | ({
      instructionType: LockedVoterInstruction.LockWithWhitelistEntry;
    } & ParsedLockWithWhitelistEntryInstruction<TProgram>)
  | ({
      instructionType: LockedVoterInstruction.LockPermissionless;
    } & ParsedLockPermissionlessInstruction<TProgram>)
  | ({
      instructionType: LockedVoterInstruction.Exit;
    } & ParsedExitInstruction<TProgram>)
  | ({
      instructionType: LockedVoterInstruction.ActivateProposal;
    } & ParsedActivateProposalInstruction<TProgram>)
  | ({
      instructionType: LockedVoterInstruction.CastVote;
    } & ParsedCastVoteInstruction<TProgram>)
  | ({
      instructionType: LockedVoterInstruction.SetVoteDelegate;
    } & ParsedSetVoteDelegateInstruction<TProgram>)
  | ({
      instructionType: LockedVoterInstruction.SetLockerParams;
    } & ParsedSetLockerParamsInstruction<TProgram>)
  | ({
      instructionType: LockedVoterInstruction.ApproveProgramLockPrivilege;
    } & ParsedApproveProgramLockPrivilegeInstruction<TProgram>)
  | ({
      instructionType: LockedVoterInstruction.RevokeProgramLockPrivilege;
    } & ParsedRevokeProgramLockPrivilegeInstruction<TProgram>);
