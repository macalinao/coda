/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type { Address, ReadonlyUint8Array } from "@solana/kit";
import type {
  ParsedActivateProposalInstruction,
  ParsedCancelProposalInstruction,
  ParsedCreateGovernorInstruction,
  ParsedCreateProposalInstruction,
  ParsedCreateProposalMetaInstruction,
  ParsedNewVoteInstruction,
  ParsedQueueProposalInstruction,
  ParsedSetElectorateInstruction,
  ParsedSetGovernanceParamsInstruction,
  ParsedSetVoteInstruction,
} from "../instructions/index.js";
import { containsBytes, fixEncoderSize, getBytesEncoder } from "@solana/kit";

export const GOVERN_PROGRAM_ADDRESS =
  "Govz1VyoyLD5BL6CSCxUJLVLsQHRwjfFj1prNsdNg5Jw" as Address<"Govz1VyoyLD5BL6CSCxUJLVLsQHRwjfFj1prNsdNg5Jw">;

export enum GovernAccount {
  Governor = 0,
  Proposal = 1,
  ProposalMeta = 2,
  Vote = 3,
}

export function identifyGovernAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): GovernAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([37, 136, 44, 80, 68, 85, 213, 178]),
      ),
      0,
    )
  ) {
    return GovernAccount.Governor;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([26, 94, 189, 187, 116, 136, 53, 33]),
      ),
      0,
    )
  ) {
    return GovernAccount.Proposal;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([50, 100, 46, 24, 151, 174, 216, 78]),
      ),
      0,
    )
  ) {
    return GovernAccount.ProposalMeta;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([96, 91, 104, 57, 145, 35, 172, 155]),
      ),
      0,
    )
  ) {
    return GovernAccount.Vote;
  }
  throw new Error(
    "The provided account could not be identified as a govern account.",
  );
}

export enum GovernInstruction {
  CreateGovernor = 0,
  CreateProposal = 1,
  ActivateProposal = 2,
  CancelProposal = 3,
  QueueProposal = 4,
  NewVote = 5,
  SetVote = 6,
  SetGovernanceParams = 7,
  SetElectorate = 8,
  CreateProposalMeta = 9,
}

export function identifyGovernInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): GovernInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([103, 30, 78, 252, 28, 128, 40, 3]),
      ),
      0,
    )
  ) {
    return GovernInstruction.CreateGovernor;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([132, 116, 68, 174, 216, 160, 198, 22]),
      ),
      0,
    )
  ) {
    return GovernInstruction.CreateProposal;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([90, 186, 203, 234, 70, 185, 191, 21]),
      ),
      0,
    )
  ) {
    return GovernInstruction.ActivateProposal;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([106, 74, 128, 146, 19, 65, 39, 23]),
      ),
      0,
    )
  ) {
    return GovernInstruction.CancelProposal;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([168, 219, 139, 211, 205, 152, 125, 110]),
      ),
      0,
    )
  ) {
    return GovernInstruction.QueueProposal;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([163, 108, 157, 189, 140, 80, 13, 143]),
      ),
      0,
    )
  ) {
    return GovernInstruction.NewVote;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([171, 33, 83, 172, 148, 215, 239, 97]),
      ),
      0,
    )
  ) {
    return GovernInstruction.SetVote;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([175, 187, 3, 73, 8, 251, 67, 178]),
      ),
      0,
    )
  ) {
    return GovernInstruction.SetGovernanceParams;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([145, 135, 92, 16, 77, 195, 145, 91]),
      ),
      0,
    )
  ) {
    return GovernInstruction.SetElectorate;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([238, 138, 212, 160, 46, 53, 51, 88]),
      ),
      0,
    )
  ) {
    return GovernInstruction.CreateProposalMeta;
  }
  throw new Error(
    "The provided instruction could not be identified as a govern instruction.",
  );
}

export type ParsedGovernInstruction<
  TProgram extends string = "Govz1VyoyLD5BL6CSCxUJLVLsQHRwjfFj1prNsdNg5Jw",
> =
  | ({
      instructionType: GovernInstruction.CreateGovernor;
    } & ParsedCreateGovernorInstruction<TProgram>)
  | ({
      instructionType: GovernInstruction.CreateProposal;
    } & ParsedCreateProposalInstruction<TProgram>)
  | ({
      instructionType: GovernInstruction.ActivateProposal;
    } & ParsedActivateProposalInstruction<TProgram>)
  | ({
      instructionType: GovernInstruction.CancelProposal;
    } & ParsedCancelProposalInstruction<TProgram>)
  | ({
      instructionType: GovernInstruction.QueueProposal;
    } & ParsedQueueProposalInstruction<TProgram>)
  | ({
      instructionType: GovernInstruction.NewVote;
    } & ParsedNewVoteInstruction<TProgram>)
  | ({
      instructionType: GovernInstruction.SetVote;
    } & ParsedSetVoteInstruction<TProgram>)
  | ({
      instructionType: GovernInstruction.SetGovernanceParams;
    } & ParsedSetGovernanceParamsInstruction<TProgram>)
  | ({
      instructionType: GovernInstruction.SetElectorate;
    } & ParsedSetElectorateInstruction<TProgram>)
  | ({
      instructionType: GovernInstruction.CreateProposalMeta;
    } & ParsedCreateProposalMetaInstruction<TProgram>);
