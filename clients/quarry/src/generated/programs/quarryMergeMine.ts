/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  
  containsBytes,
  fixEncoderSize,
  getBytesEncoder
  
} from "@solana/kit";
import type {Address, ReadonlyUint8Array} from "@solana/kit";
import type {ParsedClaimRewardsMMInstruction, ParsedInitMergeMinerInstruction, ParsedInitMergeMinerV2Instruction, ParsedInitMinerMMInstruction, ParsedInitMinerMMV2Instruction, ParsedNewPoolInstruction, ParsedNewPoolV2Instruction, ParsedRescueTokensMMInstruction, ParsedStakePrimaryMinerInstruction, ParsedStakeReplicaMinerInstruction, ParsedUnstakeAllReplicaMinerInstruction, ParsedUnstakePrimaryMinerInstruction, ParsedWithdrawTokensMMInstruction} from "../instructions/index.js";

export const QUARRY_MERGE_MINE_PROGRAM_ADDRESS =
  "QMMD16kjauP5knBwxNUJRZ1Z5o3deBuFrqVjBVmmqto" as Address<"QMMD16kjauP5knBwxNUJRZ1Z5o3deBuFrqVjBVmmqto">;

export enum QuarryMergeMineAccount {
  MergePool,
  MergeMiner,
}

export function identifyQuarryMergeMineAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): QuarryMergeMineAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([15, 189, 242, 87, 188, 75, 64, 244]),
      ),
      0,
    )
  ) {
    return QuarryMergeMineAccount.MergePool;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([243, 97, 253, 80, 19, 210, 148, 120]),
      ),
      0,
    )
  ) {
    return QuarryMergeMineAccount.MergeMiner;
  }
  throw new Error(
    "The provided account could not be identified as a quarryMergeMine account.",
  );
}

export enum QuarryMergeMineInstruction {
  NewPool,
  NewPoolV2,
  InitMergeMiner,
  InitMergeMinerV2,
  InitMinerMM,
  InitMinerMMV2,
  StakePrimaryMiner,
  StakeReplicaMiner,
  UnstakePrimaryMiner,
  UnstakeAllReplicaMiner,
  WithdrawTokensMM,
  RescueTokensMM,
  ClaimRewardsMM,
}

export function identifyQuarryMergeMineInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): QuarryMergeMineInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([38, 63, 210, 32, 246, 20, 239, 112]),
      ),
      0,
    )
  ) {
    return QuarryMergeMineInstruction.NewPool;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([107, 122, 206, 99, 39, 6, 23, 195]),
      ),
      0,
    )
  ) {
    return QuarryMergeMineInstruction.NewPoolV2;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([23, 22, 142, 134, 78, 63, 147, 161]),
      ),
      0,
    )
  ) {
    return QuarryMergeMineInstruction.InitMergeMiner;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([153, 44, 29, 197, 171, 114, 71, 208]),
      ),
      0,
    )
  ) {
    return QuarryMergeMineInstruction.InitMergeMinerV2;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([144, 159, 202, 208, 234, 154, 242, 55]),
      ),
      0,
    )
  ) {
    return QuarryMergeMineInstruction.InitMinerMM;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([189, 125, 116, 157, 73, 4, 253, 156]),
      ),
      0,
    )
  ) {
    return QuarryMergeMineInstruction.InitMinerMMV2;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([72, 59, 23, 242, 117, 178, 129, 138]),
      ),
      0,
    )
  ) {
    return QuarryMergeMineInstruction.StakePrimaryMiner;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([246, 171, 25, 201, 242, 145, 94, 47]),
      ),
      0,
    )
  ) {
    return QuarryMergeMineInstruction.StakeReplicaMiner;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([45, 62, 3, 33, 114, 156, 186, 26]),
      ),
      0,
    )
  ) {
    return QuarryMergeMineInstruction.UnstakePrimaryMiner;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([250, 4, 3, 209, 154, 125, 71, 168]),
      ),
      0,
    )
  ) {
    return QuarryMergeMineInstruction.UnstakeAllReplicaMiner;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([2, 4, 225, 61, 19, 182, 106, 170]),
      ),
      0,
    )
  ) {
    return QuarryMergeMineInstruction.WithdrawTokensMM;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([222, 81, 199, 209, 182, 62, 62, 186]),
      ),
      0,
    )
  ) {
    return QuarryMergeMineInstruction.RescueTokensMM;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([4, 144, 132, 71, 116, 23, 151, 80]),
      ),
      0,
    )
  ) {
    return QuarryMergeMineInstruction.ClaimRewardsMM;
  }
  throw new Error(
    "The provided instruction could not be identified as a quarryMergeMine instruction.",
  );
}

export type ParsedQuarryMergeMineInstruction<
  TProgram extends string = "QMMD16kjauP5knBwxNUJRZ1Z5o3deBuFrqVjBVmmqto",
> =
  | ({
      instructionType: QuarryMergeMineInstruction.NewPool;
    } & ParsedNewPoolInstruction<TProgram>)
  | ({
      instructionType: QuarryMergeMineInstruction.NewPoolV2;
    } & ParsedNewPoolV2Instruction<TProgram>)
  | ({
      instructionType: QuarryMergeMineInstruction.InitMergeMiner;
    } & ParsedInitMergeMinerInstruction<TProgram>)
  | ({
      instructionType: QuarryMergeMineInstruction.InitMergeMinerV2;
    } & ParsedInitMergeMinerV2Instruction<TProgram>)
  | ({
      instructionType: QuarryMergeMineInstruction.InitMinerMM;
    } & ParsedInitMinerMMInstruction<TProgram>)
  | ({
      instructionType: QuarryMergeMineInstruction.InitMinerMMV2;
    } & ParsedInitMinerMMV2Instruction<TProgram>)
  | ({
      instructionType: QuarryMergeMineInstruction.StakePrimaryMiner;
    } & ParsedStakePrimaryMinerInstruction<TProgram>)
  | ({
      instructionType: QuarryMergeMineInstruction.StakeReplicaMiner;
    } & ParsedStakeReplicaMinerInstruction<TProgram>)
  | ({
      instructionType: QuarryMergeMineInstruction.UnstakePrimaryMiner;
    } & ParsedUnstakePrimaryMinerInstruction<TProgram>)
  | ({
      instructionType: QuarryMergeMineInstruction.UnstakeAllReplicaMiner;
    } & ParsedUnstakeAllReplicaMinerInstruction<TProgram>)
  | ({
      instructionType: QuarryMergeMineInstruction.WithdrawTokensMM;
    } & ParsedWithdrawTokensMMInstruction<TProgram>)
  | ({
      instructionType: QuarryMergeMineInstruction.RescueTokensMM;
    } & ParsedRescueTokensMMInstruction<TProgram>)
  | ({
      instructionType: QuarryMergeMineInstruction.ClaimRewardsMM;
    } & ParsedClaimRewardsMMInstruction<TProgram>);
