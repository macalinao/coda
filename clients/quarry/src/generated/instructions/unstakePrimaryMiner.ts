/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  AccountMeta,
  AccountSignerMeta,
  Address,
  FixedSizeCodec,
  FixedSizeDecoder,
  FixedSizeEncoder,
  Instruction,
  InstructionWithAccounts,
  InstructionWithData,
  ReadonlyAccount,
  ReadonlySignerAccount,
  ReadonlyUint8Array,
  TransactionSigner,
  WritableAccount,
} from "@solana/kit";
import type { ResolvedAccount } from "../shared/index.js";
import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
} from "@solana/kit";
import { findMergeMinerPda } from "../pdas/index.js";
import { QUARRY_MERGE_MINE_PROGRAM_ADDRESS } from "../programs/index.js";
import { expectAddress, getAccountMetaFactory } from "../shared/index.js";

export const UNSTAKE_PRIMARY_MINER_DISCRIMINATOR: ReadonlyUint8Array =
  new Uint8Array([45, 62, 3, 33, 114, 156, 186, 26]);

export function getUnstakePrimaryMinerDiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    UNSTAKE_PRIMARY_MINER_DISCRIMINATOR,
  );
}

export type UnstakePrimaryMinerInstruction<
  TProgram extends string = typeof QUARRY_MERGE_MINE_PROGRAM_ADDRESS,
  TAccountMmOwner extends string | AccountMeta = string,
  TAccountMmPrimaryTokenAccount extends string | AccountMeta = string,
  TAccountPool extends string | AccountMeta = string,
  TAccountMm extends string | AccountMeta = string,
  TAccountRewarder extends string | AccountMeta = string,
  TAccountQuarry extends string | AccountMeta = string,
  TAccountMiner extends string | AccountMeta = string,
  TAccountMinerVault extends string | AccountMeta = string,
  TAccountTokenProgram extends
    | string
    | AccountMeta = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
  TAccountMineProgram extends
    | string
    | AccountMeta = "QMNeHCGYnLVDn1icRAfQZpjPLBNkfGbSKRB83G5d8KB",
  TRemainingAccounts extends readonly AccountMeta[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountMmOwner extends string
        ? ReadonlySignerAccount<TAccountMmOwner> &
            AccountSignerMeta<TAccountMmOwner>
        : TAccountMmOwner,
      TAccountMmPrimaryTokenAccount extends string
        ? WritableAccount<TAccountMmPrimaryTokenAccount>
        : TAccountMmPrimaryTokenAccount,
      TAccountPool extends string
        ? WritableAccount<TAccountPool>
        : TAccountPool,
      TAccountMm extends string ? WritableAccount<TAccountMm> : TAccountMm,
      TAccountRewarder extends string
        ? ReadonlyAccount<TAccountRewarder>
        : TAccountRewarder,
      TAccountQuarry extends string
        ? WritableAccount<TAccountQuarry>
        : TAccountQuarry,
      TAccountMiner extends string
        ? WritableAccount<TAccountMiner>
        : TAccountMiner,
      TAccountMinerVault extends string
        ? WritableAccount<TAccountMinerVault>
        : TAccountMinerVault,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountMineProgram extends string
        ? ReadonlyAccount<TAccountMineProgram>
        : TAccountMineProgram,
      ...TRemainingAccounts,
    ]
  >;

export interface UnstakePrimaryMinerInstructionData {
  discriminator: ReadonlyUint8Array;
  amount: bigint;
}

export interface UnstakePrimaryMinerInstructionDataArgs {
  amount: number | bigint;
}

export function getUnstakePrimaryMinerInstructionDataEncoder(): FixedSizeEncoder<UnstakePrimaryMinerInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["amount", getU64Encoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: UNSTAKE_PRIMARY_MINER_DISCRIMINATOR,
    }),
  );
}

export function getUnstakePrimaryMinerInstructionDataDecoder(): FixedSizeDecoder<UnstakePrimaryMinerInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["amount", getU64Decoder()],
  ]);
}

export function getUnstakePrimaryMinerInstructionDataCodec(): FixedSizeCodec<
  UnstakePrimaryMinerInstructionDataArgs,
  UnstakePrimaryMinerInstructionData
> {
  return combineCodec(
    getUnstakePrimaryMinerInstructionDataEncoder(),
    getUnstakePrimaryMinerInstructionDataDecoder(),
  );
}

export interface UnstakePrimaryMinerAsyncInput<
  TAccountMmOwner extends string = string,
  TAccountMmPrimaryTokenAccount extends string = string,
  TAccountPool extends string = string,
  TAccountMm extends string = string,
  TAccountRewarder extends string = string,
  TAccountQuarry extends string = string,
  TAccountMiner extends string = string,
  TAccountMinerVault extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountMineProgram extends string = string,
> {
  mmOwner: TransactionSigner<TAccountMmOwner>;
  mmPrimaryTokenAccount: Address<TAccountMmPrimaryTokenAccount>;
  pool: Address<TAccountPool>;
  mm?: Address<TAccountMm>;
  rewarder: Address<TAccountRewarder>;
  quarry: Address<TAccountQuarry>;
  miner: Address<TAccountMiner>;
  minerVault: Address<TAccountMinerVault>;
  tokenProgram?: Address<TAccountTokenProgram>;
  mineProgram?: Address<TAccountMineProgram>;
  amount: UnstakePrimaryMinerInstructionDataArgs["amount"];
}

export async function getUnstakePrimaryMinerInstructionAsync<
  TAccountMmOwner extends string,
  TAccountMmPrimaryTokenAccount extends string,
  TAccountPool extends string,
  TAccountMm extends string,
  TAccountRewarder extends string,
  TAccountQuarry extends string,
  TAccountMiner extends string,
  TAccountMinerVault extends string,
  TAccountTokenProgram extends string,
  TAccountMineProgram extends string,
  TProgramAddress extends Address = typeof QUARRY_MERGE_MINE_PROGRAM_ADDRESS,
>(
  input: UnstakePrimaryMinerAsyncInput<
    TAccountMmOwner,
    TAccountMmPrimaryTokenAccount,
    TAccountPool,
    TAccountMm,
    TAccountRewarder,
    TAccountQuarry,
    TAccountMiner,
    TAccountMinerVault,
    TAccountTokenProgram,
    TAccountMineProgram
  >,
  config?: { programAddress?: TProgramAddress },
): Promise<
  UnstakePrimaryMinerInstruction<
    TProgramAddress,
    TAccountMmOwner,
    TAccountMmPrimaryTokenAccount,
    TAccountPool,
    TAccountMm,
    TAccountRewarder,
    TAccountQuarry,
    TAccountMiner,
    TAccountMinerVault,
    TAccountTokenProgram,
    TAccountMineProgram
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? QUARRY_MERGE_MINE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    mmOwner: { value: input.mmOwner ?? null, isWritable: false },
    mmPrimaryTokenAccount: {
      value: input.mmPrimaryTokenAccount ?? null,
      isWritable: true,
    },
    pool: { value: input.pool ?? null, isWritable: true },
    mm: { value: input.mm ?? null, isWritable: true },
    rewarder: { value: input.rewarder ?? null, isWritable: false },
    quarry: { value: input.quarry ?? null, isWritable: true },
    miner: { value: input.miner ?? null, isWritable: true },
    minerVault: { value: input.minerVault ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    mineProgram: { value: input.mineProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.mm.value) {
    accounts.mm.value = await findMergeMinerPda({
      pool: expectAddress(accounts.pool.value),
      owner: expectAddress(accounts.mmOwner.value),
    });
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }
  if (!accounts.mineProgram.value) {
    accounts.mineProgram.value =
      "QMNeHCGYnLVDn1icRAfQZpjPLBNkfGbSKRB83G5d8KB" as Address<"QMNeHCGYnLVDn1icRAfQZpjPLBNkfGbSKRB83G5d8KB">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.mmOwner),
      getAccountMeta(accounts.mmPrimaryTokenAccount),
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.mm),
      getAccountMeta(accounts.rewarder),
      getAccountMeta(accounts.quarry),
      getAccountMeta(accounts.miner),
      getAccountMeta(accounts.minerVault),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.mineProgram),
    ],
    data: getUnstakePrimaryMinerInstructionDataEncoder().encode(
      args as UnstakePrimaryMinerInstructionDataArgs,
    ),
    programAddress,
  } as UnstakePrimaryMinerInstruction<
    TProgramAddress,
    TAccountMmOwner,
    TAccountMmPrimaryTokenAccount,
    TAccountPool,
    TAccountMm,
    TAccountRewarder,
    TAccountQuarry,
    TAccountMiner,
    TAccountMinerVault,
    TAccountTokenProgram,
    TAccountMineProgram
  >);
}

export interface UnstakePrimaryMinerInput<
  TAccountMmOwner extends string = string,
  TAccountMmPrimaryTokenAccount extends string = string,
  TAccountPool extends string = string,
  TAccountMm extends string = string,
  TAccountRewarder extends string = string,
  TAccountQuarry extends string = string,
  TAccountMiner extends string = string,
  TAccountMinerVault extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountMineProgram extends string = string,
> {
  mmOwner: TransactionSigner<TAccountMmOwner>;
  mmPrimaryTokenAccount: Address<TAccountMmPrimaryTokenAccount>;
  pool: Address<TAccountPool>;
  mm: Address<TAccountMm>;
  rewarder: Address<TAccountRewarder>;
  quarry: Address<TAccountQuarry>;
  miner: Address<TAccountMiner>;
  minerVault: Address<TAccountMinerVault>;
  tokenProgram?: Address<TAccountTokenProgram>;
  mineProgram?: Address<TAccountMineProgram>;
  amount: UnstakePrimaryMinerInstructionDataArgs["amount"];
}

export function getUnstakePrimaryMinerInstruction<
  TAccountMmOwner extends string,
  TAccountMmPrimaryTokenAccount extends string,
  TAccountPool extends string,
  TAccountMm extends string,
  TAccountRewarder extends string,
  TAccountQuarry extends string,
  TAccountMiner extends string,
  TAccountMinerVault extends string,
  TAccountTokenProgram extends string,
  TAccountMineProgram extends string,
  TProgramAddress extends Address = typeof QUARRY_MERGE_MINE_PROGRAM_ADDRESS,
>(
  input: UnstakePrimaryMinerInput<
    TAccountMmOwner,
    TAccountMmPrimaryTokenAccount,
    TAccountPool,
    TAccountMm,
    TAccountRewarder,
    TAccountQuarry,
    TAccountMiner,
    TAccountMinerVault,
    TAccountTokenProgram,
    TAccountMineProgram
  >,
  config?: { programAddress?: TProgramAddress },
): UnstakePrimaryMinerInstruction<
  TProgramAddress,
  TAccountMmOwner,
  TAccountMmPrimaryTokenAccount,
  TAccountPool,
  TAccountMm,
  TAccountRewarder,
  TAccountQuarry,
  TAccountMiner,
  TAccountMinerVault,
  TAccountTokenProgram,
  TAccountMineProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? QUARRY_MERGE_MINE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    mmOwner: { value: input.mmOwner ?? null, isWritable: false },
    mmPrimaryTokenAccount: {
      value: input.mmPrimaryTokenAccount ?? null,
      isWritable: true,
    },
    pool: { value: input.pool ?? null, isWritable: true },
    mm: { value: input.mm ?? null, isWritable: true },
    rewarder: { value: input.rewarder ?? null, isWritable: false },
    quarry: { value: input.quarry ?? null, isWritable: true },
    miner: { value: input.miner ?? null, isWritable: true },
    minerVault: { value: input.minerVault ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    mineProgram: { value: input.mineProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }
  if (!accounts.mineProgram.value) {
    accounts.mineProgram.value =
      "QMNeHCGYnLVDn1icRAfQZpjPLBNkfGbSKRB83G5d8KB" as Address<"QMNeHCGYnLVDn1icRAfQZpjPLBNkfGbSKRB83G5d8KB">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.mmOwner),
      getAccountMeta(accounts.mmPrimaryTokenAccount),
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.mm),
      getAccountMeta(accounts.rewarder),
      getAccountMeta(accounts.quarry),
      getAccountMeta(accounts.miner),
      getAccountMeta(accounts.minerVault),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.mineProgram),
    ],
    data: getUnstakePrimaryMinerInstructionDataEncoder().encode(
      args as UnstakePrimaryMinerInstructionDataArgs,
    ),
    programAddress,
  } as UnstakePrimaryMinerInstruction<
    TProgramAddress,
    TAccountMmOwner,
    TAccountMmPrimaryTokenAccount,
    TAccountPool,
    TAccountMm,
    TAccountRewarder,
    TAccountQuarry,
    TAccountMiner,
    TAccountMinerVault,
    TAccountTokenProgram,
    TAccountMineProgram
  >);
}

export interface ParsedUnstakePrimaryMinerInstruction<
  TProgram extends string = typeof QUARRY_MERGE_MINE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> {
  programAddress: Address<TProgram>;
  accounts: {
    mmOwner: TAccountMetas[0];
    mmPrimaryTokenAccount: TAccountMetas[1];
    pool: TAccountMetas[2];
    mm: TAccountMetas[3];
    rewarder: TAccountMetas[4];
    quarry: TAccountMetas[5];
    miner: TAccountMetas[6];
    minerVault: TAccountMetas[7];
    tokenProgram: TAccountMetas[8];
    mineProgram: TAccountMetas[9];
  };
  data: UnstakePrimaryMinerInstructionData;
}

export function parseUnstakePrimaryMinerInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedUnstakePrimaryMinerInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 10) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mmOwner: getNextAccount(),
      mmPrimaryTokenAccount: getNextAccount(),
      pool: getNextAccount(),
      mm: getNextAccount(),
      rewarder: getNextAccount(),
      quarry: getNextAccount(),
      miner: getNextAccount(),
      minerVault: getNextAccount(),
      tokenProgram: getNextAccount(),
      mineProgram: getNextAccount(),
    },
    data: getUnstakePrimaryMinerInstructionDataDecoder().decode(
      instruction.data,
    ),
  };
}
