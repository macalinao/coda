/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  AccountMeta,
  AccountSignerMeta,
  Address,
  FixedSizeCodec,
  FixedSizeDecoder,
  FixedSizeEncoder,
  Instruction,
  InstructionWithAccounts,
  InstructionWithData,
  ReadonlyAccount,
  ReadonlySignerAccount,
  ReadonlyUint8Array,
  TransactionSigner,
  WritableAccount,
} from "@solana/kit";
import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
} from "@solana/kit";
import { QUARRY_MINE_PROGRAM_ADDRESS } from "../programs/index.js";
import type { ResolvedAccount } from "../shared/index.js";
import { getAccountMetaFactory } from "../shared/index.js";

export const CLAIM_REWARDS_V2_DISCRIMINATOR: ReadonlyUint8Array =
  new Uint8Array([69, 49, 158, 229, 212, 133, 136, 227]);

export function getClaimRewardsV2DiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    CLAIM_REWARDS_V2_DISCRIMINATOR,
  );
}

export type ClaimRewardsV2Instruction<
  TProgram extends string = typeof QUARRY_MINE_PROGRAM_ADDRESS,
  TAccountMintWrapper extends string | AccountMeta = string,
  TAccountMintWrapperProgram extends
    | string
    | AccountMeta = "QMWoBmAyJLAsA1Lh9ugMTw2gciTihncciphzdNzdZYV",
  TAccountMinter extends string | AccountMeta = string,
  TAccountRewardsTokenMint extends string | AccountMeta = string,
  TAccountRewardsTokenAccount extends string | AccountMeta = string,
  TAccountClaimFeeTokenAccount extends string | AccountMeta = string,
  TAccountClaimAuthority extends string | AccountMeta = string,
  TAccountClaimMiner extends string | AccountMeta = string,
  TAccountClaimQuarry extends string | AccountMeta = string,
  TAccountClaimTokenProgram extends
    | string
    | AccountMeta = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
  TAccountClaimRewarder extends string | AccountMeta = string,
  TRemainingAccounts extends readonly AccountMeta[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountMintWrapper extends string
        ? WritableAccount<TAccountMintWrapper>
        : TAccountMintWrapper,
      TAccountMintWrapperProgram extends string
        ? ReadonlyAccount<TAccountMintWrapperProgram>
        : TAccountMintWrapperProgram,
      TAccountMinter extends string
        ? WritableAccount<TAccountMinter>
        : TAccountMinter,
      TAccountRewardsTokenMint extends string
        ? WritableAccount<TAccountRewardsTokenMint>
        : TAccountRewardsTokenMint,
      TAccountRewardsTokenAccount extends string
        ? WritableAccount<TAccountRewardsTokenAccount>
        : TAccountRewardsTokenAccount,
      TAccountClaimFeeTokenAccount extends string
        ? WritableAccount<TAccountClaimFeeTokenAccount>
        : TAccountClaimFeeTokenAccount,
      TAccountClaimAuthority extends string
        ? ReadonlySignerAccount<TAccountClaimAuthority> &
            AccountSignerMeta<TAccountClaimAuthority>
        : TAccountClaimAuthority,
      TAccountClaimMiner extends string
        ? WritableAccount<TAccountClaimMiner>
        : TAccountClaimMiner,
      TAccountClaimQuarry extends string
        ? WritableAccount<TAccountClaimQuarry>
        : TAccountClaimQuarry,
      TAccountClaimTokenProgram extends string
        ? ReadonlyAccount<TAccountClaimTokenProgram>
        : TAccountClaimTokenProgram,
      TAccountClaimRewarder extends string
        ? ReadonlyAccount<TAccountClaimRewarder>
        : TAccountClaimRewarder,
      ...TRemainingAccounts,
    ]
  >;

export interface ClaimRewardsV2InstructionData {
  discriminator: ReadonlyUint8Array;
}

export interface ClaimRewardsV2InstructionDataArgs {}

export function getClaimRewardsV2InstructionDataEncoder(): FixedSizeEncoder<ClaimRewardsV2InstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]),
    (value) => ({ ...value, discriminator: CLAIM_REWARDS_V2_DISCRIMINATOR }),
  );
}

export function getClaimRewardsV2InstructionDataDecoder(): FixedSizeDecoder<ClaimRewardsV2InstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
  ]);
}

export function getClaimRewardsV2InstructionDataCodec(): FixedSizeCodec<
  ClaimRewardsV2InstructionDataArgs,
  ClaimRewardsV2InstructionData
> {
  return combineCodec(
    getClaimRewardsV2InstructionDataEncoder(),
    getClaimRewardsV2InstructionDataDecoder(),
  );
}

export interface ClaimRewardsV2Input<
  TAccountMintWrapper extends string = string,
  TAccountMintWrapperProgram extends string = string,
  TAccountMinter extends string = string,
  TAccountRewardsTokenMint extends string = string,
  TAccountRewardsTokenAccount extends string = string,
  TAccountClaimFeeTokenAccount extends string = string,
  TAccountClaimAuthority extends string = string,
  TAccountClaimMiner extends string = string,
  TAccountClaimQuarry extends string = string,
  TAccountClaimTokenProgram extends string = string,
  TAccountClaimRewarder extends string = string,
> {
  mintWrapper: Address<TAccountMintWrapper>;
  mintWrapperProgram?: Address<TAccountMintWrapperProgram>;
  minter: Address<TAccountMinter>;
  rewardsTokenMint: Address<TAccountRewardsTokenMint>;
  rewardsTokenAccount: Address<TAccountRewardsTokenAccount>;
  claimFeeTokenAccount: Address<TAccountClaimFeeTokenAccount>;
  claimAuthority: TransactionSigner<TAccountClaimAuthority>;
  claimMiner: Address<TAccountClaimMiner>;
  claimQuarry: Address<TAccountClaimQuarry>;
  claimTokenProgram?: Address<TAccountClaimTokenProgram>;
  claimRewarder: Address<TAccountClaimRewarder>;
}

export function getClaimRewardsV2Instruction<
  TAccountMintWrapper extends string,
  TAccountMintWrapperProgram extends string,
  TAccountMinter extends string,
  TAccountRewardsTokenMint extends string,
  TAccountRewardsTokenAccount extends string,
  TAccountClaimFeeTokenAccount extends string,
  TAccountClaimAuthority extends string,
  TAccountClaimMiner extends string,
  TAccountClaimQuarry extends string,
  TAccountClaimTokenProgram extends string,
  TAccountClaimRewarder extends string,
  TProgramAddress extends Address = typeof QUARRY_MINE_PROGRAM_ADDRESS,
>(
  input: ClaimRewardsV2Input<
    TAccountMintWrapper,
    TAccountMintWrapperProgram,
    TAccountMinter,
    TAccountRewardsTokenMint,
    TAccountRewardsTokenAccount,
    TAccountClaimFeeTokenAccount,
    TAccountClaimAuthority,
    TAccountClaimMiner,
    TAccountClaimQuarry,
    TAccountClaimTokenProgram,
    TAccountClaimRewarder
  >,
  config?: { programAddress?: TProgramAddress },
): ClaimRewardsV2Instruction<
  TProgramAddress,
  TAccountMintWrapper,
  TAccountMintWrapperProgram,
  TAccountMinter,
  TAccountRewardsTokenMint,
  TAccountRewardsTokenAccount,
  TAccountClaimFeeTokenAccount,
  TAccountClaimAuthority,
  TAccountClaimMiner,
  TAccountClaimQuarry,
  TAccountClaimTokenProgram,
  TAccountClaimRewarder
> {
  // Program address.
  const programAddress = config?.programAddress ?? QUARRY_MINE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    mintWrapper: { value: input.mintWrapper ?? null, isWritable: true },
    mintWrapperProgram: {
      value: input.mintWrapperProgram ?? null,
      isWritable: false,
    },
    minter: { value: input.minter ?? null, isWritable: true },
    rewardsTokenMint: {
      value: input.rewardsTokenMint ?? null,
      isWritable: true,
    },
    rewardsTokenAccount: {
      value: input.rewardsTokenAccount ?? null,
      isWritable: true,
    },
    claimFeeTokenAccount: {
      value: input.claimFeeTokenAccount ?? null,
      isWritable: true,
    },
    claimAuthority: { value: input.claimAuthority ?? null, isWritable: false },
    claimMiner: { value: input.claimMiner ?? null, isWritable: true },
    claimQuarry: { value: input.claimQuarry ?? null, isWritable: true },
    claimTokenProgram: {
      value: input.claimTokenProgram ?? null,
      isWritable: false,
    },
    claimRewarder: { value: input.claimRewarder ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.mintWrapperProgram.value) {
    accounts.mintWrapperProgram.value =
      "QMWoBmAyJLAsA1Lh9ugMTw2gciTihncciphzdNzdZYV" as Address<"QMWoBmAyJLAsA1Lh9ugMTw2gciTihncciphzdNzdZYV">;
  }
  if (!accounts.claimTokenProgram.value) {
    accounts.claimTokenProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mintWrapper),
      getAccountMeta(accounts.mintWrapperProgram),
      getAccountMeta(accounts.minter),
      getAccountMeta(accounts.rewardsTokenMint),
      getAccountMeta(accounts.rewardsTokenAccount),
      getAccountMeta(accounts.claimFeeTokenAccount),
      getAccountMeta(accounts.claimAuthority),
      getAccountMeta(accounts.claimMiner),
      getAccountMeta(accounts.claimQuarry),
      getAccountMeta(accounts.claimTokenProgram),
      getAccountMeta(accounts.claimRewarder),
    ],
    programAddress,
    data: getClaimRewardsV2InstructionDataEncoder().encode({}),
  } as ClaimRewardsV2Instruction<
    TProgramAddress,
    TAccountMintWrapper,
    TAccountMintWrapperProgram,
    TAccountMinter,
    TAccountRewardsTokenMint,
    TAccountRewardsTokenAccount,
    TAccountClaimFeeTokenAccount,
    TAccountClaimAuthority,
    TAccountClaimMiner,
    TAccountClaimQuarry,
    TAccountClaimTokenProgram,
    TAccountClaimRewarder
  >;

  return instruction;
}

export interface ParsedClaimRewardsV2Instruction<
  TProgram extends string = typeof QUARRY_MINE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> {
  programAddress: Address<TProgram>;
  accounts: {
    mintWrapper: TAccountMetas[0];
    mintWrapperProgram: TAccountMetas[1];
    minter: TAccountMetas[2];
    rewardsTokenMint: TAccountMetas[3];
    rewardsTokenAccount: TAccountMetas[4];
    claimFeeTokenAccount: TAccountMetas[5];
    claimAuthority: TAccountMetas[6];
    claimMiner: TAccountMetas[7];
    claimQuarry: TAccountMetas[8];
    claimTokenProgram: TAccountMetas[9];
    claimRewarder: TAccountMetas[10];
  };
  data: ClaimRewardsV2InstructionData;
}

export function parseClaimRewardsV2Instruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedClaimRewardsV2Instruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mintWrapper: getNextAccount(),
      mintWrapperProgram: getNextAccount(),
      minter: getNextAccount(),
      rewardsTokenMint: getNextAccount(),
      rewardsTokenAccount: getNextAccount(),
      claimFeeTokenAccount: getNextAccount(),
      claimAuthority: getNextAccount(),
      claimMiner: getNextAccount(),
      claimQuarry: getNextAccount(),
      claimTokenProgram: getNextAccount(),
      claimRewarder: getNextAccount(),
    },
    data: getClaimRewardsV2InstructionDataDecoder().decode(instruction.data),
  };
}
