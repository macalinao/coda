/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  AccountMeta,
  AccountSignerMeta,
  Address,
  FixedSizeCodec,
  FixedSizeDecoder,
  FixedSizeEncoder,
  Instruction,
  InstructionWithAccounts,
  InstructionWithData,
  ReadonlyAccount,
  ReadonlyUint8Array,
  TransactionSigner,
  WritableAccount,
  WritableSignerAccount,
} from "@solana/kit";
import type { ResolvedAccount } from "../shared/index.js";
import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
} from "@solana/kit";
import { QUARRY_MERGE_MINE_PROGRAM_ADDRESS } from "../programs/index.js";
import { getAccountMetaFactory } from "../shared/index.js";

export const INIT_MINER_M_M_DISCRIMINATOR: ReadonlyUint8Array = new Uint8Array([
  144, 159, 202, 208, 234, 154, 242, 55,
]);

export function getInitMinerMMDiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    INIT_MINER_M_M_DISCRIMINATOR,
  );
}

export type InitMinerMMInstruction<
  TProgram extends string = typeof QUARRY_MERGE_MINE_PROGRAM_ADDRESS,
  TAccountPool extends string | AccountMeta = string,
  TAccountMm extends string | AccountMeta = string,
  TAccountMiner extends string | AccountMeta = string,
  TAccountQuarry extends string | AccountMeta = string,
  TAccountRewarder extends string | AccountMeta = string,
  TAccountTokenMint extends string | AccountMeta = string,
  TAccountMinerVault extends string | AccountMeta = string,
  TAccountPayer extends string | AccountMeta = string,
  TAccountMineProgram extends
    | string
    | AccountMeta = "QMNeHCGYnLVDn1icRAfQZpjPLBNkfGbSKRB83G5d8KB",
  TAccountSystemProgram extends
    | string
    | AccountMeta = "11111111111111111111111111111111",
  TAccountTokenProgram extends
    | string
    | AccountMeta = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
  TRemainingAccounts extends readonly AccountMeta[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountPool extends string
        ? ReadonlyAccount<TAccountPool>
        : TAccountPool,
      TAccountMm extends string ? ReadonlyAccount<TAccountMm> : TAccountMm,
      TAccountMiner extends string
        ? WritableAccount<TAccountMiner>
        : TAccountMiner,
      TAccountQuarry extends string
        ? WritableAccount<TAccountQuarry>
        : TAccountQuarry,
      TAccountRewarder extends string
        ? ReadonlyAccount<TAccountRewarder>
        : TAccountRewarder,
      TAccountTokenMint extends string
        ? ReadonlyAccount<TAccountTokenMint>
        : TAccountTokenMint,
      TAccountMinerVault extends string
        ? ReadonlyAccount<TAccountMinerVault>
        : TAccountMinerVault,
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountMineProgram extends string
        ? ReadonlyAccount<TAccountMineProgram>
        : TAccountMineProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      ...TRemainingAccounts,
    ]
  >;

export interface InitMinerMMInstructionData {
  discriminator: ReadonlyUint8Array;
  bump: number;
}

export interface InitMinerMMInstructionDataArgs {
  bump: number;
}

export function getInitMinerMMInstructionDataEncoder(): FixedSizeEncoder<InitMinerMMInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["bump", getU8Encoder()],
    ]),
    (value) => ({ ...value, discriminator: INIT_MINER_M_M_DISCRIMINATOR }),
  );
}

export function getInitMinerMMInstructionDataDecoder(): FixedSizeDecoder<InitMinerMMInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["bump", getU8Decoder()],
  ]);
}

export function getInitMinerMMInstructionDataCodec(): FixedSizeCodec<
  InitMinerMMInstructionDataArgs,
  InitMinerMMInstructionData
> {
  return combineCodec(
    getInitMinerMMInstructionDataEncoder(),
    getInitMinerMMInstructionDataDecoder(),
  );
}

export interface InitMinerMMInput<
  TAccountPool extends string = string,
  TAccountMm extends string = string,
  TAccountMiner extends string = string,
  TAccountQuarry extends string = string,
  TAccountRewarder extends string = string,
  TAccountTokenMint extends string = string,
  TAccountMinerVault extends string = string,
  TAccountPayer extends string = string,
  TAccountMineProgram extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountTokenProgram extends string = string,
> {
  pool: Address<TAccountPool>;
  mm: Address<TAccountMm>;
  miner: Address<TAccountMiner>;
  quarry: Address<TAccountQuarry>;
  rewarder: Address<TAccountRewarder>;
  tokenMint: Address<TAccountTokenMint>;
  minerVault: Address<TAccountMinerVault>;
  payer: TransactionSigner<TAccountPayer>;
  mineProgram?: Address<TAccountMineProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
  tokenProgram?: Address<TAccountTokenProgram>;
  bump: InitMinerMMInstructionDataArgs["bump"];
}

export function getInitMinerMMInstruction<
  TAccountPool extends string,
  TAccountMm extends string,
  TAccountMiner extends string,
  TAccountQuarry extends string,
  TAccountRewarder extends string,
  TAccountTokenMint extends string,
  TAccountMinerVault extends string,
  TAccountPayer extends string,
  TAccountMineProgram extends string,
  TAccountSystemProgram extends string,
  TAccountTokenProgram extends string,
  TProgramAddress extends Address = typeof QUARRY_MERGE_MINE_PROGRAM_ADDRESS,
>(
  input: InitMinerMMInput<
    TAccountPool,
    TAccountMm,
    TAccountMiner,
    TAccountQuarry,
    TAccountRewarder,
    TAccountTokenMint,
    TAccountMinerVault,
    TAccountPayer,
    TAccountMineProgram,
    TAccountSystemProgram,
    TAccountTokenProgram
  >,
  config?: { programAddress?: TProgramAddress },
): InitMinerMMInstruction<
  TProgramAddress,
  TAccountPool,
  TAccountMm,
  TAccountMiner,
  TAccountQuarry,
  TAccountRewarder,
  TAccountTokenMint,
  TAccountMinerVault,
  TAccountPayer,
  TAccountMineProgram,
  TAccountSystemProgram,
  TAccountTokenProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? QUARRY_MERGE_MINE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    pool: { value: input.pool ?? null, isWritable: false },
    mm: { value: input.mm ?? null, isWritable: false },
    miner: { value: input.miner ?? null, isWritable: true },
    quarry: { value: input.quarry ?? null, isWritable: true },
    rewarder: { value: input.rewarder ?? null, isWritable: false },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    minerVault: { value: input.minerVault ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: true },
    mineProgram: { value: input.mineProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.mineProgram.value) {
    accounts.mineProgram.value =
      "QMNeHCGYnLVDn1icRAfQZpjPLBNkfGbSKRB83G5d8KB" as Address<"QMNeHCGYnLVDn1icRAfQZpjPLBNkfGbSKRB83G5d8KB">;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.mm),
      getAccountMeta(accounts.miner),
      getAccountMeta(accounts.quarry),
      getAccountMeta(accounts.rewarder),
      getAccountMeta(accounts.tokenMint),
      getAccountMeta(accounts.minerVault),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.mineProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram),
    ],
    programAddress,
    data: getInitMinerMMInstructionDataEncoder().encode(
      args as InitMinerMMInstructionDataArgs,
    ),
  } as InitMinerMMInstruction<
    TProgramAddress,
    TAccountPool,
    TAccountMm,
    TAccountMiner,
    TAccountQuarry,
    TAccountRewarder,
    TAccountTokenMint,
    TAccountMinerVault,
    TAccountPayer,
    TAccountMineProgram,
    TAccountSystemProgram,
    TAccountTokenProgram
  >;

  return instruction;
}

export interface ParsedInitMinerMMInstruction<
  TProgram extends string = typeof QUARRY_MERGE_MINE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> {
  programAddress: Address<TProgram>;
  accounts: {
    pool: TAccountMetas[0];
    mm: TAccountMetas[1];
    miner: TAccountMetas[2];
    quarry: TAccountMetas[3];
    rewarder: TAccountMetas[4];
    tokenMint: TAccountMetas[5];
    minerVault: TAccountMetas[6];
    payer: TAccountMetas[7];
    mineProgram: TAccountMetas[8];
    systemProgram: TAccountMetas[9];
    tokenProgram: TAccountMetas[10];
  };
  data: InitMinerMMInstructionData;
}

export function parseInitMinerMMInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedInitMinerMMInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      pool: getNextAccount(),
      mm: getNextAccount(),
      miner: getNextAccount(),
      quarry: getNextAccount(),
      rewarder: getNextAccount(),
      tokenMint: getNextAccount(),
      minerVault: getNextAccount(),
      payer: getNextAccount(),
      mineProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      tokenProgram: getNextAccount(),
    },
    data: getInitMinerMMInstructionDataDecoder().decode(instruction.data),
  };
}
