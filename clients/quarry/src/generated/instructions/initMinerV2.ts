/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  AccountMeta,
  AccountSignerMeta,
  Address,
  FixedSizeCodec,
  FixedSizeDecoder,
  FixedSizeEncoder,
  Instruction,
  InstructionWithAccounts,
  InstructionWithData,
  ReadonlyAccount,
  ReadonlyUint8Array,
  TransactionSigner,
  WritableAccount,
  WritableSignerAccount,
} from "@solana/kit";
import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
} from "@solana/kit";
import { QUARRY_MERGE_MINE_PROGRAM_ADDRESS } from "../programs/index.js";
import type { ResolvedAccount } from "../shared/index.js";
import { getAccountMetaFactory } from "../shared/index.js";

export const INIT_MINER_V2_DISCRIMINATOR = new Uint8Array([
  189, 125, 116, 157, 73, 4, 253, 156,
]);

export function getInitMinerV2DiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    INIT_MINER_V2_DISCRIMINATOR,
  );
}

export type InitMinerV2Instruction<
  TProgram extends string = typeof QUARRY_MERGE_MINE_PROGRAM_ADDRESS,
  TAccountPool extends string | AccountMeta = string,
  TAccountMm extends string | AccountMeta = string,
  TAccountMiner extends string | AccountMeta = string,
  TAccountQuarry extends string | AccountMeta = string,
  TAccountRewarder extends string | AccountMeta = string,
  TAccountTokenMint extends string | AccountMeta = string,
  TAccountMinerVault extends string | AccountMeta = string,
  TAccountPayer extends string | AccountMeta = string,
  TAccountMineProgram extends
    | string
    | AccountMeta = "QMNeHCGYnLVDn1icRAfQZpjPLBNkfGbSKRB83G5d8KB",
  TAccountSystemProgram extends
    | string
    | AccountMeta = "11111111111111111111111111111111",
  TAccountTokenProgram extends
    | string
    | AccountMeta = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
  TRemainingAccounts extends readonly AccountMeta[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountPool extends string
        ? ReadonlyAccount<TAccountPool>
        : TAccountPool,
      TAccountMm extends string ? ReadonlyAccount<TAccountMm> : TAccountMm,
      TAccountMiner extends string
        ? WritableAccount<TAccountMiner>
        : TAccountMiner,
      TAccountQuarry extends string
        ? WritableAccount<TAccountQuarry>
        : TAccountQuarry,
      TAccountRewarder extends string
        ? ReadonlyAccount<TAccountRewarder>
        : TAccountRewarder,
      TAccountTokenMint extends string
        ? ReadonlyAccount<TAccountTokenMint>
        : TAccountTokenMint,
      TAccountMinerVault extends string
        ? ReadonlyAccount<TAccountMinerVault>
        : TAccountMinerVault,
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountMineProgram extends string
        ? ReadonlyAccount<TAccountMineProgram>
        : TAccountMineProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      ...TRemainingAccounts,
    ]
  >;

export interface InitMinerV2InstructionData {
  discriminator: ReadonlyUint8Array;
}

export interface InitMinerV2InstructionDataArgs {}

export function getInitMinerV2InstructionDataEncoder(): FixedSizeEncoder<InitMinerV2InstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]),
    (value) => ({ ...value, discriminator: INIT_MINER_V2_DISCRIMINATOR }),
  );
}

export function getInitMinerV2InstructionDataDecoder(): FixedSizeDecoder<InitMinerV2InstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
  ]);
}

export function getInitMinerV2InstructionDataCodec(): FixedSizeCodec<
  InitMinerV2InstructionDataArgs,
  InitMinerV2InstructionData
> {
  return combineCodec(
    getInitMinerV2InstructionDataEncoder(),
    getInitMinerV2InstructionDataDecoder(),
  );
}

export interface InitMinerV2Input<
  TAccountPool extends string = string,
  TAccountMm extends string = string,
  TAccountMiner extends string = string,
  TAccountQuarry extends string = string,
  TAccountRewarder extends string = string,
  TAccountTokenMint extends string = string,
  TAccountMinerVault extends string = string,
  TAccountPayer extends string = string,
  TAccountMineProgram extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountTokenProgram extends string = string,
> {
  pool: Address<TAccountPool>;
  mm: Address<TAccountMm>;
  miner: Address<TAccountMiner>;
  quarry: Address<TAccountQuarry>;
  rewarder: Address<TAccountRewarder>;
  tokenMint: Address<TAccountTokenMint>;
  minerVault: Address<TAccountMinerVault>;
  payer: TransactionSigner<TAccountPayer>;
  mineProgram?: Address<TAccountMineProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
  tokenProgram?: Address<TAccountTokenProgram>;
}

export function getInitMinerV2Instruction<
  TAccountPool extends string,
  TAccountMm extends string,
  TAccountMiner extends string,
  TAccountQuarry extends string,
  TAccountRewarder extends string,
  TAccountTokenMint extends string,
  TAccountMinerVault extends string,
  TAccountPayer extends string,
  TAccountMineProgram extends string,
  TAccountSystemProgram extends string,
  TAccountTokenProgram extends string,
  TProgramAddress extends Address = typeof QUARRY_MERGE_MINE_PROGRAM_ADDRESS,
>(
  input: InitMinerV2Input<
    TAccountPool,
    TAccountMm,
    TAccountMiner,
    TAccountQuarry,
    TAccountRewarder,
    TAccountTokenMint,
    TAccountMinerVault,
    TAccountPayer,
    TAccountMineProgram,
    TAccountSystemProgram,
    TAccountTokenProgram
  >,
  config?: { programAddress?: TProgramAddress },
): InitMinerV2Instruction<
  TProgramAddress,
  TAccountPool,
  TAccountMm,
  TAccountMiner,
  TAccountQuarry,
  TAccountRewarder,
  TAccountTokenMint,
  TAccountMinerVault,
  TAccountPayer,
  TAccountMineProgram,
  TAccountSystemProgram,
  TAccountTokenProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? QUARRY_MERGE_MINE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    pool: { value: input.pool ?? null, isWritable: false },
    mm: { value: input.mm ?? null, isWritable: false },
    miner: { value: input.miner ?? null, isWritable: true },
    quarry: { value: input.quarry ?? null, isWritable: true },
    rewarder: { value: input.rewarder ?? null, isWritable: false },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    minerVault: { value: input.minerVault ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: true },
    mineProgram: { value: input.mineProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.mineProgram.value) {
    accounts.mineProgram.value =
      "QMNeHCGYnLVDn1icRAfQZpjPLBNkfGbSKRB83G5d8KB" as Address<"QMNeHCGYnLVDn1icRAfQZpjPLBNkfGbSKRB83G5d8KB">;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.mm),
      getAccountMeta(accounts.miner),
      getAccountMeta(accounts.quarry),
      getAccountMeta(accounts.rewarder),
      getAccountMeta(accounts.tokenMint),
      getAccountMeta(accounts.minerVault),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.mineProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram),
    ],
    programAddress,
    data: getInitMinerV2InstructionDataEncoder().encode({}),
  } as InitMinerV2Instruction<
    TProgramAddress,
    TAccountPool,
    TAccountMm,
    TAccountMiner,
    TAccountQuarry,
    TAccountRewarder,
    TAccountTokenMint,
    TAccountMinerVault,
    TAccountPayer,
    TAccountMineProgram,
    TAccountSystemProgram,
    TAccountTokenProgram
  >;

  return instruction;
}

export interface ParsedInitMinerV2Instruction<
  TProgram extends string = typeof QUARRY_MERGE_MINE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> {
  programAddress: Address<TProgram>;
  accounts: {
    pool: TAccountMetas[0];
    mm: TAccountMetas[1];
    miner: TAccountMetas[2];
    quarry: TAccountMetas[3];
    rewarder: TAccountMetas[4];
    tokenMint: TAccountMetas[5];
    minerVault: TAccountMetas[6];
    payer: TAccountMetas[7];
    mineProgram: TAccountMetas[8];
    systemProgram: TAccountMetas[9];
    tokenProgram: TAccountMetas[10];
  };
  data: InitMinerV2InstructionData;
}

export function parseInitMinerV2Instruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedInitMinerV2Instruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      pool: getNextAccount(),
      mm: getNextAccount(),
      miner: getNextAccount(),
      quarry: getNextAccount(),
      rewarder: getNextAccount(),
      tokenMint: getNextAccount(),
      minerVault: getNextAccount(),
      payer: getNextAccount(),
      mineProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      tokenProgram: getNextAccount(),
    },
    data: getInitMinerV2InstructionDataDecoder().decode(instruction.data),
  };
}
