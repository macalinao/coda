/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  FixedSizeCodec,
  FixedSizeDecoder,
  FixedSizeEncoder,
} from "@solana/kit";
import {
  combineCodec,
  getArrayDecoder,
  getArrayEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  getU16Decoder,
  getU16Encoder,
  getU128Decoder,
  getU128Encoder,
} from "@solana/kit";

/**
 * A single obligation order.
 * See [Obligation::orders].
 */
export interface ObligationOrderInput {
  /**
   * A threshold value used by the condition (scaled [Fraction]).
   * The exact meaning depends on the specific [Self::condition_type].
   *
   * Examples:
   * - when `condition_type == 2 (UserLtvBelow)`:
   * then a value of `0.455` here means that the order is active only when the obligation's
   * user LTV is less than `0.455` (i.e. < 45.5%).
   * - when `condition_type == 3 (DebtCollPriceRatioAbove)`:
   * assuming the obligation uses BTC collateral for SOL debt, then a value of `491.3` here
   * means that the order is active only when the BTC-SOL price is greater than `491.3` (i.e.
   * > 491.3 SOL per BTC).
   */
  conditionThresholdSf: bigint;
  /**
   * A configuration parameter used by the opportunity (scaled [Fraction]).
   * The exact meaning depends on the specific [Self::opportunity_type].
   *
   * Examples:
   * - when `opportunity_type == 0 (DeleverageSingleDebtAmount)`:
   * Assuming the obligation uses BTC collateral for SOL debt, then a value of `1_234_000_000`
   * here means that a liquidator may repay up to 1234000000 lamports (i.e. 1.234 SOL) on this
   * obligation.
   * Note: the special value of [Fraction::MAX] is *not* allowed in this case.
   * - when `opportunity_type == 1 (DeleverageAllDebtAmount)`:
   * The only allowed value in this case is [Fraction::MAX] (to emphasize that *all* debt
   * should be repaid).
   */
  opportunityParameterSf: bigint;
  /**
   * A *minimum* additional fraction of collateral transferred to the liquidator, in bps.
   *
   * The minimum bonus is applied exactly when the [Self::condition_threshold_sf] is met, and
   * grows linearly towards the [Self::max_execution_bonus_bps].
   *
   * Example: a value of `50` here means 50bps == 0.5% bonus for an "LTV > 65%" order, when
   * executed precisely at the moment LTV exceeds 65%.
   */
  minExecutionBonusBps: number;
  /**
   * A *maximum* additional fraction of collateral transferred to the liquidator, in bps.
   *
   * The maximum bonus is applied at the relevant "extreme" state of the obligation, i.e.:
   * - for a stop-loss condition, it is a point at which the obligation becomes liquidatable;
   * - for a take-profit condition, it is a point at which obligation has 0% LTV.
   *
   * In non-extreme states, the actual bonus value is interpolated linearly, starting from
   * [Self::min_execution_bonus_bps] (at the point specified by the order's condition).
   *
   * Example: a value of `300` here means 300bps == 3.0% bonus for a "debt/coll price > 140"
   * order, when executed at a higher price = 200, at which the obligation's LTV happens to
   * be equal to its liquidation LTV.
   */
  maxExecutionBonusBps: number;
  /**
   * Serialized [ConditionType].
   * The entire order is void when this is zeroed (i.e. representing [ConditionType::Never]).
   *
   * Example: a value of `2` here denotes `UserLtvBelow` condition type. Of course, to
   * interpret this condition, we also need to take the [Self::condition_threshold_sf] into
   * account.
   */
  conditionType: number;
  /**
   * Serialized [OpportunityType].
   *
   * Example: a value of `0` here denotes `DeleverageSingleDebtAmount` opportunity. Of course, to
   * interpret this opportunity, we also need to take the [Self::opportunity_parameter_sf] into
   * account.
   */
  opportunityType: number;
  /**
   * Internal padding.
   * The fields above take up 2+2+1+1 bytes = 48 bits, which means we need 80 bits = 10 bytes to
   * align with `u128`s.
   */
  padding1: number[];
  /**
   * End padding.
   * The total size of a single instance is 8*u128 = 128 bytes.
   */
  padding2: bigint[];
}

export interface ObligationOrderInputArgs {
  /**
   * A threshold value used by the condition (scaled [Fraction]).
   * The exact meaning depends on the specific [Self::condition_type].
   *
   * Examples:
   * - when `condition_type == 2 (UserLtvBelow)`:
   * then a value of `0.455` here means that the order is active only when the obligation's
   * user LTV is less than `0.455` (i.e. < 45.5%).
   * - when `condition_type == 3 (DebtCollPriceRatioAbove)`:
   * assuming the obligation uses BTC collateral for SOL debt, then a value of `491.3` here
   * means that the order is active only when the BTC-SOL price is greater than `491.3` (i.e.
   * > 491.3 SOL per BTC).
   */
  conditionThresholdSf: number | bigint;
  /**
   * A configuration parameter used by the opportunity (scaled [Fraction]).
   * The exact meaning depends on the specific [Self::opportunity_type].
   *
   * Examples:
   * - when `opportunity_type == 0 (DeleverageSingleDebtAmount)`:
   * Assuming the obligation uses BTC collateral for SOL debt, then a value of `1_234_000_000`
   * here means that a liquidator may repay up to 1234000000 lamports (i.e. 1.234 SOL) on this
   * obligation.
   * Note: the special value of [Fraction::MAX] is *not* allowed in this case.
   * - when `opportunity_type == 1 (DeleverageAllDebtAmount)`:
   * The only allowed value in this case is [Fraction::MAX] (to emphasize that *all* debt
   * should be repaid).
   */
  opportunityParameterSf: number | bigint;
  /**
   * A *minimum* additional fraction of collateral transferred to the liquidator, in bps.
   *
   * The minimum bonus is applied exactly when the [Self::condition_threshold_sf] is met, and
   * grows linearly towards the [Self::max_execution_bonus_bps].
   *
   * Example: a value of `50` here means 50bps == 0.5% bonus for an "LTV > 65%" order, when
   * executed precisely at the moment LTV exceeds 65%.
   */
  minExecutionBonusBps: number;
  /**
   * A *maximum* additional fraction of collateral transferred to the liquidator, in bps.
   *
   * The maximum bonus is applied at the relevant "extreme" state of the obligation, i.e.:
   * - for a stop-loss condition, it is a point at which the obligation becomes liquidatable;
   * - for a take-profit condition, it is a point at which obligation has 0% LTV.
   *
   * In non-extreme states, the actual bonus value is interpolated linearly, starting from
   * [Self::min_execution_bonus_bps] (at the point specified by the order's condition).
   *
   * Example: a value of `300` here means 300bps == 3.0% bonus for a "debt/coll price > 140"
   * order, when executed at a higher price = 200, at which the obligation's LTV happens to
   * be equal to its liquidation LTV.
   */
  maxExecutionBonusBps: number;
  /**
   * Serialized [ConditionType].
   * The entire order is void when this is zeroed (i.e. representing [ConditionType::Never]).
   *
   * Example: a value of `2` here denotes `UserLtvBelow` condition type. Of course, to
   * interpret this condition, we also need to take the [Self::condition_threshold_sf] into
   * account.
   */
  conditionType: number;
  /**
   * Serialized [OpportunityType].
   *
   * Example: a value of `0` here denotes `DeleverageSingleDebtAmount` opportunity. Of course, to
   * interpret this opportunity, we also need to take the [Self::opportunity_parameter_sf] into
   * account.
   */
  opportunityType: number;
  /**
   * Internal padding.
   * The fields above take up 2+2+1+1 bytes = 48 bits, which means we need 80 bits = 10 bytes to
   * align with `u128`s.
   */
  padding1: number[];
  /**
   * End padding.
   * The total size of a single instance is 8*u128 = 128 bytes.
   */
  padding2: (number | bigint)[];
}

export function getObligationOrderInputEncoder(): FixedSizeEncoder<ObligationOrderInputArgs> {
  return getStructEncoder([
    ["conditionThresholdSf", getU128Encoder()],
    ["opportunityParameterSf", getU128Encoder()],
    ["minExecutionBonusBps", getU16Encoder()],
    ["maxExecutionBonusBps", getU16Encoder()],
    ["conditionType", getU8Encoder()],
    ["opportunityType", getU8Encoder()],
    ["padding1", getArrayEncoder(getU8Encoder(), { size: 10 })],
    ["padding2", getArrayEncoder(getU128Encoder(), { size: 5 })],
  ]);
}

export function getObligationOrderInputDecoder(): FixedSizeDecoder<ObligationOrderInput> {
  return getStructDecoder([
    ["conditionThresholdSf", getU128Decoder()],
    ["opportunityParameterSf", getU128Decoder()],
    ["minExecutionBonusBps", getU16Decoder()],
    ["maxExecutionBonusBps", getU16Decoder()],
    ["conditionType", getU8Decoder()],
    ["opportunityType", getU8Decoder()],
    ["padding1", getArrayDecoder(getU8Decoder(), { size: 10 })],
    ["padding2", getArrayDecoder(getU128Decoder(), { size: 5 })],
  ]);
}

export function getObligationOrderInputCodec(): FixedSizeCodec<
  ObligationOrderInputArgs,
  ObligationOrderInput
> {
  return combineCodec(
    getObligationOrderInputEncoder(),
    getObligationOrderInputDecoder(),
  );
}
