/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  combineCodec,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  transformEncoder,
  type WritableAccount,
} from "@solana/kit";
import { KAMINO_LENDING_PROGRAM_ADDRESS } from "../programs/index.js";
import {
  getAccountMetaFactory,
  type ResolvedAccount,
} from "../shared/index.js";

export const REQUEST_ELEVATION_GROUP_DISCRIMINATOR = new Uint8Array([
  36, 119, 251, 129, 34, 240, 7, 147,
]);

export function getRequestElevationGroupDiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    REQUEST_ELEVATION_GROUP_DISCRIMINATOR,
  );
}

export type RequestElevationGroupInstruction<
  TProgram extends string = typeof KAMINO_LENDING_PROGRAM_ADDRESS,
  TAccountOwner extends string | AccountMeta<string> = string,
  TAccountObligation extends string | AccountMeta<string> = string,
  TAccountLendingMarket extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountOwner extends string
        ? ReadonlySignerAccount<TAccountOwner> &
            AccountSignerMeta<TAccountOwner>
        : TAccountOwner,
      TAccountObligation extends string
        ? WritableAccount<TAccountObligation>
        : TAccountObligation,
      TAccountLendingMarket extends string
        ? ReadonlyAccount<TAccountLendingMarket>
        : TAccountLendingMarket,
      ...TRemainingAccounts,
    ]
  >;

export type RequestElevationGroupInstructionData = {
  discriminator: ReadonlyUint8Array;
  elevationGroup: number;
};

export type RequestElevationGroupInstructionDataArgs = {
  elevationGroup: number;
};

export function getRequestElevationGroupInstructionDataEncoder(): FixedSizeEncoder<RequestElevationGroupInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["elevationGroup", getU8Encoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: REQUEST_ELEVATION_GROUP_DISCRIMINATOR,
    }),
  );
}

export function getRequestElevationGroupInstructionDataDecoder(): FixedSizeDecoder<RequestElevationGroupInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["elevationGroup", getU8Decoder()],
  ]);
}

export function getRequestElevationGroupInstructionDataCodec(): FixedSizeCodec<
  RequestElevationGroupInstructionDataArgs,
  RequestElevationGroupInstructionData
> {
  return combineCodec(
    getRequestElevationGroupInstructionDataEncoder(),
    getRequestElevationGroupInstructionDataDecoder(),
  );
}

export type RequestElevationGroupInput<
  TAccountOwner extends string = string,
  TAccountObligation extends string = string,
  TAccountLendingMarket extends string = string,
> = {
  owner: TransactionSigner<TAccountOwner>;
  obligation: Address<TAccountObligation>;
  lendingMarket: Address<TAccountLendingMarket>;
  elevationGroup: RequestElevationGroupInstructionDataArgs["elevationGroup"];
};

export function getRequestElevationGroupInstruction<
  TAccountOwner extends string,
  TAccountObligation extends string,
  TAccountLendingMarket extends string,
  TProgramAddress extends Address = typeof KAMINO_LENDING_PROGRAM_ADDRESS,
>(
  input: RequestElevationGroupInput<
    TAccountOwner,
    TAccountObligation,
    TAccountLendingMarket
  >,
  config?: { programAddress?: TProgramAddress },
): RequestElevationGroupInstruction<
  TProgramAddress,
  TAccountOwner,
  TAccountObligation,
  TAccountLendingMarket
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? KAMINO_LENDING_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: false },
    obligation: { value: input.obligation ?? null, isWritable: true },
    lendingMarket: { value: input.lendingMarket ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.obligation),
      getAccountMeta(accounts.lendingMarket),
    ],
    programAddress,
    data: getRequestElevationGroupInstructionDataEncoder().encode(
      args as RequestElevationGroupInstructionDataArgs,
    ),
  } as RequestElevationGroupInstruction<
    TProgramAddress,
    TAccountOwner,
    TAccountObligation,
    TAccountLendingMarket
  >;

  return instruction;
}

export type ParsedRequestElevationGroupInstruction<
  TProgram extends string = typeof KAMINO_LENDING_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    owner: TAccountMetas[0];
    obligation: TAccountMetas[1];
    lendingMarket: TAccountMetas[2];
  };
  data: RequestElevationGroupInstructionData;
};

export function parseRequestElevationGroupInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedRequestElevationGroupInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 3) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      owner: getNextAccount(),
      obligation: getNextAccount(),
      lendingMarket: getNextAccount(),
    },
    data: getRequestElevationGroupInstructionDataDecoder().decode(
      instruction.data,
    ),
  };
}
