/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  AccountMeta,
  AccountSignerMeta,
  Address,
  FixedSizeCodec,
  FixedSizeDecoder,
  FixedSizeEncoder,
  Instruction,
  InstructionWithAccounts,
  InstructionWithData,
  ReadonlyAccount,
  ReadonlyUint8Array,
  TransactionSigner,
  WritableAccount,
  WritableSignerAccount,
} from "@solana/kit";
import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
} from "@solana/kit";
import { KAMINO_LENDING_PROGRAM_ADDRESS } from "../programs/index.js";
import type { ResolvedAccount } from "../shared/index.js";
import { getAccountMetaFactory } from "../shared/index.js";

export const INIT_OBLIGATION_FARMS_FOR_RESERVE_DISCRIMINATOR: ReadonlyUint8Array =
  new Uint8Array([136, 63, 15, 186, 211, 152, 168, 164]);

export function getInitObligationFarmsForReserveDiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    INIT_OBLIGATION_FARMS_FOR_RESERVE_DISCRIMINATOR,
  );
}

export type InitObligationFarmsForReserveInstruction<
  TProgram extends string = typeof KAMINO_LENDING_PROGRAM_ADDRESS,
  TAccountPayer extends string | AccountMeta = string,
  TAccountOwner extends string | AccountMeta = string,
  TAccountObligation extends string | AccountMeta = string,
  TAccountLendingMarketAuthority extends string | AccountMeta = string,
  TAccountReserve extends string | AccountMeta = string,
  TAccountReserveFarmState extends string | AccountMeta = string,
  TAccountObligationFarm extends string | AccountMeta = string,
  TAccountLendingMarket extends string | AccountMeta = string,
  TAccountFarmsProgram extends string | AccountMeta = string,
  TAccountRent extends string | AccountMeta = string,
  TAccountSystemProgram extends string | AccountMeta = string,
  TRemainingAccounts extends readonly AccountMeta[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountOwner extends string
        ? ReadonlyAccount<TAccountOwner>
        : TAccountOwner,
      TAccountObligation extends string
        ? WritableAccount<TAccountObligation>
        : TAccountObligation,
      TAccountLendingMarketAuthority extends string
        ? ReadonlyAccount<TAccountLendingMarketAuthority>
        : TAccountLendingMarketAuthority,
      TAccountReserve extends string
        ? WritableAccount<TAccountReserve>
        : TAccountReserve,
      TAccountReserveFarmState extends string
        ? WritableAccount<TAccountReserveFarmState>
        : TAccountReserveFarmState,
      TAccountObligationFarm extends string
        ? WritableAccount<TAccountObligationFarm>
        : TAccountObligationFarm,
      TAccountLendingMarket extends string
        ? ReadonlyAccount<TAccountLendingMarket>
        : TAccountLendingMarket,
      TAccountFarmsProgram extends string
        ? ReadonlyAccount<TAccountFarmsProgram>
        : TAccountFarmsProgram,
      TAccountRent extends string
        ? ReadonlyAccount<TAccountRent>
        : TAccountRent,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export interface InitObligationFarmsForReserveInstructionData {
  discriminator: ReadonlyUint8Array;
  mode: number;
}

export interface InitObligationFarmsForReserveInstructionDataArgs {
  mode: number;
}

export function getInitObligationFarmsForReserveInstructionDataEncoder(): FixedSizeEncoder<InitObligationFarmsForReserveInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["mode", getU8Encoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: INIT_OBLIGATION_FARMS_FOR_RESERVE_DISCRIMINATOR,
    }),
  );
}

export function getInitObligationFarmsForReserveInstructionDataDecoder(): FixedSizeDecoder<InitObligationFarmsForReserveInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["mode", getU8Decoder()],
  ]);
}

export function getInitObligationFarmsForReserveInstructionDataCodec(): FixedSizeCodec<
  InitObligationFarmsForReserveInstructionDataArgs,
  InitObligationFarmsForReserveInstructionData
> {
  return combineCodec(
    getInitObligationFarmsForReserveInstructionDataEncoder(),
    getInitObligationFarmsForReserveInstructionDataDecoder(),
  );
}

export interface InitObligationFarmsForReserveInput<
  TAccountPayer extends string = string,
  TAccountOwner extends string = string,
  TAccountObligation extends string = string,
  TAccountLendingMarketAuthority extends string = string,
  TAccountReserve extends string = string,
  TAccountReserveFarmState extends string = string,
  TAccountObligationFarm extends string = string,
  TAccountLendingMarket extends string = string,
  TAccountFarmsProgram extends string = string,
  TAccountRent extends string = string,
  TAccountSystemProgram extends string = string,
> {
  payer: TransactionSigner<TAccountPayer>;
  owner: Address<TAccountOwner>;
  obligation: Address<TAccountObligation>;
  lendingMarketAuthority: Address<TAccountLendingMarketAuthority>;
  reserve: Address<TAccountReserve>;
  reserveFarmState: Address<TAccountReserveFarmState>;
  obligationFarm: Address<TAccountObligationFarm>;
  lendingMarket: Address<TAccountLendingMarket>;
  farmsProgram: Address<TAccountFarmsProgram>;
  rent: Address<TAccountRent>;
  systemProgram: Address<TAccountSystemProgram>;
  mode: InitObligationFarmsForReserveInstructionDataArgs["mode"];
}

export function getInitObligationFarmsForReserveInstruction<
  TAccountPayer extends string,
  TAccountOwner extends string,
  TAccountObligation extends string,
  TAccountLendingMarketAuthority extends string,
  TAccountReserve extends string,
  TAccountReserveFarmState extends string,
  TAccountObligationFarm extends string,
  TAccountLendingMarket extends string,
  TAccountFarmsProgram extends string,
  TAccountRent extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof KAMINO_LENDING_PROGRAM_ADDRESS,
>(
  input: InitObligationFarmsForReserveInput<
    TAccountPayer,
    TAccountOwner,
    TAccountObligation,
    TAccountLendingMarketAuthority,
    TAccountReserve,
    TAccountReserveFarmState,
    TAccountObligationFarm,
    TAccountLendingMarket,
    TAccountFarmsProgram,
    TAccountRent,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress },
): InitObligationFarmsForReserveInstruction<
  TProgramAddress,
  TAccountPayer,
  TAccountOwner,
  TAccountObligation,
  TAccountLendingMarketAuthority,
  TAccountReserve,
  TAccountReserveFarmState,
  TAccountObligationFarm,
  TAccountLendingMarket,
  TAccountFarmsProgram,
  TAccountRent,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? KAMINO_LENDING_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    obligation: { value: input.obligation ?? null, isWritable: true },
    lendingMarketAuthority: {
      value: input.lendingMarketAuthority ?? null,
      isWritable: false,
    },
    reserve: { value: input.reserve ?? null, isWritable: true },
    reserveFarmState: {
      value: input.reserveFarmState ?? null,
      isWritable: true,
    },
    obligationFarm: { value: input.obligationFarm ?? null, isWritable: true },
    lendingMarket: { value: input.lendingMarket ?? null, isWritable: false },
    farmsProgram: { value: input.farmsProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.obligation),
      getAccountMeta(accounts.lendingMarketAuthority),
      getAccountMeta(accounts.reserve),
      getAccountMeta(accounts.reserveFarmState),
      getAccountMeta(accounts.obligationFarm),
      getAccountMeta(accounts.lendingMarket),
      getAccountMeta(accounts.farmsProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.systemProgram),
    ],
    programAddress,
    data: getInitObligationFarmsForReserveInstructionDataEncoder().encode(
      args as InitObligationFarmsForReserveInstructionDataArgs,
    ),
  } as InitObligationFarmsForReserveInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountOwner,
    TAccountObligation,
    TAccountLendingMarketAuthority,
    TAccountReserve,
    TAccountReserveFarmState,
    TAccountObligationFarm,
    TAccountLendingMarket,
    TAccountFarmsProgram,
    TAccountRent,
    TAccountSystemProgram
  >;

  return instruction;
}

export interface ParsedInitObligationFarmsForReserveInstruction<
  TProgram extends string = typeof KAMINO_LENDING_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> {
  programAddress: Address<TProgram>;
  accounts: {
    payer: TAccountMetas[0];
    owner: TAccountMetas[1];
    obligation: TAccountMetas[2];
    lendingMarketAuthority: TAccountMetas[3];
    reserve: TAccountMetas[4];
    reserveFarmState: TAccountMetas[5];
    obligationFarm: TAccountMetas[6];
    lendingMarket: TAccountMetas[7];
    farmsProgram: TAccountMetas[8];
    rent: TAccountMetas[9];
    systemProgram: TAccountMetas[10];
  };
  data: InitObligationFarmsForReserveInstructionData;
}

export function parseInitObligationFarmsForReserveInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedInitObligationFarmsForReserveInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      owner: getNextAccount(),
      obligation: getNextAccount(),
      lendingMarketAuthority: getNextAccount(),
      reserve: getNextAccount(),
      reserveFarmState: getNextAccount(),
      obligationFarm: getNextAccount(),
      lendingMarket: getNextAccount(),
      farmsProgram: getNextAccount(),
      rent: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getInitObligationFarmsForReserveInstructionDataDecoder().decode(
      instruction.data,
    ),
  };
}
