/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  Account,
  Address,
  EncodedAccount,
  FetchAccountConfig,
  FetchAccountsConfig,
  FixedSizeCodec,
  FixedSizeDecoder,
  FixedSizeEncoder,
  MaybeAccount,
  MaybeEncodedAccount,
  ReadonlyUint8Array,
} from "@solana/kit";
import type {
  ElevationGroupLendingMarket,
  ElevationGroupLendingMarketArgs,
} from "../types/index.js";
import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  getU16Decoder,
  getU16Encoder,
  getU64Decoder,
  getU64Encoder,
  getU128Decoder,
  getU128Encoder,
  transformEncoder,
} from "@solana/kit";
import {
  getElevationGroupLendingMarketDecoder,
  getElevationGroupLendingMarketEncoder,
} from "../types/index.js";

export const LENDING_MARKET_DISCRIMINATOR: ReadonlyUint8Array = new Uint8Array([
  246, 114, 50, 98, 72, 157, 28, 120,
]);

export function getLendingMarketDiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    LENDING_MARKET_DISCRIMINATOR,
  );
}

export interface LendingMarket {
  discriminator: ReadonlyUint8Array;
  version: bigint;
  bumpSeed: bigint;
  lendingMarketOwner: Address;
  lendingMarketOwnerCached: Address;
  quoteCurrency: number[];
  referralFeeBps: number;
  emergencyMode: number;
  autodeleverageEnabled: number;
  borrowDisabled: number;
  priceRefreshTriggerToMaxAgePct: number;
  liquidationMaxDebtCloseFactorPct: number;
  insolvencyRiskUnhealthyLtvPct: number;
  minFullLiquidationValueThreshold: bigint;
  maxLiquidatableDebtMarketValueAtOnce: bigint;
  reserved0: number[];
  globalAllowedBorrowValue: bigint;
  riskCouncil: Address;
  reserved1: number[];
  elevationGroups: ElevationGroupLendingMarket[];
  elevationGroupPadding: bigint[];
  minNetValueInObligationSf: bigint;
  minValueSkipLiquidationLtvChecks: bigint;
  name: number[];
  minValueSkipLiquidationBfChecks: bigint;
  individualAutodeleverageMarginCallPeriodSecs: bigint;
  minInitialDepositAmount: bigint;
  padding1: bigint[];
}

export interface LendingMarketArgs {
  version: number | bigint;
  bumpSeed: number | bigint;
  lendingMarketOwner: Address;
  lendingMarketOwnerCached: Address;
  quoteCurrency: number[];
  referralFeeBps: number;
  emergencyMode: number;
  autodeleverageEnabled: number;
  borrowDisabled: number;
  priceRefreshTriggerToMaxAgePct: number;
  liquidationMaxDebtCloseFactorPct: number;
  insolvencyRiskUnhealthyLtvPct: number;
  minFullLiquidationValueThreshold: number | bigint;
  maxLiquidatableDebtMarketValueAtOnce: number | bigint;
  reserved0: number[];
  globalAllowedBorrowValue: number | bigint;
  riskCouncil: Address;
  reserved1: number[];
  elevationGroups: ElevationGroupLendingMarketArgs[];
  elevationGroupPadding: (number | bigint)[];
  minNetValueInObligationSf: number | bigint;
  minValueSkipLiquidationLtvChecks: number | bigint;
  name: number[];
  minValueSkipLiquidationBfChecks: number | bigint;
  individualAutodeleverageMarginCallPeriodSecs: number | bigint;
  minInitialDepositAmount: number | bigint;
  padding1: (number | bigint)[];
}

export function getLendingMarketEncoder(): FixedSizeEncoder<LendingMarketArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["version", getU64Encoder()],
      ["bumpSeed", getU64Encoder()],
      ["lendingMarketOwner", getAddressEncoder()],
      ["lendingMarketOwnerCached", getAddressEncoder()],
      ["quoteCurrency", getArrayEncoder(getU8Encoder(), { size: 32 })],
      ["referralFeeBps", getU16Encoder()],
      ["emergencyMode", getU8Encoder()],
      ["autodeleverageEnabled", getU8Encoder()],
      ["borrowDisabled", getU8Encoder()],
      ["priceRefreshTriggerToMaxAgePct", getU8Encoder()],
      ["liquidationMaxDebtCloseFactorPct", getU8Encoder()],
      ["insolvencyRiskUnhealthyLtvPct", getU8Encoder()],
      ["minFullLiquidationValueThreshold", getU64Encoder()],
      ["maxLiquidatableDebtMarketValueAtOnce", getU64Encoder()],
      ["reserved0", getArrayEncoder(getU8Encoder(), { size: 8 })],
      ["globalAllowedBorrowValue", getU64Encoder()],
      ["riskCouncil", getAddressEncoder()],
      ["reserved1", getArrayEncoder(getU8Encoder(), { size: 8 })],
      [
        "elevationGroups",
        getArrayEncoder(getElevationGroupLendingMarketEncoder(), { size: 32 }),
      ],
      ["elevationGroupPadding", getArrayEncoder(getU64Encoder(), { size: 90 })],
      ["minNetValueInObligationSf", getU128Encoder()],
      ["minValueSkipLiquidationLtvChecks", getU64Encoder()],
      ["name", getArrayEncoder(getU8Encoder(), { size: 32 })],
      ["minValueSkipLiquidationBfChecks", getU64Encoder()],
      ["individualAutodeleverageMarginCallPeriodSecs", getU64Encoder()],
      ["minInitialDepositAmount", getU64Encoder()],
      ["padding1", getArrayEncoder(getU64Encoder(), { size: 170 })],
    ]),
    (value) => ({ ...value, discriminator: LENDING_MARKET_DISCRIMINATOR }),
  );
}

export function getLendingMarketDecoder(): FixedSizeDecoder<LendingMarket> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["version", getU64Decoder()],
    ["bumpSeed", getU64Decoder()],
    ["lendingMarketOwner", getAddressDecoder()],
    ["lendingMarketOwnerCached", getAddressDecoder()],
    ["quoteCurrency", getArrayDecoder(getU8Decoder(), { size: 32 })],
    ["referralFeeBps", getU16Decoder()],
    ["emergencyMode", getU8Decoder()],
    ["autodeleverageEnabled", getU8Decoder()],
    ["borrowDisabled", getU8Decoder()],
    ["priceRefreshTriggerToMaxAgePct", getU8Decoder()],
    ["liquidationMaxDebtCloseFactorPct", getU8Decoder()],
    ["insolvencyRiskUnhealthyLtvPct", getU8Decoder()],
    ["minFullLiquidationValueThreshold", getU64Decoder()],
    ["maxLiquidatableDebtMarketValueAtOnce", getU64Decoder()],
    ["reserved0", getArrayDecoder(getU8Decoder(), { size: 8 })],
    ["globalAllowedBorrowValue", getU64Decoder()],
    ["riskCouncil", getAddressDecoder()],
    ["reserved1", getArrayDecoder(getU8Decoder(), { size: 8 })],
    [
      "elevationGroups",
      getArrayDecoder(getElevationGroupLendingMarketDecoder(), { size: 32 }),
    ],
    ["elevationGroupPadding", getArrayDecoder(getU64Decoder(), { size: 90 })],
    ["minNetValueInObligationSf", getU128Decoder()],
    ["minValueSkipLiquidationLtvChecks", getU64Decoder()],
    ["name", getArrayDecoder(getU8Decoder(), { size: 32 })],
    ["minValueSkipLiquidationBfChecks", getU64Decoder()],
    ["individualAutodeleverageMarginCallPeriodSecs", getU64Decoder()],
    ["minInitialDepositAmount", getU64Decoder()],
    ["padding1", getArrayDecoder(getU64Decoder(), { size: 170 })],
  ]);
}

export function getLendingMarketCodec(): FixedSizeCodec<
  LendingMarketArgs,
  LendingMarket
> {
  return combineCodec(getLendingMarketEncoder(), getLendingMarketDecoder());
}

export function decodeLendingMarket<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<LendingMarket, TAddress>;
export function decodeLendingMarket<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<LendingMarket, TAddress>;
export function decodeLendingMarket<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<LendingMarket, TAddress> | MaybeAccount<LendingMarket, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getLendingMarketDecoder(),
  );
}

export async function fetchLendingMarket<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<LendingMarket, TAddress>> {
  const maybeAccount = await fetchMaybeLendingMarket(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeLendingMarket<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<LendingMarket, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeLendingMarket(maybeAccount);
}

export async function fetchAllLendingMarket(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<Account<LendingMarket>[]> {
  const maybeAccounts = await fetchAllMaybeLendingMarket(
    rpc,
    addresses,
    config,
  );
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeLendingMarket(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<LendingMarket>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeLendingMarket(maybeAccount));
}
