/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  Account,
  Address,
  EncodedAccount,
  FetchAccountConfig,
  FetchAccountsConfig,
  FixedSizeCodec,
  FixedSizeDecoder,
  FixedSizeEncoder,
  MaybeAccount,
  MaybeEncodedAccount,
  ReadonlyUint8Array,
} from "@solana/kit";
import type {
  ElevationGroupPod,
  ElevationGroupPodArgs,
} from "../types/index.js";
import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  getU16Decoder,
  getU16Encoder,
  getU64Decoder,
  getU64Encoder,
  getU128Decoder,
  getU128Encoder,
  transformEncoder,
} from "@solana/kit";
import {
  getElevationGroupPodDecoder,
  getElevationGroupPodEncoder,
} from "../types/index.js";

export const LENDING_MARKET_DISCRIMINATOR: ReadonlyUint8Array = new Uint8Array([
  246, 114, 50, 98, 72, 157, 28, 120,
]);

export function getLendingMarketDiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    LENDING_MARKET_DISCRIMINATOR,
  );
}

export interface LendingMarket {
  discriminator: ReadonlyUint8Array;
  /** Version of lending market */
  version: bigint;
  /** Bump seed for derived authority address */
  bumpSeed: bigint;
  /** Owner authority which can add new reserves */
  lendingMarketOwner: Address;
  /** Temporary cache of the lending market owner, used in update_lending_market_owner */
  lendingMarketOwnerCached: Address;
  /**
   * Currency market prices are quoted in
   * e.g. "USD" null padded (`*b"USD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"`) or a SPL token mint pubkey
   */
  quoteCurrency: number[];
  /** Referral fee for the lending market, as bps out of the total protocol fee */
  referralFeeBps: number;
  emergencyMode: number;
  /**
   * Whether the obligations on this market should be subject to auto-deleveraging after deposit
   * or borrow limit is crossed.
   * Besides this flag, the particular reserve's flag also needs to be enabled (logical `AND`).
   * **NOTE:** this also affects the individual "target LTV" deleveraging.
   */
  autodeleverageEnabled: number;
  borrowDisabled: number;
  /**
   * Refresh price from oracle only if it's older than this percentage of the price max age.
   * e.g. if the max age is set to 100s and this is set to 80%, the price will be refreshed if it's older than 80s.
   * Price is always refreshed if this set to 0.
   */
  priceRefreshTriggerToMaxAgePct: number;
  /** Percentage of the total borrowed value in an obligation available for liquidation */
  liquidationMaxDebtCloseFactorPct: number;
  /** Minimum acceptable unhealthy LTV before max_debt_close_factor_pct becomes 100% */
  insolvencyRiskUnhealthyLtvPct: number;
  /** Minimum liquidation value threshold triggering full liquidation for an obligation */
  minFullLiquidationValueThreshold: bigint;
  /** Max allowed liquidation value in one ix call */
  maxLiquidatableDebtMarketValueAtOnce: bigint;
  /** [DEPRECATED] Global maximum unhealthy borrow value allowed for any obligation */
  reserved0: number[];
  /** Global maximum allowed borrow value allowed for any obligation */
  globalAllowedBorrowValue: bigint;
  /** The address of the risk council, in charge of making parameter and risk decisions on behalf of the protocol */
  riskCouncil: Address;
  /** [DEPRECATED] Reward points multiplier per obligation type */
  reserved1: number[];
  /** Elevation groups are used to group together reserves that have the same risk parameters and can bump the ltv and liquidation threshold */
  elevationGroups: ElevationGroupPod[];
  elevationGroupPadding: bigint[];
  /** Min net value accepted to be found in a position after any lending action in an obligation (scaled by quote currency decimals) */
  minNetValueInObligationSf: bigint;
  /** Minimum value to enforce smallest ltv priority checks on the collateral reserves on liquidation */
  minValueSkipLiquidationLtvChecks: bigint;
  /** Market name, zero-padded. */
  name: number[];
  /** Minimum value to enforce highest borrow factor priority checks on the debt reserves on liquidation */
  minValueSkipLiquidationBfChecks: bigint;
  /**
   * Time (in seconds) that must pass before liquidation is allowed on an obligation that has
   * been individually marked for auto-deleveraging (by the risk council).
   */
  individualAutodeleverageMarginCallPeriodSecs: bigint;
  /**
   * Minimum amount of deposit at creation of a reserve to prevent artificial inflation
   * Note: this amount cannot be recovered, the ctoken associated are never minted
   */
  minInitialDepositAmount: bigint;
  /** Whether the obligation orders should be evaluated during liquidations. */
  obligationOrderExecutionEnabled: number;
  /** Whether the lending market is set as immutable. */
  immutable: number;
  /**
   * Whether new obligation orders can be created.
   * Note: updating or cancelling existing orders is *not* affected by this flag.
   */
  obligationOrderCreationEnabled: number;
  padding2: number[];
  padding1: bigint[];
}

export interface LendingMarketArgs {
  /** Version of lending market */
  version: number | bigint;
  /** Bump seed for derived authority address */
  bumpSeed: number | bigint;
  /** Owner authority which can add new reserves */
  lendingMarketOwner: Address;
  /** Temporary cache of the lending market owner, used in update_lending_market_owner */
  lendingMarketOwnerCached: Address;
  /**
   * Currency market prices are quoted in
   * e.g. "USD" null padded (`*b"USD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"`) or a SPL token mint pubkey
   */
  quoteCurrency: number[];
  /** Referral fee for the lending market, as bps out of the total protocol fee */
  referralFeeBps: number;
  emergencyMode: number;
  /**
   * Whether the obligations on this market should be subject to auto-deleveraging after deposit
   * or borrow limit is crossed.
   * Besides this flag, the particular reserve's flag also needs to be enabled (logical `AND`).
   * **NOTE:** this also affects the individual "target LTV" deleveraging.
   */
  autodeleverageEnabled: number;
  borrowDisabled: number;
  /**
   * Refresh price from oracle only if it's older than this percentage of the price max age.
   * e.g. if the max age is set to 100s and this is set to 80%, the price will be refreshed if it's older than 80s.
   * Price is always refreshed if this set to 0.
   */
  priceRefreshTriggerToMaxAgePct: number;
  /** Percentage of the total borrowed value in an obligation available for liquidation */
  liquidationMaxDebtCloseFactorPct: number;
  /** Minimum acceptable unhealthy LTV before max_debt_close_factor_pct becomes 100% */
  insolvencyRiskUnhealthyLtvPct: number;
  /** Minimum liquidation value threshold triggering full liquidation for an obligation */
  minFullLiquidationValueThreshold: number | bigint;
  /** Max allowed liquidation value in one ix call */
  maxLiquidatableDebtMarketValueAtOnce: number | bigint;
  /** [DEPRECATED] Global maximum unhealthy borrow value allowed for any obligation */
  reserved0: number[];
  /** Global maximum allowed borrow value allowed for any obligation */
  globalAllowedBorrowValue: number | bigint;
  /** The address of the risk council, in charge of making parameter and risk decisions on behalf of the protocol */
  riskCouncil: Address;
  /** [DEPRECATED] Reward points multiplier per obligation type */
  reserved1: number[];
  /** Elevation groups are used to group together reserves that have the same risk parameters and can bump the ltv and liquidation threshold */
  elevationGroups: ElevationGroupPodArgs[];
  elevationGroupPadding: (number | bigint)[];
  /** Min net value accepted to be found in a position after any lending action in an obligation (scaled by quote currency decimals) */
  minNetValueInObligationSf: number | bigint;
  /** Minimum value to enforce smallest ltv priority checks on the collateral reserves on liquidation */
  minValueSkipLiquidationLtvChecks: number | bigint;
  /** Market name, zero-padded. */
  name: number[];
  /** Minimum value to enforce highest borrow factor priority checks on the debt reserves on liquidation */
  minValueSkipLiquidationBfChecks: number | bigint;
  /**
   * Time (in seconds) that must pass before liquidation is allowed on an obligation that has
   * been individually marked for auto-deleveraging (by the risk council).
   */
  individualAutodeleverageMarginCallPeriodSecs: number | bigint;
  /**
   * Minimum amount of deposit at creation of a reserve to prevent artificial inflation
   * Note: this amount cannot be recovered, the ctoken associated are never minted
   */
  minInitialDepositAmount: number | bigint;
  /** Whether the obligation orders should be evaluated during liquidations. */
  obligationOrderExecutionEnabled: number;
  /** Whether the lending market is set as immutable. */
  immutable: number;
  /**
   * Whether new obligation orders can be created.
   * Note: updating or cancelling existing orders is *not* affected by this flag.
   */
  obligationOrderCreationEnabled: number;
  padding2: number[];
  padding1: (number | bigint)[];
}

export function getLendingMarketEncoder(): FixedSizeEncoder<LendingMarketArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["version", getU64Encoder()],
      ["bumpSeed", getU64Encoder()],
      ["lendingMarketOwner", getAddressEncoder()],
      ["lendingMarketOwnerCached", getAddressEncoder()],
      ["quoteCurrency", getArrayEncoder(getU8Encoder(), { size: 32 })],
      ["referralFeeBps", getU16Encoder()],
      ["emergencyMode", getU8Encoder()],
      ["autodeleverageEnabled", getU8Encoder()],
      ["borrowDisabled", getU8Encoder()],
      ["priceRefreshTriggerToMaxAgePct", getU8Encoder()],
      ["liquidationMaxDebtCloseFactorPct", getU8Encoder()],
      ["insolvencyRiskUnhealthyLtvPct", getU8Encoder()],
      ["minFullLiquidationValueThreshold", getU64Encoder()],
      ["maxLiquidatableDebtMarketValueAtOnce", getU64Encoder()],
      ["reserved0", getArrayEncoder(getU8Encoder(), { size: 8 })],
      ["globalAllowedBorrowValue", getU64Encoder()],
      ["riskCouncil", getAddressEncoder()],
      ["reserved1", getArrayEncoder(getU8Encoder(), { size: 8 })],
      [
        "elevationGroups",
        getArrayEncoder(getElevationGroupPodEncoder(), { size: 32 }),
      ],
      ["elevationGroupPadding", getArrayEncoder(getU64Encoder(), { size: 90 })],
      ["minNetValueInObligationSf", getU128Encoder()],
      ["minValueSkipLiquidationLtvChecks", getU64Encoder()],
      ["name", getArrayEncoder(getU8Encoder(), { size: 32 })],
      ["minValueSkipLiquidationBfChecks", getU64Encoder()],
      ["individualAutodeleverageMarginCallPeriodSecs", getU64Encoder()],
      ["minInitialDepositAmount", getU64Encoder()],
      ["obligationOrderExecutionEnabled", getU8Encoder()],
      ["immutable", getU8Encoder()],
      ["obligationOrderCreationEnabled", getU8Encoder()],
      ["padding2", getArrayEncoder(getU8Encoder(), { size: 5 })],
      ["padding1", getArrayEncoder(getU64Encoder(), { size: 169 })],
    ]),
    (value) => ({ ...value, discriminator: LENDING_MARKET_DISCRIMINATOR }),
  );
}

export function getLendingMarketDecoder(): FixedSizeDecoder<LendingMarket> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["version", getU64Decoder()],
    ["bumpSeed", getU64Decoder()],
    ["lendingMarketOwner", getAddressDecoder()],
    ["lendingMarketOwnerCached", getAddressDecoder()],
    ["quoteCurrency", getArrayDecoder(getU8Decoder(), { size: 32 })],
    ["referralFeeBps", getU16Decoder()],
    ["emergencyMode", getU8Decoder()],
    ["autodeleverageEnabled", getU8Decoder()],
    ["borrowDisabled", getU8Decoder()],
    ["priceRefreshTriggerToMaxAgePct", getU8Decoder()],
    ["liquidationMaxDebtCloseFactorPct", getU8Decoder()],
    ["insolvencyRiskUnhealthyLtvPct", getU8Decoder()],
    ["minFullLiquidationValueThreshold", getU64Decoder()],
    ["maxLiquidatableDebtMarketValueAtOnce", getU64Decoder()],
    ["reserved0", getArrayDecoder(getU8Decoder(), { size: 8 })],
    ["globalAllowedBorrowValue", getU64Decoder()],
    ["riskCouncil", getAddressDecoder()],
    ["reserved1", getArrayDecoder(getU8Decoder(), { size: 8 })],
    [
      "elevationGroups",
      getArrayDecoder(getElevationGroupPodDecoder(), { size: 32 }),
    ],
    ["elevationGroupPadding", getArrayDecoder(getU64Decoder(), { size: 90 })],
    ["minNetValueInObligationSf", getU128Decoder()],
    ["minValueSkipLiquidationLtvChecks", getU64Decoder()],
    ["name", getArrayDecoder(getU8Decoder(), { size: 32 })],
    ["minValueSkipLiquidationBfChecks", getU64Decoder()],
    ["individualAutodeleverageMarginCallPeriodSecs", getU64Decoder()],
    ["minInitialDepositAmount", getU64Decoder()],
    ["obligationOrderExecutionEnabled", getU8Decoder()],
    ["immutable", getU8Decoder()],
    ["obligationOrderCreationEnabled", getU8Decoder()],
    ["padding2", getArrayDecoder(getU8Decoder(), { size: 5 })],
    ["padding1", getArrayDecoder(getU64Decoder(), { size: 169 })],
  ]);
}

export function getLendingMarketCodec(): FixedSizeCodec<
  LendingMarketArgs,
  LendingMarket
> {
  return combineCodec(getLendingMarketEncoder(), getLendingMarketDecoder());
}

export function decodeLendingMarket<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<LendingMarket, TAddress>;
export function decodeLendingMarket<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<LendingMarket, TAddress>;
export function decodeLendingMarket<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<LendingMarket, TAddress> | MaybeAccount<LendingMarket, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getLendingMarketDecoder(),
  );
}

export async function fetchLendingMarket<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<LendingMarket, TAddress>> {
  const maybeAccount = await fetchMaybeLendingMarket(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeLendingMarket<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<LendingMarket, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeLendingMarket(maybeAccount);
}

export async function fetchAllLendingMarket(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<Account<LendingMarket>[]> {
  const maybeAccounts = await fetchAllMaybeLendingMarket(
    rpc,
    addresses,
    config,
  );
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeLendingMarket(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<LendingMarket>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeLendingMarket(maybeAccount));
}
