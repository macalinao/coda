/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  Account,
  Address,
  EncodedAccount,
  FetchAccountConfig,
  FetchAccountsConfig,
  FixedSizeCodec,
  FixedSizeDecoder,
  FixedSizeEncoder,
  MaybeAccount,
  MaybeEncodedAccount,
  ReadonlyUint8Array,
} from "@solana/kit";
import type { FarmsUserStateSeeds } from "../pdas/index.js";
import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  getU64Decoder,
  getU64Encoder,
  getU128Decoder,
  getU128Encoder,
  transformEncoder,
} from "@solana/kit";
import { findFarmsUserStatePda } from "../pdas/index.js";

export const FARMS_USER_STATE_DISCRIMINATOR: ReadonlyUint8Array =
  new Uint8Array([72, 177, 85, 249, 76, 167, 186, 126]);

export function getFarmsUserStateDiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    FARMS_USER_STATE_DISCRIMINATOR,
  );
}

export interface FarmsUserState {
  discriminator: ReadonlyUint8Array;
  userId: bigint;
  farmState: Address;
  owner: Address;
  /** Indicate if this user state is part of a delegated farm */
  isFarmDelegated: number;
  padding0: number[];
  /**
   * Rewards tally used for computation of gained rewards
   * (scaled from `Decimal` representation).
   */
  rewardsTallyScaled: bigint[];
  /** Number of reward tokens ready for claim */
  rewardsIssuedUnclaimed: bigint[];
  lastClaimTs: bigint[];
  /**
   * User stake deposited and usable, generating rewards and fees.
   * (scaled from `Decimal` representation).
   */
  activeStakeScaled: bigint;
  /**
   * User stake deposited but not usable and not generating rewards yet.
   * (scaled from `Decimal` representation).
   */
  pendingDepositStakeScaled: bigint;
  /**
   * After this timestamp, pending user stake can be moved to user stake
   * Initialized to now() + delayed user stake period
   */
  pendingDepositStakeTs: bigint;
  /**
   * User deposits unstaked, pending for withdrawal, not usable and not generating rewards.
   * (scaled from `Decimal` representation).
   */
  pendingWithdrawalUnstakeScaled: bigint;
  /** After this timestamp, user can withdraw their deposit. */
  pendingWithdrawalUnstakeTs: bigint;
  /** User bump used for account address validation */
  bump: bigint;
  /** Delegatee used for initialisation - useful to check against */
  delegatee: Address;
  lastStakeTs: bigint;
  padding1: bigint[];
}

export interface FarmsUserStateArgs {
  userId: number | bigint;
  farmState: Address;
  owner: Address;
  /** Indicate if this user state is part of a delegated farm */
  isFarmDelegated: number;
  padding0: number[];
  /**
   * Rewards tally used for computation of gained rewards
   * (scaled from `Decimal` representation).
   */
  rewardsTallyScaled: (number | bigint)[];
  /** Number of reward tokens ready for claim */
  rewardsIssuedUnclaimed: (number | bigint)[];
  lastClaimTs: (number | bigint)[];
  /**
   * User stake deposited and usable, generating rewards and fees.
   * (scaled from `Decimal` representation).
   */
  activeStakeScaled: number | bigint;
  /**
   * User stake deposited but not usable and not generating rewards yet.
   * (scaled from `Decimal` representation).
   */
  pendingDepositStakeScaled: number | bigint;
  /**
   * After this timestamp, pending user stake can be moved to user stake
   * Initialized to now() + delayed user stake period
   */
  pendingDepositStakeTs: number | bigint;
  /**
   * User deposits unstaked, pending for withdrawal, not usable and not generating rewards.
   * (scaled from `Decimal` representation).
   */
  pendingWithdrawalUnstakeScaled: number | bigint;
  /** After this timestamp, user can withdraw their deposit. */
  pendingWithdrawalUnstakeTs: number | bigint;
  /** User bump used for account address validation */
  bump: number | bigint;
  /** Delegatee used for initialisation - useful to check against */
  delegatee: Address;
  lastStakeTs: number | bigint;
  padding1: (number | bigint)[];
}

export function getFarmsUserStateEncoder(): FixedSizeEncoder<FarmsUserStateArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["userId", getU64Encoder()],
      ["farmState", getAddressEncoder()],
      ["owner", getAddressEncoder()],
      ["isFarmDelegated", getU8Encoder()],
      ["padding0", getArrayEncoder(getU8Encoder(), { size: 7 })],
      ["rewardsTallyScaled", getArrayEncoder(getU128Encoder(), { size: 10 })],
      [
        "rewardsIssuedUnclaimed",
        getArrayEncoder(getU64Encoder(), { size: 10 }),
      ],
      ["lastClaimTs", getArrayEncoder(getU64Encoder(), { size: 10 })],
      ["activeStakeScaled", getU128Encoder()],
      ["pendingDepositStakeScaled", getU128Encoder()],
      ["pendingDepositStakeTs", getU64Encoder()],
      ["pendingWithdrawalUnstakeScaled", getU128Encoder()],
      ["pendingWithdrawalUnstakeTs", getU64Encoder()],
      ["bump", getU64Encoder()],
      ["delegatee", getAddressEncoder()],
      ["lastStakeTs", getU64Encoder()],
      ["padding1", getArrayEncoder(getU64Encoder(), { size: 50 })],
    ]),
    (value) => ({ ...value, discriminator: FARMS_USER_STATE_DISCRIMINATOR }),
  );
}

export function getFarmsUserStateDecoder(): FixedSizeDecoder<FarmsUserState> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["userId", getU64Decoder()],
    ["farmState", getAddressDecoder()],
    ["owner", getAddressDecoder()],
    ["isFarmDelegated", getU8Decoder()],
    ["padding0", getArrayDecoder(getU8Decoder(), { size: 7 })],
    ["rewardsTallyScaled", getArrayDecoder(getU128Decoder(), { size: 10 })],
    ["rewardsIssuedUnclaimed", getArrayDecoder(getU64Decoder(), { size: 10 })],
    ["lastClaimTs", getArrayDecoder(getU64Decoder(), { size: 10 })],
    ["activeStakeScaled", getU128Decoder()],
    ["pendingDepositStakeScaled", getU128Decoder()],
    ["pendingDepositStakeTs", getU64Decoder()],
    ["pendingWithdrawalUnstakeScaled", getU128Decoder()],
    ["pendingWithdrawalUnstakeTs", getU64Decoder()],
    ["bump", getU64Decoder()],
    ["delegatee", getAddressDecoder()],
    ["lastStakeTs", getU64Decoder()],
    ["padding1", getArrayDecoder(getU64Decoder(), { size: 50 })],
  ]);
}

export function getFarmsUserStateCodec(): FixedSizeCodec<
  FarmsUserStateArgs,
  FarmsUserState
> {
  return combineCodec(getFarmsUserStateEncoder(), getFarmsUserStateDecoder());
}

export function decodeFarmsUserState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<FarmsUserState, TAddress>;
export function decodeFarmsUserState<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<FarmsUserState, TAddress>;
export function decodeFarmsUserState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<FarmsUserState, TAddress> | MaybeAccount<FarmsUserState, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getFarmsUserStateDecoder(),
  );
}

export async function fetchFarmsUserState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<FarmsUserState, TAddress>> {
  const maybeAccount = await fetchMaybeFarmsUserState(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeFarmsUserState<
  TAddress extends string = string,
>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<FarmsUserState, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeFarmsUserState(maybeAccount);
}

export async function fetchAllFarmsUserState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<Account<FarmsUserState>[]> {
  const maybeAccounts = await fetchAllMaybeFarmsUserState(
    rpc,
    addresses,
    config,
  );
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeFarmsUserState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<FarmsUserState>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) =>
    decodeFarmsUserState(maybeAccount),
  );
}

export async function fetchFarmsUserStateFromSeeds(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  seeds: FarmsUserStateSeeds,
  config: FetchAccountConfig & { programAddress?: Address } = {},
): Promise<Account<FarmsUserState>> {
  const maybeAccount = await fetchMaybeFarmsUserStateFromSeeds(
    rpc,
    seeds,
    config,
  );
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeFarmsUserStateFromSeeds(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  seeds: FarmsUserStateSeeds,
  config: FetchAccountConfig & { programAddress?: Address } = {},
): Promise<MaybeAccount<FarmsUserState>> {
  const { programAddress, ...fetchConfig } = config;
  const [address] = await findFarmsUserStatePda(seeds, { programAddress });
  return await fetchMaybeFarmsUserState(rpc, address, fetchConfig);
}
