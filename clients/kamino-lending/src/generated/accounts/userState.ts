/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  type Account,
  type Address,
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  type EncodedAccount,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  getU64Decoder,
  getU64Encoder,
  getU128Decoder,
  getU128Encoder,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
  transformEncoder,
} from "@solana/kit";

export const USER_STATE_DISCRIMINATOR = new Uint8Array([
  72, 177, 85, 249, 76, 167, 186, 126,
]);

export function getUserStateDiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(USER_STATE_DISCRIMINATOR);
}

export type UserState = {
  discriminator: ReadonlyUint8Array;
  userId: bigint;
  farmState: Address;
  owner: Address;
  isFarmDelegated: number;
  padding0: number[];
  rewardsTallyScaled: bigint[];
  rewardsIssuedUnclaimed: bigint[];
  lastClaimTs: bigint[];
  activeStakeScaled: bigint;
  pendingDepositStakeScaled: bigint;
  pendingDepositStakeTs: bigint;
  pendingWithdrawalUnstakeScaled: bigint;
  pendingWithdrawalUnstakeTs: bigint;
  bump: bigint;
  delegatee: Address;
  lastStakeTs: bigint;
  padding1: bigint[];
};

export type UserStateArgs = {
  userId: number | bigint;
  farmState: Address;
  owner: Address;
  isFarmDelegated: number;
  padding0: number[];
  rewardsTallyScaled: Array<number | bigint>;
  rewardsIssuedUnclaimed: Array<number | bigint>;
  lastClaimTs: Array<number | bigint>;
  activeStakeScaled: number | bigint;
  pendingDepositStakeScaled: number | bigint;
  pendingDepositStakeTs: number | bigint;
  pendingWithdrawalUnstakeScaled: number | bigint;
  pendingWithdrawalUnstakeTs: number | bigint;
  bump: number | bigint;
  delegatee: Address;
  lastStakeTs: number | bigint;
  padding1: Array<number | bigint>;
};

export function getUserStateEncoder(): FixedSizeEncoder<UserStateArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["userId", getU64Encoder()],
      ["farmState", getAddressEncoder()],
      ["owner", getAddressEncoder()],
      ["isFarmDelegated", getU8Encoder()],
      ["padding0", getArrayEncoder(getU8Encoder(), { size: 7 })],
      ["rewardsTallyScaled", getArrayEncoder(getU128Encoder(), { size: 10 })],
      [
        "rewardsIssuedUnclaimed",
        getArrayEncoder(getU64Encoder(), { size: 10 }),
      ],
      ["lastClaimTs", getArrayEncoder(getU64Encoder(), { size: 10 })],
      ["activeStakeScaled", getU128Encoder()],
      ["pendingDepositStakeScaled", getU128Encoder()],
      ["pendingDepositStakeTs", getU64Encoder()],
      ["pendingWithdrawalUnstakeScaled", getU128Encoder()],
      ["pendingWithdrawalUnstakeTs", getU64Encoder()],
      ["bump", getU64Encoder()],
      ["delegatee", getAddressEncoder()],
      ["lastStakeTs", getU64Encoder()],
      ["padding1", getArrayEncoder(getU64Encoder(), { size: 50 })],
    ]),
    (value) => ({ ...value, discriminator: USER_STATE_DISCRIMINATOR }),
  );
}

export function getUserStateDecoder(): FixedSizeDecoder<UserState> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["userId", getU64Decoder()],
    ["farmState", getAddressDecoder()],
    ["owner", getAddressDecoder()],
    ["isFarmDelegated", getU8Decoder()],
    ["padding0", getArrayDecoder(getU8Decoder(), { size: 7 })],
    ["rewardsTallyScaled", getArrayDecoder(getU128Decoder(), { size: 10 })],
    ["rewardsIssuedUnclaimed", getArrayDecoder(getU64Decoder(), { size: 10 })],
    ["lastClaimTs", getArrayDecoder(getU64Decoder(), { size: 10 })],
    ["activeStakeScaled", getU128Decoder()],
    ["pendingDepositStakeScaled", getU128Decoder()],
    ["pendingDepositStakeTs", getU64Decoder()],
    ["pendingWithdrawalUnstakeScaled", getU128Decoder()],
    ["pendingWithdrawalUnstakeTs", getU64Decoder()],
    ["bump", getU64Decoder()],
    ["delegatee", getAddressDecoder()],
    ["lastStakeTs", getU64Decoder()],
    ["padding1", getArrayDecoder(getU64Decoder(), { size: 50 })],
  ]);
}

export function getUserStateCodec(): FixedSizeCodec<UserStateArgs, UserState> {
  return combineCodec(getUserStateEncoder(), getUserStateDecoder());
}

export function decodeUserState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<UserState, TAddress>;
export function decodeUserState<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<UserState, TAddress>;
export function decodeUserState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<UserState, TAddress> | MaybeAccount<UserState, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getUserStateDecoder(),
  );
}

export async function fetchUserState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<UserState, TAddress>> {
  const maybeAccount = await fetchMaybeUserState(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeUserState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<UserState, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeUserState(maybeAccount);
}

export async function fetchAllUserState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<Account<UserState>[]> {
  const maybeAccounts = await fetchAllMaybeUserState(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeUserState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<UserState>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeUserState(maybeAccount));
}
