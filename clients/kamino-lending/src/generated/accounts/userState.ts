/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  Account,
  Address,
  EncodedAccount,
  FetchAccountConfig,
  FetchAccountsConfig,
  FixedSizeCodec,
  FixedSizeDecoder,
  FixedSizeEncoder,
  MaybeAccount,
  MaybeEncodedAccount,
  ReadonlyUint8Array,
} from "@solana/kit";
import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  getU64Decoder,
  getU64Encoder,
  getU128Decoder,
  getU128Encoder,
  transformEncoder,
} from "@solana/kit";

export const USER_STATE_DISCRIMINATOR: ReadonlyUint8Array = new Uint8Array([
  72, 177, 85, 249, 76, 167, 186, 126,
]);

export function getUserStateDiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(USER_STATE_DISCRIMINATOR);
}

export interface UserState {
  discriminator: ReadonlyUint8Array;
  userId: bigint;
  farmState: Address;
  owner: Address;
  /** Indicate if this user state is part of a delegated farm */
  isFarmDelegated: number;
  padding0: number[];
  /**
   * Rewards tally used for computation of gained rewards
   * (scaled from `Decimal` representation).
   */
  rewardsTallyScaled: bigint[];
  /** Number of reward tokens ready for claim */
  rewardsIssuedUnclaimed: bigint[];
  lastClaimTs: bigint[];
  /**
   * User stake deposited and usable, generating rewards and fees.
   * (scaled from `Decimal` representation).
   */
  activeStakeScaled: bigint;
  /**
   * User stake deposited but not usable and not generating rewards yet.
   * (scaled from `Decimal` representation).
   */
  pendingDepositStakeScaled: bigint;
  /**
   * After this timestamp, pending user stake can be moved to user stake
   * Initialized to now() + delayed user stake period
   */
  pendingDepositStakeTs: bigint;
  /**
   * User deposits unstaked, pending for withdrawal, not usable and not generating rewards.
   * (scaled from `Decimal` representation).
   */
  pendingWithdrawalUnstakeScaled: bigint;
  /** After this timestamp, user can withdraw their deposit. */
  pendingWithdrawalUnstakeTs: bigint;
  /** User bump used for account address validation */
  bump: bigint;
  /** Delegatee used for initialisation - useful to check against */
  delegatee: Address;
  lastStakeTs: bigint;
  padding1: bigint[];
}

export interface UserStateArgs {
  userId: number | bigint;
  farmState: Address;
  owner: Address;
  /** Indicate if this user state is part of a delegated farm */
  isFarmDelegated: number;
  padding0: number[];
  /**
   * Rewards tally used for computation of gained rewards
   * (scaled from `Decimal` representation).
   */
  rewardsTallyScaled: (number | bigint)[];
  /** Number of reward tokens ready for claim */
  rewardsIssuedUnclaimed: (number | bigint)[];
  lastClaimTs: (number | bigint)[];
  /**
   * User stake deposited and usable, generating rewards and fees.
   * (scaled from `Decimal` representation).
   */
  activeStakeScaled: number | bigint;
  /**
   * User stake deposited but not usable and not generating rewards yet.
   * (scaled from `Decimal` representation).
   */
  pendingDepositStakeScaled: number | bigint;
  /**
   * After this timestamp, pending user stake can be moved to user stake
   * Initialized to now() + delayed user stake period
   */
  pendingDepositStakeTs: number | bigint;
  /**
   * User deposits unstaked, pending for withdrawal, not usable and not generating rewards.
   * (scaled from `Decimal` representation).
   */
  pendingWithdrawalUnstakeScaled: number | bigint;
  /** After this timestamp, user can withdraw their deposit. */
  pendingWithdrawalUnstakeTs: number | bigint;
  /** User bump used for account address validation */
  bump: number | bigint;
  /** Delegatee used for initialisation - useful to check against */
  delegatee: Address;
  lastStakeTs: number | bigint;
  padding1: (number | bigint)[];
}

export function getUserStateEncoder(): FixedSizeEncoder<UserStateArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["userId", getU64Encoder()],
      ["farmState", getAddressEncoder()],
      ["owner", getAddressEncoder()],
      ["isFarmDelegated", getU8Encoder()],
      ["padding0", getArrayEncoder(getU8Encoder(), { size: 7 })],
      ["rewardsTallyScaled", getArrayEncoder(getU128Encoder(), { size: 10 })],
      [
        "rewardsIssuedUnclaimed",
        getArrayEncoder(getU64Encoder(), { size: 10 }),
      ],
      ["lastClaimTs", getArrayEncoder(getU64Encoder(), { size: 10 })],
      ["activeStakeScaled", getU128Encoder()],
      ["pendingDepositStakeScaled", getU128Encoder()],
      ["pendingDepositStakeTs", getU64Encoder()],
      ["pendingWithdrawalUnstakeScaled", getU128Encoder()],
      ["pendingWithdrawalUnstakeTs", getU64Encoder()],
      ["bump", getU64Encoder()],
      ["delegatee", getAddressEncoder()],
      ["lastStakeTs", getU64Encoder()],
      ["padding1", getArrayEncoder(getU64Encoder(), { size: 50 })],
    ]),
    (value) => ({ ...value, discriminator: USER_STATE_DISCRIMINATOR }),
  );
}

export function getUserStateDecoder(): FixedSizeDecoder<UserState> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["userId", getU64Decoder()],
    ["farmState", getAddressDecoder()],
    ["owner", getAddressDecoder()],
    ["isFarmDelegated", getU8Decoder()],
    ["padding0", getArrayDecoder(getU8Decoder(), { size: 7 })],
    ["rewardsTallyScaled", getArrayDecoder(getU128Decoder(), { size: 10 })],
    ["rewardsIssuedUnclaimed", getArrayDecoder(getU64Decoder(), { size: 10 })],
    ["lastClaimTs", getArrayDecoder(getU64Decoder(), { size: 10 })],
    ["activeStakeScaled", getU128Decoder()],
    ["pendingDepositStakeScaled", getU128Decoder()],
    ["pendingDepositStakeTs", getU64Decoder()],
    ["pendingWithdrawalUnstakeScaled", getU128Decoder()],
    ["pendingWithdrawalUnstakeTs", getU64Decoder()],
    ["bump", getU64Decoder()],
    ["delegatee", getAddressDecoder()],
    ["lastStakeTs", getU64Decoder()],
    ["padding1", getArrayDecoder(getU64Decoder(), { size: 50 })],
  ]);
}

export function getUserStateCodec(): FixedSizeCodec<UserStateArgs, UserState> {
  return combineCodec(getUserStateEncoder(), getUserStateDecoder());
}

export function decodeUserState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<UserState, TAddress>;
export function decodeUserState<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<UserState, TAddress>;
export function decodeUserState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<UserState, TAddress> | MaybeAccount<UserState, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getUserStateDecoder(),
  );
}

export async function fetchUserState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<UserState, TAddress>> {
  const maybeAccount = await fetchMaybeUserState(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeUserState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<UserState, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeUserState(maybeAccount);
}

export async function fetchAllUserState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<Account<UserState>[]> {
  const maybeAccounts = await fetchAllMaybeUserState(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeUserState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<UserState>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeUserState(maybeAccount));
}
