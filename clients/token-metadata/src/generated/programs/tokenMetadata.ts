/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type { Address, ReadonlyUint8Array } from "@solana/kit";
import type {
  ParsedApproveCollectionAuthorityInstruction,
  ParsedApproveUseAuthorityInstruction,
  ParsedBubblegumSetCollectionSizeInstruction,
  ParsedBurnEditionNftInstruction,
  ParsedBurnInstruction,
  ParsedBurnNftInstruction,
  ParsedCloseAccountsInstruction,
  ParsedCloseEscrowAccountInstruction,
  ParsedCollectInstruction,
  ParsedConvertMasterEditionV1ToV2Instruction,
  ParsedCreateEscrowAccountInstruction,
  ParsedCreateInstruction,
  ParsedCreateMasterEditionInstruction,
  ParsedCreateMasterEditionV3Instruction,
  ParsedCreateMetadataAccountInstruction,
  ParsedCreateMetadataAccountV2Instruction,
  ParsedCreateMetadataAccountV3Instruction,
  ParsedDelegateInstruction,
  ParsedDeprecatedCreateMasterEditionInstruction,
  ParsedDeprecatedCreateReservationListInstruction,
  ParsedDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstruction,
  ParsedDeprecatedMintPrintingTokensInstruction,
  ParsedDeprecatedMintPrintingTokensViaTokenInstruction,
  ParsedDeprecatedSetReservationListInstruction,
  ParsedFreezeDelegatedAccountInstruction,
  ParsedLockInstruction,
  ParsedMigrateInstruction,
  ParsedMintInstruction,
  ParsedMintNewEditionFromMasterEditionViaTokenInstruction,
  ParsedMintNewEditionFromMasterEditionViaVaultProxyInstruction,
  ParsedPrintInstruction,
  ParsedPuffMetadataInstruction,
  ParsedRemoveCreatorVerificationInstruction,
  ParsedResizeInstruction,
  ParsedRevokeCollectionAuthorityInstruction,
  ParsedRevokeInstruction,
  ParsedRevokeUseAuthorityInstruction,
  ParsedSetAndVerifyCollectionInstruction,
  ParsedSetAndVerifySizedCollectionItemInstruction,
  ParsedSetCollectionSizeInstruction,
  ParsedSetTokenStandardInstruction,
  ParsedSignMetadataInstruction,
  ParsedThawDelegatedAccountInstruction,
  ParsedTransferInstruction,
  ParsedTransferOutOfEscrowInstruction,
  ParsedUnlockInstruction,
  ParsedUnverifyCollectionInstruction,
  ParsedUnverifyInstruction,
  ParsedUnverifySizedCollectionItemInstruction,
  ParsedUpdateInstruction,
  ParsedUpdateMetadataAccountInstruction,
  ParsedUpdateMetadataAccountV2Instruction,
  ParsedUpdatePrimarySaleHappenedViaTokenInstruction,
  ParsedUseInstruction,
  ParsedUtilizeInstruction,
  ParsedVerifyCollectionInstruction,
  ParsedVerifyInstruction,
  ParsedVerifySizedCollectionItemInstruction,
} from "../instructions/index.js";
import { containsBytes, getU8Encoder } from "@solana/kit";

export const TOKEN_METADATA_PROGRAM_ADDRESS =
  "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s" as Address<"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s">;

export enum TokenMetadataAccount {
  CollectionAuthorityRecord = 0,
  MetadataDelegateRecord = 1,
  HolderDelegateRecord = 2,
  Edition = 3,
  EditionMarker = 4,
  EditionMarkerV2 = 5,
  TokenOwnedEscrow = 6,
  MasterEditionV2 = 7,
  MasterEditionV1 = 8,
  Metadata = 9,
  TokenRecord = 10,
  ReservationListV2 = 11,
  ReservationListV1 = 12,
  UseAuthorityRecord = 13,
}

export enum TokenMetadataInstruction {
  CreateMetadataAccount = 0,
  UpdateMetadataAccount = 1,
  DeprecatedCreateMasterEdition = 2,
  DeprecatedMintNewEditionFromMasterEditionViaPrintingToken = 3,
  UpdatePrimarySaleHappenedViaToken = 4,
  DeprecatedSetReservationList = 5,
  DeprecatedCreateReservationList = 6,
  SignMetadata = 7,
  DeprecatedMintPrintingTokensViaToken = 8,
  DeprecatedMintPrintingTokens = 9,
  CreateMasterEdition = 10,
  MintNewEditionFromMasterEditionViaToken = 11,
  ConvertMasterEditionV1ToV2 = 12,
  MintNewEditionFromMasterEditionViaVaultProxy = 13,
  PuffMetadata = 14,
  UpdateMetadataAccountV2 = 15,
  CreateMetadataAccountV2 = 16,
  CreateMasterEditionV3 = 17,
  VerifyCollection = 18,
  Utilize = 19,
  ApproveUseAuthority = 20,
  RevokeUseAuthority = 21,
  UnverifyCollection = 22,
  ApproveCollectionAuthority = 23,
  RevokeCollectionAuthority = 24,
  SetAndVerifyCollection = 25,
  FreezeDelegatedAccount = 26,
  ThawDelegatedAccount = 27,
  RemoveCreatorVerification = 28,
  BurnNft = 29,
  VerifySizedCollectionItem = 30,
  UnverifySizedCollectionItem = 31,
  SetAndVerifySizedCollectionItem = 32,
  CreateMetadataAccountV3 = 33,
  SetCollectionSize = 34,
  SetTokenStandard = 35,
  BubblegumSetCollectionSize = 36,
  BurnEditionNft = 37,
  CreateEscrowAccount = 38,
  CloseEscrowAccount = 39,
  TransferOutOfEscrow = 40,
  Burn = 41,
  Create = 42,
  Mint = 43,
  Delegate = 44,
  Revoke = 45,
  Lock = 46,
  Unlock = 47,
  Migrate = 48,
  Transfer = 49,
  Update = 50,
  Use = 51,
  Verify = 52,
  Unverify = 53,
  Collect = 54,
  Print = 55,
  Resize = 56,
  CloseAccounts = 57,
}

export function identifyTokenMetadataInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): TokenMetadataInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (containsBytes(data, getU8Encoder().encode(0), 0)) {
    return TokenMetadataInstruction.CreateMetadataAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(1), 0)) {
    return TokenMetadataInstruction.UpdateMetadataAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(2), 0)) {
    return TokenMetadataInstruction.DeprecatedCreateMasterEdition;
  }
  if (containsBytes(data, getU8Encoder().encode(3), 0)) {
    return TokenMetadataInstruction.DeprecatedMintNewEditionFromMasterEditionViaPrintingToken;
  }
  if (containsBytes(data, getU8Encoder().encode(4), 0)) {
    return TokenMetadataInstruction.UpdatePrimarySaleHappenedViaToken;
  }
  if (containsBytes(data, getU8Encoder().encode(5), 0)) {
    return TokenMetadataInstruction.DeprecatedSetReservationList;
  }
  if (containsBytes(data, getU8Encoder().encode(6), 0)) {
    return TokenMetadataInstruction.DeprecatedCreateReservationList;
  }
  if (containsBytes(data, getU8Encoder().encode(7), 0)) {
    return TokenMetadataInstruction.SignMetadata;
  }
  if (containsBytes(data, getU8Encoder().encode(8), 0)) {
    return TokenMetadataInstruction.DeprecatedMintPrintingTokensViaToken;
  }
  if (containsBytes(data, getU8Encoder().encode(9), 0)) {
    return TokenMetadataInstruction.DeprecatedMintPrintingTokens;
  }
  if (containsBytes(data, getU8Encoder().encode(10), 0)) {
    return TokenMetadataInstruction.CreateMasterEdition;
  }
  if (containsBytes(data, getU8Encoder().encode(11), 0)) {
    return TokenMetadataInstruction.MintNewEditionFromMasterEditionViaToken;
  }
  if (containsBytes(data, getU8Encoder().encode(12), 0)) {
    return TokenMetadataInstruction.ConvertMasterEditionV1ToV2;
  }
  if (containsBytes(data, getU8Encoder().encode(13), 0)) {
    return TokenMetadataInstruction.MintNewEditionFromMasterEditionViaVaultProxy;
  }
  if (containsBytes(data, getU8Encoder().encode(14), 0)) {
    return TokenMetadataInstruction.PuffMetadata;
  }
  if (containsBytes(data, getU8Encoder().encode(15), 0)) {
    return TokenMetadataInstruction.UpdateMetadataAccountV2;
  }
  if (containsBytes(data, getU8Encoder().encode(16), 0)) {
    return TokenMetadataInstruction.CreateMetadataAccountV2;
  }
  if (containsBytes(data, getU8Encoder().encode(17), 0)) {
    return TokenMetadataInstruction.CreateMasterEditionV3;
  }
  if (containsBytes(data, getU8Encoder().encode(18), 0)) {
    return TokenMetadataInstruction.VerifyCollection;
  }
  if (containsBytes(data, getU8Encoder().encode(19), 0)) {
    return TokenMetadataInstruction.Utilize;
  }
  if (containsBytes(data, getU8Encoder().encode(20), 0)) {
    return TokenMetadataInstruction.ApproveUseAuthority;
  }
  if (containsBytes(data, getU8Encoder().encode(21), 0)) {
    return TokenMetadataInstruction.RevokeUseAuthority;
  }
  if (containsBytes(data, getU8Encoder().encode(22), 0)) {
    return TokenMetadataInstruction.UnverifyCollection;
  }
  if (containsBytes(data, getU8Encoder().encode(23), 0)) {
    return TokenMetadataInstruction.ApproveCollectionAuthority;
  }
  if (containsBytes(data, getU8Encoder().encode(24), 0)) {
    return TokenMetadataInstruction.RevokeCollectionAuthority;
  }
  if (containsBytes(data, getU8Encoder().encode(25), 0)) {
    return TokenMetadataInstruction.SetAndVerifyCollection;
  }
  if (containsBytes(data, getU8Encoder().encode(26), 0)) {
    return TokenMetadataInstruction.FreezeDelegatedAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(27), 0)) {
    return TokenMetadataInstruction.ThawDelegatedAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(28), 0)) {
    return TokenMetadataInstruction.RemoveCreatorVerification;
  }
  if (containsBytes(data, getU8Encoder().encode(29), 0)) {
    return TokenMetadataInstruction.BurnNft;
  }
  if (containsBytes(data, getU8Encoder().encode(30), 0)) {
    return TokenMetadataInstruction.VerifySizedCollectionItem;
  }
  if (containsBytes(data, getU8Encoder().encode(31), 0)) {
    return TokenMetadataInstruction.UnverifySizedCollectionItem;
  }
  if (containsBytes(data, getU8Encoder().encode(32), 0)) {
    return TokenMetadataInstruction.SetAndVerifySizedCollectionItem;
  }
  if (containsBytes(data, getU8Encoder().encode(33), 0)) {
    return TokenMetadataInstruction.CreateMetadataAccountV3;
  }
  if (containsBytes(data, getU8Encoder().encode(34), 0)) {
    return TokenMetadataInstruction.SetCollectionSize;
  }
  if (containsBytes(data, getU8Encoder().encode(35), 0)) {
    return TokenMetadataInstruction.SetTokenStandard;
  }
  if (containsBytes(data, getU8Encoder().encode(36), 0)) {
    return TokenMetadataInstruction.BubblegumSetCollectionSize;
  }
  if (containsBytes(data, getU8Encoder().encode(37), 0)) {
    return TokenMetadataInstruction.BurnEditionNft;
  }
  if (containsBytes(data, getU8Encoder().encode(38), 0)) {
    return TokenMetadataInstruction.CreateEscrowAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(39), 0)) {
    return TokenMetadataInstruction.CloseEscrowAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(40), 0)) {
    return TokenMetadataInstruction.TransferOutOfEscrow;
  }
  if (containsBytes(data, getU8Encoder().encode(41), 0)) {
    return TokenMetadataInstruction.Burn;
  }
  if (containsBytes(data, getU8Encoder().encode(42), 0)) {
    return TokenMetadataInstruction.Create;
  }
  if (containsBytes(data, getU8Encoder().encode(43), 0)) {
    return TokenMetadataInstruction.Mint;
  }
  if (containsBytes(data, getU8Encoder().encode(44), 0)) {
    return TokenMetadataInstruction.Delegate;
  }
  if (containsBytes(data, getU8Encoder().encode(45), 0)) {
    return TokenMetadataInstruction.Revoke;
  }
  if (containsBytes(data, getU8Encoder().encode(46), 0)) {
    return TokenMetadataInstruction.Lock;
  }
  if (containsBytes(data, getU8Encoder().encode(47), 0)) {
    return TokenMetadataInstruction.Unlock;
  }
  if (containsBytes(data, getU8Encoder().encode(48), 0)) {
    return TokenMetadataInstruction.Migrate;
  }
  if (containsBytes(data, getU8Encoder().encode(49), 0)) {
    return TokenMetadataInstruction.Transfer;
  }
  if (containsBytes(data, getU8Encoder().encode(50), 0)) {
    return TokenMetadataInstruction.Update;
  }
  if (containsBytes(data, getU8Encoder().encode(51), 0)) {
    return TokenMetadataInstruction.Use;
  }
  if (containsBytes(data, getU8Encoder().encode(52), 0)) {
    return TokenMetadataInstruction.Verify;
  }
  if (containsBytes(data, getU8Encoder().encode(53), 0)) {
    return TokenMetadataInstruction.Unverify;
  }
  if (containsBytes(data, getU8Encoder().encode(54), 0)) {
    return TokenMetadataInstruction.Collect;
  }
  if (containsBytes(data, getU8Encoder().encode(55), 0)) {
    return TokenMetadataInstruction.Print;
  }
  if (containsBytes(data, getU8Encoder().encode(56), 0)) {
    return TokenMetadataInstruction.Resize;
  }
  if (containsBytes(data, getU8Encoder().encode(57), 0)) {
    return TokenMetadataInstruction.CloseAccounts;
  }
  throw new Error(
    "The provided instruction could not be identified as a tokenMetadata instruction.",
  );
}

export type ParsedTokenMetadataInstruction<
  TProgram extends string = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s",
> =
  | ({
      instructionType: TokenMetadataInstruction.CreateMetadataAccount;
    } & ParsedCreateMetadataAccountInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.UpdateMetadataAccount;
    } & ParsedUpdateMetadataAccountInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.DeprecatedCreateMasterEdition;
    } & ParsedDeprecatedCreateMasterEditionInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.DeprecatedMintNewEditionFromMasterEditionViaPrintingToken;
    } & ParsedDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.UpdatePrimarySaleHappenedViaToken;
    } & ParsedUpdatePrimarySaleHappenedViaTokenInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.DeprecatedSetReservationList;
    } & ParsedDeprecatedSetReservationListInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.DeprecatedCreateReservationList;
    } & ParsedDeprecatedCreateReservationListInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.SignMetadata;
    } & ParsedSignMetadataInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.DeprecatedMintPrintingTokensViaToken;
    } & ParsedDeprecatedMintPrintingTokensViaTokenInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.DeprecatedMintPrintingTokens;
    } & ParsedDeprecatedMintPrintingTokensInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.CreateMasterEdition;
    } & ParsedCreateMasterEditionInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.MintNewEditionFromMasterEditionViaToken;
    } & ParsedMintNewEditionFromMasterEditionViaTokenInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.ConvertMasterEditionV1ToV2;
    } & ParsedConvertMasterEditionV1ToV2Instruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.MintNewEditionFromMasterEditionViaVaultProxy;
    } & ParsedMintNewEditionFromMasterEditionViaVaultProxyInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.PuffMetadata;
    } & ParsedPuffMetadataInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.UpdateMetadataAccountV2;
    } & ParsedUpdateMetadataAccountV2Instruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.CreateMetadataAccountV2;
    } & ParsedCreateMetadataAccountV2Instruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.CreateMasterEditionV3;
    } & ParsedCreateMasterEditionV3Instruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.VerifyCollection;
    } & ParsedVerifyCollectionInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Utilize;
    } & ParsedUtilizeInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.ApproveUseAuthority;
    } & ParsedApproveUseAuthorityInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.RevokeUseAuthority;
    } & ParsedRevokeUseAuthorityInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.UnverifyCollection;
    } & ParsedUnverifyCollectionInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.ApproveCollectionAuthority;
    } & ParsedApproveCollectionAuthorityInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.RevokeCollectionAuthority;
    } & ParsedRevokeCollectionAuthorityInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.SetAndVerifyCollection;
    } & ParsedSetAndVerifyCollectionInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.FreezeDelegatedAccount;
    } & ParsedFreezeDelegatedAccountInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.ThawDelegatedAccount;
    } & ParsedThawDelegatedAccountInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.RemoveCreatorVerification;
    } & ParsedRemoveCreatorVerificationInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.BurnNft;
    } & ParsedBurnNftInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.VerifySizedCollectionItem;
    } & ParsedVerifySizedCollectionItemInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.UnverifySizedCollectionItem;
    } & ParsedUnverifySizedCollectionItemInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.SetAndVerifySizedCollectionItem;
    } & ParsedSetAndVerifySizedCollectionItemInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.CreateMetadataAccountV3;
    } & ParsedCreateMetadataAccountV3Instruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.SetCollectionSize;
    } & ParsedSetCollectionSizeInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.SetTokenStandard;
    } & ParsedSetTokenStandardInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.BubblegumSetCollectionSize;
    } & ParsedBubblegumSetCollectionSizeInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.BurnEditionNft;
    } & ParsedBurnEditionNftInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.CreateEscrowAccount;
    } & ParsedCreateEscrowAccountInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.CloseEscrowAccount;
    } & ParsedCloseEscrowAccountInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.TransferOutOfEscrow;
    } & ParsedTransferOutOfEscrowInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Burn;
    } & ParsedBurnInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Create;
    } & ParsedCreateInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Mint;
    } & ParsedMintInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Delegate;
    } & ParsedDelegateInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Revoke;
    } & ParsedRevokeInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Lock;
    } & ParsedLockInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Unlock;
    } & ParsedUnlockInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Migrate;
    } & ParsedMigrateInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Transfer;
    } & ParsedTransferInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Update;
    } & ParsedUpdateInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Use;
    } & ParsedUseInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Verify;
    } & ParsedVerifyInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Unverify;
    } & ParsedUnverifyInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Collect;
    } & ParsedCollectInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Print;
    } & ParsedPrintInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.Resize;
    } & ParsedResizeInstruction<TProgram>)
  | ({
      instructionType: TokenMetadataInstruction.CloseAccounts;
    } & ParsedCloseAccountsInstruction<TProgram>);
