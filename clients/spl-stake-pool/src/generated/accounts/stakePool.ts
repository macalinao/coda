/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  Account,
  Address,
  Codec,
  Decoder,
  EncodedAccount,
  Encoder,
  FetchAccountConfig,
  FetchAccountsConfig,
  MaybeAccount,
  MaybeEncodedAccount,
  Option,
  OptionOrNullable,
} from "@solana/kit";
import type {
  Fee,
  FeeArgs,
  FutureEpoch,
  FutureEpochArgs,
  Lockup,
  LockupArgs,
} from "../types/index.js";
import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  getAddressDecoder,
  getAddressEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
} from "@solana/kit";
import {
  AccountType,
  getAccountTypeDecoder,
  getAccountTypeEncoder,
  getFeeDecoder,
  getFeeEncoder,
  getFutureEpochDecoder,
  getFutureEpochEncoder,
  getLockupDecoder,
  getLockupEncoder,
} from "../types/index.js";

export const STAKE_POOL_ACCOUNT_TYPE = AccountType.StakePool;

export function getStakePoolAccountTypeBytes() {
  return getAccountTypeEncoder().encode(STAKE_POOL_ACCOUNT_TYPE);
}

export interface StakePool {
  /** Account type, must be `StakePool` currently */
  accountType: AccountType;
  /**
   * Manager authority, allows for updating the staker, manager, and fee
   * account
   */
  manager: Address;
  /**
   * Staker authority, allows for adding and removing validators, and
   * managing stake distribution
   */
  staker: Address;
  /**
   * Stake deposit authority
   * If a depositor pubkey is specified on initialization, then deposits must
   * be signed by this authority. If no deposit authority is specified,
   * then the stake pool will default to the result of:
   * `Pubkey::find_program_address(
   * &[&stake_pool_address.as_ref(), b"deposit"],
   * program_id,
   * )`
   */
  stakeDepositAuthority: Address;
  /**
   * Stake withdrawal authority bump seed
   * for `create_program_address(&[state::StakePool account, "withdrawal"])`
   */
  stakeWithdrawBumpSeed: number;
  /** Validator stake list storage account */
  validatorList: Address;
  /** Reserve stake account, holds deactivated stake */
  reserveStake: Address;
  /** Pool Mint */
  poolMint: Address;
  /** Manager fee account */
  managerFeeAccount: Address;
  /** Pool token program id */
  tokenProgramId: Address;
  /**
   * Total stake under management.
   * Note that if `last_update_epoch` does not match the current epoch then
   * this field may not be accurate
   */
  totalLamports: bigint;
  /**
   * Total supply of pool tokens (should always match the supply in the Pool
   * Mint)
   */
  poolTokenSupply: bigint;
  /** Last epoch the `total_lamports` field was updated */
  lastUpdateEpoch: bigint;
  /** Lockup that all stakes in the pool must have */
  lockup: Lockup;
  /** Fee taken as a proportion of rewards each epoch */
  epochFee: Fee;
  /** Fee for next epoch */
  nextEpochFee: FutureEpoch;
  /** Preferred deposit validator vote account pubkey */
  preferredDepositValidatorVoteAddress: Option<Address>;
  /** Preferred withdraw validator vote account pubkey */
  preferredWithdrawValidatorVoteAddress: Option<Address>;
  /** Fee assessed on stake deposits */
  stakeDepositFee: Fee;
  /** Fee assessed on withdrawals */
  stakeWithdrawalFee: Fee;
  /** Future stake withdrawal fee, to be set for the following epoch */
  nextStakeWithdrawalFee: FutureEpoch;
  /**
   * Fees paid out to referrers on referred stake deposits.
   * Expressed as a percentage (0 - 100) of deposit fees.
   * i.e. `stake_deposit_fee`% of stake deposited is collected as deposit
   * fees for every deposit and `stake_referral_fee`% of the collected
   * stake deposit fees is paid out to the referrer
   */
  stakeReferralFee: number;
  /**
   * Toggles whether the `DepositSol` instruction requires a signature from
   * this `sol_deposit_authority`
   */
  solDepositAuthority: Option<Address>;
  /** Fee assessed on SOL deposits */
  solDepositFee: Fee;
  /**
   * Fees paid out to referrers on referred SOL deposits.
   * Expressed as a percentage (0 - 100) of SOL deposit fees.
   * i.e. `sol_deposit_fee`% of SOL deposited is collected as deposit fees
   * for every deposit and `sol_referral_fee`% of the collected SOL
   * deposit fees is paid out to the referrer
   */
  solReferralFee: number;
  /**
   * Toggles whether the `WithdrawSol` instruction requires a signature from
   * the `deposit_authority`
   */
  solWithdrawAuthority: Option<Address>;
  /** Fee assessed on SOL withdrawals */
  solWithdrawalFee: Fee;
  /** Future SOL withdrawal fee, to be set for the following epoch */
  nextSolWithdrawalFee: FutureEpoch;
  /** Last epoch's total pool tokens, used only for APR estimation */
  lastEpochPoolTokenSupply: bigint;
  /** Last epoch's total lamports, used only for APR estimation */
  lastEpochTotalLamports: bigint;
}

export interface StakePoolArgs {
  /**
   * Manager authority, allows for updating the staker, manager, and fee
   * account
   */
  manager: Address;
  /**
   * Staker authority, allows for adding and removing validators, and
   * managing stake distribution
   */
  staker: Address;
  /**
   * Stake deposit authority
   * If a depositor pubkey is specified on initialization, then deposits must
   * be signed by this authority. If no deposit authority is specified,
   * then the stake pool will default to the result of:
   * `Pubkey::find_program_address(
   * &[&stake_pool_address.as_ref(), b"deposit"],
   * program_id,
   * )`
   */
  stakeDepositAuthority: Address;
  /**
   * Stake withdrawal authority bump seed
   * for `create_program_address(&[state::StakePool account, "withdrawal"])`
   */
  stakeWithdrawBumpSeed: number;
  /** Validator stake list storage account */
  validatorList: Address;
  /** Reserve stake account, holds deactivated stake */
  reserveStake: Address;
  /** Pool Mint */
  poolMint: Address;
  /** Manager fee account */
  managerFeeAccount: Address;
  /** Pool token program id */
  tokenProgramId: Address;
  /**
   * Total stake under management.
   * Note that if `last_update_epoch` does not match the current epoch then
   * this field may not be accurate
   */
  totalLamports: number | bigint;
  /**
   * Total supply of pool tokens (should always match the supply in the Pool
   * Mint)
   */
  poolTokenSupply: number | bigint;
  /** Last epoch the `total_lamports` field was updated */
  lastUpdateEpoch: number | bigint;
  /** Lockup that all stakes in the pool must have */
  lockup: LockupArgs;
  /** Fee taken as a proportion of rewards each epoch */
  epochFee: FeeArgs;
  /** Fee for next epoch */
  nextEpochFee: FutureEpochArgs;
  /** Preferred deposit validator vote account pubkey */
  preferredDepositValidatorVoteAddress: OptionOrNullable<Address>;
  /** Preferred withdraw validator vote account pubkey */
  preferredWithdrawValidatorVoteAddress: OptionOrNullable<Address>;
  /** Fee assessed on stake deposits */
  stakeDepositFee: FeeArgs;
  /** Fee assessed on withdrawals */
  stakeWithdrawalFee: FeeArgs;
  /** Future stake withdrawal fee, to be set for the following epoch */
  nextStakeWithdrawalFee: FutureEpochArgs;
  /**
   * Fees paid out to referrers on referred stake deposits.
   * Expressed as a percentage (0 - 100) of deposit fees.
   * i.e. `stake_deposit_fee`% of stake deposited is collected as deposit
   * fees for every deposit and `stake_referral_fee`% of the collected
   * stake deposit fees is paid out to the referrer
   */
  stakeReferralFee: number;
  /**
   * Toggles whether the `DepositSol` instruction requires a signature from
   * this `sol_deposit_authority`
   */
  solDepositAuthority: OptionOrNullable<Address>;
  /** Fee assessed on SOL deposits */
  solDepositFee: FeeArgs;
  /**
   * Fees paid out to referrers on referred SOL deposits.
   * Expressed as a percentage (0 - 100) of SOL deposit fees.
   * i.e. `sol_deposit_fee`% of SOL deposited is collected as deposit fees
   * for every deposit and `sol_referral_fee`% of the collected SOL
   * deposit fees is paid out to the referrer
   */
  solReferralFee: number;
  /**
   * Toggles whether the `WithdrawSol` instruction requires a signature from
   * the `deposit_authority`
   */
  solWithdrawAuthority: OptionOrNullable<Address>;
  /** Fee assessed on SOL withdrawals */
  solWithdrawalFee: FeeArgs;
  /** Future SOL withdrawal fee, to be set for the following epoch */
  nextSolWithdrawalFee: FutureEpochArgs;
  /** Last epoch's total pool tokens, used only for APR estimation */
  lastEpochPoolTokenSupply: number | bigint;
  /** Last epoch's total lamports, used only for APR estimation */
  lastEpochTotalLamports: number | bigint;
}

export function getStakePoolEncoder(): Encoder<StakePoolArgs> {
  return transformEncoder(
    getStructEncoder([
      ["accountType", getAccountTypeEncoder()],
      ["manager", getAddressEncoder()],
      ["staker", getAddressEncoder()],
      ["stakeDepositAuthority", getAddressEncoder()],
      ["stakeWithdrawBumpSeed", getU8Encoder()],
      ["validatorList", getAddressEncoder()],
      ["reserveStake", getAddressEncoder()],
      ["poolMint", getAddressEncoder()],
      ["managerFeeAccount", getAddressEncoder()],
      ["tokenProgramId", getAddressEncoder()],
      ["totalLamports", getU64Encoder()],
      ["poolTokenSupply", getU64Encoder()],
      ["lastUpdateEpoch", getU64Encoder()],
      ["lockup", getLockupEncoder()],
      ["epochFee", getFeeEncoder()],
      ["nextEpochFee", getFutureEpochEncoder()],
      [
        "preferredDepositValidatorVoteAddress",
        getOptionEncoder(getAddressEncoder()),
      ],
      [
        "preferredWithdrawValidatorVoteAddress",
        getOptionEncoder(getAddressEncoder()),
      ],
      ["stakeDepositFee", getFeeEncoder()],
      ["stakeWithdrawalFee", getFeeEncoder()],
      ["nextStakeWithdrawalFee", getFutureEpochEncoder()],
      ["stakeReferralFee", getU8Encoder()],
      ["solDepositAuthority", getOptionEncoder(getAddressEncoder())],
      ["solDepositFee", getFeeEncoder()],
      ["solReferralFee", getU8Encoder()],
      ["solWithdrawAuthority", getOptionEncoder(getAddressEncoder())],
      ["solWithdrawalFee", getFeeEncoder()],
      ["nextSolWithdrawalFee", getFutureEpochEncoder()],
      ["lastEpochPoolTokenSupply", getU64Encoder()],
      ["lastEpochTotalLamports", getU64Encoder()],
    ]),
    (value) => ({ ...value, accountType: STAKE_POOL_ACCOUNT_TYPE }),
  );
}

export function getStakePoolDecoder(): Decoder<StakePool> {
  return getStructDecoder([
    ["accountType", getAccountTypeDecoder()],
    ["manager", getAddressDecoder()],
    ["staker", getAddressDecoder()],
    ["stakeDepositAuthority", getAddressDecoder()],
    ["stakeWithdrawBumpSeed", getU8Decoder()],
    ["validatorList", getAddressDecoder()],
    ["reserveStake", getAddressDecoder()],
    ["poolMint", getAddressDecoder()],
    ["managerFeeAccount", getAddressDecoder()],
    ["tokenProgramId", getAddressDecoder()],
    ["totalLamports", getU64Decoder()],
    ["poolTokenSupply", getU64Decoder()],
    ["lastUpdateEpoch", getU64Decoder()],
    ["lockup", getLockupDecoder()],
    ["epochFee", getFeeDecoder()],
    ["nextEpochFee", getFutureEpochDecoder()],
    [
      "preferredDepositValidatorVoteAddress",
      getOptionDecoder(getAddressDecoder()),
    ],
    [
      "preferredWithdrawValidatorVoteAddress",
      getOptionDecoder(getAddressDecoder()),
    ],
    ["stakeDepositFee", getFeeDecoder()],
    ["stakeWithdrawalFee", getFeeDecoder()],
    ["nextStakeWithdrawalFee", getFutureEpochDecoder()],
    ["stakeReferralFee", getU8Decoder()],
    ["solDepositAuthority", getOptionDecoder(getAddressDecoder())],
    ["solDepositFee", getFeeDecoder()],
    ["solReferralFee", getU8Decoder()],
    ["solWithdrawAuthority", getOptionDecoder(getAddressDecoder())],
    ["solWithdrawalFee", getFeeDecoder()],
    ["nextSolWithdrawalFee", getFutureEpochDecoder()],
    ["lastEpochPoolTokenSupply", getU64Decoder()],
    ["lastEpochTotalLamports", getU64Decoder()],
  ]);
}

export function getStakePoolCodec(): Codec<StakePoolArgs, StakePool> {
  return combineCodec(getStakePoolEncoder(), getStakePoolDecoder());
}

export function decodeStakePool<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<StakePool, TAddress>;
export function decodeStakePool<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<StakePool, TAddress>;
export function decodeStakePool<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<StakePool, TAddress> | MaybeAccount<StakePool, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getStakePoolDecoder(),
  );
}

export async function fetchStakePool<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<StakePool, TAddress>> {
  const maybeAccount = await fetchMaybeStakePool(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeStakePool<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<StakePool, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeStakePool(maybeAccount);
}

export async function fetchAllStakePool(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<Account<StakePool>[]> {
  const maybeAccounts = await fetchAllMaybeStakePool(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeStakePool(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<StakePool>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeStakePool(maybeAccount));
}
