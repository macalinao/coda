/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  Account,
  Address,
  EncodedAccount,
  FetchAccountConfig,
  FetchAccountsConfig,
  FixedSizeCodec,
  FixedSizeDecoder,
  FixedSizeEncoder,
  MaybeAccount,
  MaybeEncodedAccount,
  ReadonlyUint8Array,
} from "@solana/kit";
import type {
  PoolFeesStruct,
  PoolFeesStructArgs,
  PoolMetrics,
  PoolMetricsArgs,
  RewardInfo,
  RewardInfoArgs,
} from "../types/index.js";
import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  getU64Decoder,
  getU64Encoder,
  getU128Decoder,
  getU128Encoder,
  transformEncoder,
} from "@solana/kit";
import {
  getPoolFeesStructDecoder,
  getPoolFeesStructEncoder,
  getPoolMetricsDecoder,
  getPoolMetricsEncoder,
  getRewardInfoDecoder,
  getRewardInfoEncoder,
} from "../types/index.js";

export const POOL_DISCRIMINATOR: ReadonlyUint8Array = new Uint8Array([
  241, 154, 109, 4, 17, 177, 109, 188,
]);

export function getPoolDiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(POOL_DISCRIMINATOR);
}

export interface Pool {
  discriminator: ReadonlyUint8Array;
  /** Pool fee */
  poolFees: PoolFeesStruct;
  /** token a mint */
  tokenAMint: Address;
  /** token b mint */
  tokenBMint: Address;
  /** token a vault */
  tokenAVault: Address;
  /** token b vault */
  tokenBVault: Address;
  /** Whitelisted vault to be able to buy pool before activation_point */
  whitelistedVault: Address;
  /** partner */
  partner: Address;
  /** liquidity share */
  liquidity: bigint;
  /** padding, previous reserve amount, be careful to use that field */
  padding: bigint;
  /** protocol a fee */
  protocolAFee: bigint;
  /** protocol b fee */
  protocolBFee: bigint;
  /** partner a fee */
  partnerAFee: bigint;
  /** partner b fee */
  partnerBFee: bigint;
  /** min price */
  sqrtMinPrice: bigint;
  /** max price */
  sqrtMaxPrice: bigint;
  /** current price */
  sqrtPrice: bigint;
  /** Activation point, can be slot or timestamp */
  activationPoint: bigint;
  /** Activation type, 0 means by slot, 1 means by timestamp */
  activationType: number;
  /** pool status, 0: enable, 1 disable */
  poolStatus: number;
  /** token a flag */
  tokenAFlag: number;
  /** token b flag */
  tokenBFlag: number;
  /** 0 is collect fee in both token, 1 only collect fee in token a, 2 only collect fee in token b */
  collectFeeMode: number;
  /** pool type */
  poolType: number;
  /** pool version, 0: max_fee is still capped at 50%, 1: max_fee is capped at 99% */
  version: number;
  /** padding */
  padding0: number;
  /** cumulative */
  feeAPerLiquidity: number[];
  /** cumulative */
  feeBPerLiquidity: number[];
  permanentLockLiquidity: bigint;
  /** metrics */
  metrics: PoolMetrics;
  /** pool creator */
  creator: Address;
  /** Padding for further use */
  padding1: bigint[];
  /** Farming reward information */
  rewardInfos: RewardInfo[];
}

export interface PoolArgs {
  /** Pool fee */
  poolFees: PoolFeesStructArgs;
  /** token a mint */
  tokenAMint: Address;
  /** token b mint */
  tokenBMint: Address;
  /** token a vault */
  tokenAVault: Address;
  /** token b vault */
  tokenBVault: Address;
  /** Whitelisted vault to be able to buy pool before activation_point */
  whitelistedVault: Address;
  /** partner */
  partner: Address;
  /** liquidity share */
  liquidity: number | bigint;
  /** padding, previous reserve amount, be careful to use that field */
  padding: number | bigint;
  /** protocol a fee */
  protocolAFee: number | bigint;
  /** protocol b fee */
  protocolBFee: number | bigint;
  /** partner a fee */
  partnerAFee: number | bigint;
  /** partner b fee */
  partnerBFee: number | bigint;
  /** min price */
  sqrtMinPrice: number | bigint;
  /** max price */
  sqrtMaxPrice: number | bigint;
  /** current price */
  sqrtPrice: number | bigint;
  /** Activation point, can be slot or timestamp */
  activationPoint: number | bigint;
  /** Activation type, 0 means by slot, 1 means by timestamp */
  activationType: number;
  /** pool status, 0: enable, 1 disable */
  poolStatus: number;
  /** token a flag */
  tokenAFlag: number;
  /** token b flag */
  tokenBFlag: number;
  /** 0 is collect fee in both token, 1 only collect fee in token a, 2 only collect fee in token b */
  collectFeeMode: number;
  /** pool type */
  poolType: number;
  /** pool version, 0: max_fee is still capped at 50%, 1: max_fee is capped at 99% */
  version: number;
  /** padding */
  padding0: number;
  /** cumulative */
  feeAPerLiquidity: number[];
  /** cumulative */
  feeBPerLiquidity: number[];
  permanentLockLiquidity: number | bigint;
  /** metrics */
  metrics: PoolMetricsArgs;
  /** pool creator */
  creator: Address;
  /** Padding for further use */
  padding1: (number | bigint)[];
  /** Farming reward information */
  rewardInfos: RewardInfoArgs[];
}

export function getPoolEncoder(): FixedSizeEncoder<PoolArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["poolFees", getPoolFeesStructEncoder()],
      ["tokenAMint", getAddressEncoder()],
      ["tokenBMint", getAddressEncoder()],
      ["tokenAVault", getAddressEncoder()],
      ["tokenBVault", getAddressEncoder()],
      ["whitelistedVault", getAddressEncoder()],
      ["partner", getAddressEncoder()],
      ["liquidity", getU128Encoder()],
      ["padding", getU128Encoder()],
      ["protocolAFee", getU64Encoder()],
      ["protocolBFee", getU64Encoder()],
      ["partnerAFee", getU64Encoder()],
      ["partnerBFee", getU64Encoder()],
      ["sqrtMinPrice", getU128Encoder()],
      ["sqrtMaxPrice", getU128Encoder()],
      ["sqrtPrice", getU128Encoder()],
      ["activationPoint", getU64Encoder()],
      ["activationType", getU8Encoder()],
      ["poolStatus", getU8Encoder()],
      ["tokenAFlag", getU8Encoder()],
      ["tokenBFlag", getU8Encoder()],
      ["collectFeeMode", getU8Encoder()],
      ["poolType", getU8Encoder()],
      ["version", getU8Encoder()],
      ["padding0", getU8Encoder()],
      ["feeAPerLiquidity", getArrayEncoder(getU8Encoder(), { size: 32 })],
      ["feeBPerLiquidity", getArrayEncoder(getU8Encoder(), { size: 32 })],
      ["permanentLockLiquidity", getU128Encoder()],
      ["metrics", getPoolMetricsEncoder()],
      ["creator", getAddressEncoder()],
      ["padding1", getArrayEncoder(getU64Encoder(), { size: 6 })],
      ["rewardInfos", getArrayEncoder(getRewardInfoEncoder(), { size: 2 })],
    ]),
    (value) => ({ ...value, discriminator: POOL_DISCRIMINATOR }),
  );
}

export function getPoolDecoder(): FixedSizeDecoder<Pool> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["poolFees", getPoolFeesStructDecoder()],
    ["tokenAMint", getAddressDecoder()],
    ["tokenBMint", getAddressDecoder()],
    ["tokenAVault", getAddressDecoder()],
    ["tokenBVault", getAddressDecoder()],
    ["whitelistedVault", getAddressDecoder()],
    ["partner", getAddressDecoder()],
    ["liquidity", getU128Decoder()],
    ["padding", getU128Decoder()],
    ["protocolAFee", getU64Decoder()],
    ["protocolBFee", getU64Decoder()],
    ["partnerAFee", getU64Decoder()],
    ["partnerBFee", getU64Decoder()],
    ["sqrtMinPrice", getU128Decoder()],
    ["sqrtMaxPrice", getU128Decoder()],
    ["sqrtPrice", getU128Decoder()],
    ["activationPoint", getU64Decoder()],
    ["activationType", getU8Decoder()],
    ["poolStatus", getU8Decoder()],
    ["tokenAFlag", getU8Decoder()],
    ["tokenBFlag", getU8Decoder()],
    ["collectFeeMode", getU8Decoder()],
    ["poolType", getU8Decoder()],
    ["version", getU8Decoder()],
    ["padding0", getU8Decoder()],
    ["feeAPerLiquidity", getArrayDecoder(getU8Decoder(), { size: 32 })],
    ["feeBPerLiquidity", getArrayDecoder(getU8Decoder(), { size: 32 })],
    ["permanentLockLiquidity", getU128Decoder()],
    ["metrics", getPoolMetricsDecoder()],
    ["creator", getAddressDecoder()],
    ["padding1", getArrayDecoder(getU64Decoder(), { size: 6 })],
    ["rewardInfos", getArrayDecoder(getRewardInfoDecoder(), { size: 2 })],
  ]);
}

export function getPoolCodec(): FixedSizeCodec<PoolArgs, Pool> {
  return combineCodec(getPoolEncoder(), getPoolDecoder());
}

export function decodePool<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<Pool, TAddress>;
export function decodePool<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<Pool, TAddress>;
export function decodePool<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<Pool, TAddress> | MaybeAccount<Pool, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getPoolDecoder(),
  );
}

export async function fetchPool<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<Pool, TAddress>> {
  const maybeAccount = await fetchMaybePool(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybePool<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<Pool, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodePool(maybeAccount);
}

export async function fetchAllPool(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<Account<Pool>[]> {
  const maybeAccounts = await fetchAllMaybePool(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybePool(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<Pool>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodePool(maybeAccount));
}
