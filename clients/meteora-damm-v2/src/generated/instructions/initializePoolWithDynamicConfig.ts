/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  AccountMeta,
  AccountSignerMeta,
  Address,
  Codec,
  Decoder,
  Encoder,
  Instruction,
  InstructionWithAccounts,
  InstructionWithData,
  ReadonlyAccount,
  ReadonlySignerAccount,
  ReadonlyUint8Array,
  TransactionSigner,
  WritableAccount,
  WritableSignerAccount,
} from "@solana/kit";
import type { ResolvedAccount } from "../shared/index.js";
import type {
  InitializeCustomizablePoolParameters,
  InitializeCustomizablePoolParametersArgs,
} from "../types/index.js";
import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
} from "@solana/kit";
import {
  findEventAuthorityPda,
  findPoolAuthorityPda,
  findPoolPda,
  findPositionNftAccountPda,
  findTokenVaultPda,
} from "../pdas/index.js";
import { CP_AMM_PROGRAM_ADDRESS } from "../programs/index.js";
import { expectAddress, getAccountMetaFactory } from "../shared/index.js";
import {
  getInitializeCustomizablePoolParametersDecoder,
  getInitializeCustomizablePoolParametersEncoder,
} from "../types/index.js";

export const INITIALIZE_POOL_WITH_DYNAMIC_CONFIG_DISCRIMINATOR: ReadonlyUint8Array =
  new Uint8Array([149, 82, 72, 197, 253, 252, 68, 15]);

export function getInitializePoolWithDynamicConfigDiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    INITIALIZE_POOL_WITH_DYNAMIC_CONFIG_DISCRIMINATOR,
  );
}

export type InitializePoolWithDynamicConfigInstruction<
  TProgram extends string = typeof CP_AMM_PROGRAM_ADDRESS,
  TAccountCreator extends string | AccountMeta = string,
  TAccountPositionNftMint extends string | AccountMeta = string,
  TAccountPositionNftAccount extends string | AccountMeta = string,
  TAccountPayer extends string | AccountMeta = string,
  TAccountPoolCreatorAuthority extends string | AccountMeta = string,
  TAccountConfig extends string | AccountMeta = string,
  TAccountPoolAuthority extends string | AccountMeta = string,
  TAccountPool extends string | AccountMeta = string,
  TAccountPosition extends string | AccountMeta = string,
  TAccountTokenAMint extends string | AccountMeta = string,
  TAccountTokenBMint extends string | AccountMeta = string,
  TAccountTokenAVault extends string | AccountMeta = string,
  TAccountTokenBVault extends string | AccountMeta = string,
  TAccountPayerTokenA extends string | AccountMeta = string,
  TAccountPayerTokenB extends string | AccountMeta = string,
  TAccountTokenAProgram extends
    | string
    | AccountMeta = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
  TAccountTokenBProgram extends
    | string
    | AccountMeta = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
  TAccountToken2022Program extends
    | string
    | AccountMeta = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
  TAccountSystemProgram extends
    | string
    | AccountMeta = "11111111111111111111111111111111",
  TAccountEventAuthority extends string | AccountMeta = string,
  TAccountProgram extends
    | string
    | AccountMeta = "cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG",
  TRemainingAccounts extends readonly AccountMeta[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountCreator extends string
        ? ReadonlyAccount<TAccountCreator>
        : TAccountCreator,
      TAccountPositionNftMint extends string
        ? WritableSignerAccount<TAccountPositionNftMint> &
            AccountSignerMeta<TAccountPositionNftMint>
        : TAccountPositionNftMint,
      TAccountPositionNftAccount extends string
        ? WritableAccount<TAccountPositionNftAccount>
        : TAccountPositionNftAccount,
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountPoolCreatorAuthority extends string
        ? ReadonlySignerAccount<TAccountPoolCreatorAuthority> &
            AccountSignerMeta<TAccountPoolCreatorAuthority>
        : TAccountPoolCreatorAuthority,
      TAccountConfig extends string
        ? ReadonlyAccount<TAccountConfig>
        : TAccountConfig,
      TAccountPoolAuthority extends string
        ? ReadonlyAccount<TAccountPoolAuthority>
        : TAccountPoolAuthority,
      TAccountPool extends string
        ? WritableAccount<TAccountPool>
        : TAccountPool,
      TAccountPosition extends string
        ? WritableAccount<TAccountPosition>
        : TAccountPosition,
      TAccountTokenAMint extends string
        ? ReadonlyAccount<TAccountTokenAMint>
        : TAccountTokenAMint,
      TAccountTokenBMint extends string
        ? ReadonlyAccount<TAccountTokenBMint>
        : TAccountTokenBMint,
      TAccountTokenAVault extends string
        ? WritableAccount<TAccountTokenAVault>
        : TAccountTokenAVault,
      TAccountTokenBVault extends string
        ? WritableAccount<TAccountTokenBVault>
        : TAccountTokenBVault,
      TAccountPayerTokenA extends string
        ? WritableAccount<TAccountPayerTokenA>
        : TAccountPayerTokenA,
      TAccountPayerTokenB extends string
        ? WritableAccount<TAccountPayerTokenB>
        : TAccountPayerTokenB,
      TAccountTokenAProgram extends string
        ? ReadonlyAccount<TAccountTokenAProgram>
        : TAccountTokenAProgram,
      TAccountTokenBProgram extends string
        ? ReadonlyAccount<TAccountTokenBProgram>
        : TAccountTokenBProgram,
      TAccountToken2022Program extends string
        ? ReadonlyAccount<TAccountToken2022Program>
        : TAccountToken2022Program,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountEventAuthority extends string
        ? ReadonlyAccount<TAccountEventAuthority>
        : TAccountEventAuthority,
      TAccountProgram extends string
        ? ReadonlyAccount<TAccountProgram>
        : TAccountProgram,
      ...TRemainingAccounts,
    ]
  >;

export interface InitializePoolWithDynamicConfigInstructionData {
  discriminator: ReadonlyUint8Array;
  params: InitializeCustomizablePoolParameters;
}

export interface InitializePoolWithDynamicConfigInstructionDataArgs {
  params: InitializeCustomizablePoolParametersArgs;
}

export function getInitializePoolWithDynamicConfigInstructionDataEncoder(): Encoder<InitializePoolWithDynamicConfigInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["params", getInitializeCustomizablePoolParametersEncoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_POOL_WITH_DYNAMIC_CONFIG_DISCRIMINATOR,
    }),
  );
}

export function getInitializePoolWithDynamicConfigInstructionDataDecoder(): Decoder<InitializePoolWithDynamicConfigInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["params", getInitializeCustomizablePoolParametersDecoder()],
  ]);
}

export function getInitializePoolWithDynamicConfigInstructionDataCodec(): Codec<
  InitializePoolWithDynamicConfigInstructionDataArgs,
  InitializePoolWithDynamicConfigInstructionData
> {
  return combineCodec(
    getInitializePoolWithDynamicConfigInstructionDataEncoder(),
    getInitializePoolWithDynamicConfigInstructionDataDecoder(),
  );
}

export interface InitializePoolWithDynamicConfigAsyncInput<
  TAccountCreator extends string = string,
  TAccountPositionNftMint extends string = string,
  TAccountPositionNftAccount extends string = string,
  TAccountPayer extends string = string,
  TAccountPoolCreatorAuthority extends string = string,
  TAccountConfig extends string = string,
  TAccountPoolAuthority extends string = string,
  TAccountPool extends string = string,
  TAccountPosition extends string = string,
  TAccountTokenAMint extends string = string,
  TAccountTokenBMint extends string = string,
  TAccountTokenAVault extends string = string,
  TAccountTokenBVault extends string = string,
  TAccountPayerTokenA extends string = string,
  TAccountPayerTokenB extends string = string,
  TAccountTokenAProgram extends string = string,
  TAccountTokenBProgram extends string = string,
  TAccountToken2022Program extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> {
  creator: Address<TAccountCreator>;
  /** position_nft_mint */
  positionNftMint: TransactionSigner<TAccountPositionNftMint>;
  /** position nft account */
  positionNftAccount?: Address<TAccountPositionNftAccount>;
  /** Address paying to create the pool. Can be anyone */
  payer: TransactionSigner<TAccountPayer>;
  poolCreatorAuthority: TransactionSigner<TAccountPoolCreatorAuthority>;
  /** Which config the pool belongs to. */
  config: Address<TAccountConfig>;
  poolAuthority?: Address<TAccountPoolAuthority>;
  /** Initialize an account to store the pool state */
  pool?: Address<TAccountPool>;
  position?: Address<TAccountPosition>;
  /** Token a mint */
  tokenAMint: Address<TAccountTokenAMint>;
  /** Token b mint */
  tokenBMint: Address<TAccountTokenBMint>;
  /** Token a vault for the pool */
  tokenAVault?: Address<TAccountTokenAVault>;
  /** Token b vault for the pool */
  tokenBVault?: Address<TAccountTokenBVault>;
  /** payer token a account */
  payerTokenA: Address<TAccountPayerTokenA>;
  /** creator token b account */
  payerTokenB: Address<TAccountPayerTokenB>;
  /** Program to create mint account and mint tokens */
  tokenAProgram?: Address<TAccountTokenAProgram>;
  /** Program to create mint account and mint tokens */
  tokenBProgram?: Address<TAccountTokenBProgram>;
  /** Program to create NFT mint/token account and transfer for token22 account */
  token2022Program?: Address<TAccountToken2022Program>;
  systemProgram?: Address<TAccountSystemProgram>;
  eventAuthority?: Address<TAccountEventAuthority>;
  program?: Address<TAccountProgram>;
  params: InitializePoolWithDynamicConfigInstructionDataArgs["params"];
}

export async function getInitializePoolWithDynamicConfigInstructionAsync<
  TAccountCreator extends string,
  TAccountPositionNftMint extends string,
  TAccountPositionNftAccount extends string,
  TAccountPayer extends string,
  TAccountPoolCreatorAuthority extends string,
  TAccountConfig extends string,
  TAccountPoolAuthority extends string,
  TAccountPool extends string,
  TAccountPosition extends string,
  TAccountTokenAMint extends string,
  TAccountTokenBMint extends string,
  TAccountTokenAVault extends string,
  TAccountTokenBVault extends string,
  TAccountPayerTokenA extends string,
  TAccountPayerTokenB extends string,
  TAccountTokenAProgram extends string,
  TAccountTokenBProgram extends string,
  TAccountToken2022Program extends string,
  TAccountSystemProgram extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof CP_AMM_PROGRAM_ADDRESS,
>(
  input: InitializePoolWithDynamicConfigAsyncInput<
    TAccountCreator,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPayer,
    TAccountPoolCreatorAuthority,
    TAccountConfig,
    TAccountPoolAuthority,
    TAccountPool,
    TAccountPosition,
    TAccountTokenAMint,
    TAccountTokenBMint,
    TAccountTokenAVault,
    TAccountTokenBVault,
    TAccountPayerTokenA,
    TAccountPayerTokenB,
    TAccountTokenAProgram,
    TAccountTokenBProgram,
    TAccountToken2022Program,
    TAccountSystemProgram,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress },
): Promise<
  InitializePoolWithDynamicConfigInstruction<
    TProgramAddress,
    TAccountCreator,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPayer,
    TAccountPoolCreatorAuthority,
    TAccountConfig,
    TAccountPoolAuthority,
    TAccountPool,
    TAccountPosition,
    TAccountTokenAMint,
    TAccountTokenBMint,
    TAccountTokenAVault,
    TAccountTokenBVault,
    TAccountPayerTokenA,
    TAccountPayerTokenB,
    TAccountTokenAProgram,
    TAccountTokenBProgram,
    TAccountToken2022Program,
    TAccountSystemProgram,
    TAccountEventAuthority,
    TAccountProgram
  >
> {
  // Program address.
  const programAddress = config?.programAddress ?? CP_AMM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    creator: { value: input.creator ?? null, isWritable: false },
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true,
    },
    payer: { value: input.payer ?? null, isWritable: true },
    poolCreatorAuthority: {
      value: input.poolCreatorAuthority ?? null,
      isWritable: false,
    },
    config: { value: input.config ?? null, isWritable: false },
    poolAuthority: { value: input.poolAuthority ?? null, isWritable: false },
    pool: { value: input.pool ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    tokenAMint: { value: input.tokenAMint ?? null, isWritable: false },
    tokenBMint: { value: input.tokenBMint ?? null, isWritable: false },
    tokenAVault: { value: input.tokenAVault ?? null, isWritable: true },
    tokenBVault: { value: input.tokenBVault ?? null, isWritable: true },
    payerTokenA: { value: input.payerTokenA ?? null, isWritable: true },
    payerTokenB: { value: input.payerTokenB ?? null, isWritable: true },
    tokenAProgram: { value: input.tokenAProgram ?? null, isWritable: false },
    tokenBProgram: { value: input.tokenBProgram ?? null, isWritable: false },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false,
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.positionNftAccount.value) {
    accounts.positionNftAccount.value = await findPositionNftAccountPda({
      positionNftMint: expectAddress(accounts.positionNftMint.value),
    });
  }
  if (!accounts.poolAuthority.value) {
    accounts.poolAuthority.value = await findPoolAuthorityPda();
  }
  if (!accounts.pool.value) {
    accounts.pool.value = await findPoolPda({
      config: expectAddress(accounts.config.value),
      tokenAMint: expectAddress(accounts.tokenAMint.value),
      tokenBMint: expectAddress(accounts.tokenBMint.value),
    });
  }
  if (!accounts.position.value) {
    accounts.position.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([112, 111, 115, 105, 116, 105, 111, 110]),
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.positionNftMint.value),
        ),
      ],
    });
  }
  if (!accounts.tokenAVault.value) {
    accounts.tokenAVault.value = await findTokenVaultPda({
      tokenMint: expectAddress(accounts.tokenAMint.value),
      pool: expectAddress(accounts.pool.value),
    });
  }
  if (!accounts.tokenBVault.value) {
    accounts.tokenBVault.value = await findTokenVaultPda({
      tokenMint: expectAddress(accounts.tokenBMint.value),
      pool: expectAddress(accounts.pool.value),
    });
  }
  if (!accounts.tokenAProgram.value) {
    accounts.tokenAProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }
  if (!accounts.tokenBProgram.value) {
    accounts.tokenBProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }
  if (!accounts.token2022Program.value) {
    accounts.token2022Program.value =
      "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb" as Address<"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb">;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }
  if (!accounts.eventAuthority.value) {
    accounts.eventAuthority.value = await findEventAuthorityPda();
  }
  if (!accounts.program.value) {
    accounts.program.value =
      "cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG" as Address<"cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.creator),
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.poolCreatorAuthority),
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.poolAuthority),
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.tokenAMint),
      getAccountMeta(accounts.tokenBMint),
      getAccountMeta(accounts.tokenAVault),
      getAccountMeta(accounts.tokenBVault),
      getAccountMeta(accounts.payerTokenA),
      getAccountMeta(accounts.payerTokenB),
      getAccountMeta(accounts.tokenAProgram),
      getAccountMeta(accounts.tokenBProgram),
      getAccountMeta(accounts.token2022Program),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    data: getInitializePoolWithDynamicConfigInstructionDataEncoder().encode(
      args as InitializePoolWithDynamicConfigInstructionDataArgs,
    ),
    programAddress,
  } as InitializePoolWithDynamicConfigInstruction<
    TProgramAddress,
    TAccountCreator,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPayer,
    TAccountPoolCreatorAuthority,
    TAccountConfig,
    TAccountPoolAuthority,
    TAccountPool,
    TAccountPosition,
    TAccountTokenAMint,
    TAccountTokenBMint,
    TAccountTokenAVault,
    TAccountTokenBVault,
    TAccountPayerTokenA,
    TAccountPayerTokenB,
    TAccountTokenAProgram,
    TAccountTokenBProgram,
    TAccountToken2022Program,
    TAccountSystemProgram,
    TAccountEventAuthority,
    TAccountProgram
  >);
}

export interface InitializePoolWithDynamicConfigInput<
  TAccountCreator extends string = string,
  TAccountPositionNftMint extends string = string,
  TAccountPositionNftAccount extends string = string,
  TAccountPayer extends string = string,
  TAccountPoolCreatorAuthority extends string = string,
  TAccountConfig extends string = string,
  TAccountPoolAuthority extends string = string,
  TAccountPool extends string = string,
  TAccountPosition extends string = string,
  TAccountTokenAMint extends string = string,
  TAccountTokenBMint extends string = string,
  TAccountTokenAVault extends string = string,
  TAccountTokenBVault extends string = string,
  TAccountPayerTokenA extends string = string,
  TAccountPayerTokenB extends string = string,
  TAccountTokenAProgram extends string = string,
  TAccountTokenBProgram extends string = string,
  TAccountToken2022Program extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> {
  creator: Address<TAccountCreator>;
  /** position_nft_mint */
  positionNftMint: TransactionSigner<TAccountPositionNftMint>;
  /** position nft account */
  positionNftAccount: Address<TAccountPositionNftAccount>;
  /** Address paying to create the pool. Can be anyone */
  payer: TransactionSigner<TAccountPayer>;
  poolCreatorAuthority: TransactionSigner<TAccountPoolCreatorAuthority>;
  /** Which config the pool belongs to. */
  config: Address<TAccountConfig>;
  poolAuthority: Address<TAccountPoolAuthority>;
  /** Initialize an account to store the pool state */
  pool: Address<TAccountPool>;
  position: Address<TAccountPosition>;
  /** Token a mint */
  tokenAMint: Address<TAccountTokenAMint>;
  /** Token b mint */
  tokenBMint: Address<TAccountTokenBMint>;
  /** Token a vault for the pool */
  tokenAVault: Address<TAccountTokenAVault>;
  /** Token b vault for the pool */
  tokenBVault: Address<TAccountTokenBVault>;
  /** payer token a account */
  payerTokenA: Address<TAccountPayerTokenA>;
  /** creator token b account */
  payerTokenB: Address<TAccountPayerTokenB>;
  /** Program to create mint account and mint tokens */
  tokenAProgram?: Address<TAccountTokenAProgram>;
  /** Program to create mint account and mint tokens */
  tokenBProgram?: Address<TAccountTokenBProgram>;
  /** Program to create NFT mint/token account and transfer for token22 account */
  token2022Program?: Address<TAccountToken2022Program>;
  systemProgram?: Address<TAccountSystemProgram>;
  eventAuthority: Address<TAccountEventAuthority>;
  program?: Address<TAccountProgram>;
  params: InitializePoolWithDynamicConfigInstructionDataArgs["params"];
}

export function getInitializePoolWithDynamicConfigInstruction<
  TAccountCreator extends string,
  TAccountPositionNftMint extends string,
  TAccountPositionNftAccount extends string,
  TAccountPayer extends string,
  TAccountPoolCreatorAuthority extends string,
  TAccountConfig extends string,
  TAccountPoolAuthority extends string,
  TAccountPool extends string,
  TAccountPosition extends string,
  TAccountTokenAMint extends string,
  TAccountTokenBMint extends string,
  TAccountTokenAVault extends string,
  TAccountTokenBVault extends string,
  TAccountPayerTokenA extends string,
  TAccountPayerTokenB extends string,
  TAccountTokenAProgram extends string,
  TAccountTokenBProgram extends string,
  TAccountToken2022Program extends string,
  TAccountSystemProgram extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof CP_AMM_PROGRAM_ADDRESS,
>(
  input: InitializePoolWithDynamicConfigInput<
    TAccountCreator,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPayer,
    TAccountPoolCreatorAuthority,
    TAccountConfig,
    TAccountPoolAuthority,
    TAccountPool,
    TAccountPosition,
    TAccountTokenAMint,
    TAccountTokenBMint,
    TAccountTokenAVault,
    TAccountTokenBVault,
    TAccountPayerTokenA,
    TAccountPayerTokenB,
    TAccountTokenAProgram,
    TAccountTokenBProgram,
    TAccountToken2022Program,
    TAccountSystemProgram,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress },
): InitializePoolWithDynamicConfigInstruction<
  TProgramAddress,
  TAccountCreator,
  TAccountPositionNftMint,
  TAccountPositionNftAccount,
  TAccountPayer,
  TAccountPoolCreatorAuthority,
  TAccountConfig,
  TAccountPoolAuthority,
  TAccountPool,
  TAccountPosition,
  TAccountTokenAMint,
  TAccountTokenBMint,
  TAccountTokenAVault,
  TAccountTokenBVault,
  TAccountPayerTokenA,
  TAccountPayerTokenB,
  TAccountTokenAProgram,
  TAccountTokenBProgram,
  TAccountToken2022Program,
  TAccountSystemProgram,
  TAccountEventAuthority,
  TAccountProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? CP_AMM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    creator: { value: input.creator ?? null, isWritable: false },
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true,
    },
    payer: { value: input.payer ?? null, isWritable: true },
    poolCreatorAuthority: {
      value: input.poolCreatorAuthority ?? null,
      isWritable: false,
    },
    config: { value: input.config ?? null, isWritable: false },
    poolAuthority: { value: input.poolAuthority ?? null, isWritable: false },
    pool: { value: input.pool ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    tokenAMint: { value: input.tokenAMint ?? null, isWritable: false },
    tokenBMint: { value: input.tokenBMint ?? null, isWritable: false },
    tokenAVault: { value: input.tokenAVault ?? null, isWritable: true },
    tokenBVault: { value: input.tokenBVault ?? null, isWritable: true },
    payerTokenA: { value: input.payerTokenA ?? null, isWritable: true },
    payerTokenB: { value: input.payerTokenB ?? null, isWritable: true },
    tokenAProgram: { value: input.tokenAProgram ?? null, isWritable: false },
    tokenBProgram: { value: input.tokenBProgram ?? null, isWritable: false },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false,
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenAProgram.value) {
    accounts.tokenAProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }
  if (!accounts.tokenBProgram.value) {
    accounts.tokenBProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }
  if (!accounts.token2022Program.value) {
    accounts.token2022Program.value =
      "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb" as Address<"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb">;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }
  if (!accounts.program.value) {
    accounts.program.value =
      "cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG" as Address<"cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.creator),
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.poolCreatorAuthority),
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.poolAuthority),
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.tokenAMint),
      getAccountMeta(accounts.tokenBMint),
      getAccountMeta(accounts.tokenAVault),
      getAccountMeta(accounts.tokenBVault),
      getAccountMeta(accounts.payerTokenA),
      getAccountMeta(accounts.payerTokenB),
      getAccountMeta(accounts.tokenAProgram),
      getAccountMeta(accounts.tokenBProgram),
      getAccountMeta(accounts.token2022Program),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    data: getInitializePoolWithDynamicConfigInstructionDataEncoder().encode(
      args as InitializePoolWithDynamicConfigInstructionDataArgs,
    ),
    programAddress,
  } as InitializePoolWithDynamicConfigInstruction<
    TProgramAddress,
    TAccountCreator,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPayer,
    TAccountPoolCreatorAuthority,
    TAccountConfig,
    TAccountPoolAuthority,
    TAccountPool,
    TAccountPosition,
    TAccountTokenAMint,
    TAccountTokenBMint,
    TAccountTokenAVault,
    TAccountTokenBVault,
    TAccountPayerTokenA,
    TAccountPayerTokenB,
    TAccountTokenAProgram,
    TAccountTokenBProgram,
    TAccountToken2022Program,
    TAccountSystemProgram,
    TAccountEventAuthority,
    TAccountProgram
  >);
}

export interface ParsedInitializePoolWithDynamicConfigInstruction<
  TProgram extends string = typeof CP_AMM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> {
  programAddress: Address<TProgram>;
  accounts: {
    creator: TAccountMetas[0];
    /** position_nft_mint */
    positionNftMint: TAccountMetas[1];
    /** position nft account */
    positionNftAccount: TAccountMetas[2];
    /** Address paying to create the pool. Can be anyone */
    payer: TAccountMetas[3];
    poolCreatorAuthority: TAccountMetas[4];
    /** Which config the pool belongs to. */
    config: TAccountMetas[5];
    poolAuthority: TAccountMetas[6];
    /** Initialize an account to store the pool state */
    pool: TAccountMetas[7];
    position: TAccountMetas[8];
    /** Token a mint */
    tokenAMint: TAccountMetas[9];
    /** Token b mint */
    tokenBMint: TAccountMetas[10];
    /** Token a vault for the pool */
    tokenAVault: TAccountMetas[11];
    /** Token b vault for the pool */
    tokenBVault: TAccountMetas[12];
    /** payer token a account */
    payerTokenA: TAccountMetas[13];
    /** creator token b account */
    payerTokenB: TAccountMetas[14];
    /** Program to create mint account and mint tokens */
    tokenAProgram: TAccountMetas[15];
    /** Program to create mint account and mint tokens */
    tokenBProgram: TAccountMetas[16];
    /** Program to create NFT mint/token account and transfer for token22 account */
    token2022Program: TAccountMetas[17];
    systemProgram: TAccountMetas[18];
    eventAuthority: TAccountMetas[19];
    program: TAccountMetas[20];
  };
  data: InitializePoolWithDynamicConfigInstructionData;
}

export function parseInitializePoolWithDynamicConfigInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedInitializePoolWithDynamicConfigInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 21) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      creator: getNextAccount(),
      positionNftMint: getNextAccount(),
      positionNftAccount: getNextAccount(),
      payer: getNextAccount(),
      poolCreatorAuthority: getNextAccount(),
      config: getNextAccount(),
      poolAuthority: getNextAccount(),
      pool: getNextAccount(),
      position: getNextAccount(),
      tokenAMint: getNextAccount(),
      tokenBMint: getNextAccount(),
      tokenAVault: getNextAccount(),
      tokenBVault: getNextAccount(),
      payerTokenA: getNextAccount(),
      payerTokenB: getNextAccount(),
      tokenAProgram: getNextAccount(),
      tokenBProgram: getNextAccount(),
      token2022Program: getNextAccount(),
      systemProgram: getNextAccount(),
      eventAuthority: getNextAccount(),
      program: getNextAccount(),
    },
    data: getInitializePoolWithDynamicConfigInstructionDataDecoder().decode(
      instruction.data,
    ),
  };
}
