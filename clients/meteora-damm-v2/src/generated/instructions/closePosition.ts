/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  AccountMeta,
  AccountSignerMeta,
  Address,
  FixedSizeCodec,
  FixedSizeDecoder,
  FixedSizeEncoder,
  Instruction,
  InstructionWithAccounts,
  InstructionWithData,
  ReadonlyAccount,
  ReadonlySignerAccount,
  ReadonlyUint8Array,
  TransactionSigner,
  WritableAccount,
} from "@solana/kit";
import type { ResolvedAccount } from "../shared/index.js";
import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
} from "@solana/kit";
import {
  findEventAuthorityPda,
  findPoolAuthorityPda,
  findPositionNftAccountPda,
} from "../pdas/index.js";
import { CP_AMM_PROGRAM_ADDRESS } from "../programs/index.js";
import { expectAddress, getAccountMetaFactory } from "../shared/index.js";

export const CLOSE_POSITION_DISCRIMINATOR: ReadonlyUint8Array = new Uint8Array([
  123, 134, 81, 0, 49, 68, 98, 98,
]);

export function getClosePositionDiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    CLOSE_POSITION_DISCRIMINATOR,
  );
}

export type ClosePositionInstruction<
  TProgram extends string = typeof CP_AMM_PROGRAM_ADDRESS,
  TAccountPositionNftMint extends string | AccountMeta = string,
  TAccountPositionNftAccount extends string | AccountMeta = string,
  TAccountPool extends string | AccountMeta = string,
  TAccountPosition extends string | AccountMeta = string,
  TAccountPoolAuthority extends string | AccountMeta = string,
  TAccountRentReceiver extends string | AccountMeta = string,
  TAccountOwner extends string | AccountMeta = string,
  TAccountTokenProgram extends
    | string
    | AccountMeta = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
  TAccountEventAuthority extends string | AccountMeta = string,
  TAccountProgram extends
    | string
    | AccountMeta = "cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG",
  TRemainingAccounts extends readonly AccountMeta[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountPositionNftMint extends string
        ? WritableAccount<TAccountPositionNftMint>
        : TAccountPositionNftMint,
      TAccountPositionNftAccount extends string
        ? WritableAccount<TAccountPositionNftAccount>
        : TAccountPositionNftAccount,
      TAccountPool extends string
        ? WritableAccount<TAccountPool>
        : TAccountPool,
      TAccountPosition extends string
        ? WritableAccount<TAccountPosition>
        : TAccountPosition,
      TAccountPoolAuthority extends string
        ? ReadonlyAccount<TAccountPoolAuthority>
        : TAccountPoolAuthority,
      TAccountRentReceiver extends string
        ? WritableAccount<TAccountRentReceiver>
        : TAccountRentReceiver,
      TAccountOwner extends string
        ? ReadonlySignerAccount<TAccountOwner> &
            AccountSignerMeta<TAccountOwner>
        : TAccountOwner,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountEventAuthority extends string
        ? ReadonlyAccount<TAccountEventAuthority>
        : TAccountEventAuthority,
      TAccountProgram extends string
        ? ReadonlyAccount<TAccountProgram>
        : TAccountProgram,
      ...TRemainingAccounts,
    ]
  >;

export interface ClosePositionInstructionData {
  discriminator: ReadonlyUint8Array;
}

export interface ClosePositionInstructionDataArgs {}

export function getClosePositionInstructionDataEncoder(): FixedSizeEncoder<ClosePositionInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]),
    (value) => ({ ...value, discriminator: CLOSE_POSITION_DISCRIMINATOR }),
  );
}

export function getClosePositionInstructionDataDecoder(): FixedSizeDecoder<ClosePositionInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
  ]);
}

export function getClosePositionInstructionDataCodec(): FixedSizeCodec<
  ClosePositionInstructionDataArgs,
  ClosePositionInstructionData
> {
  return combineCodec(
    getClosePositionInstructionDataEncoder(),
    getClosePositionInstructionDataDecoder(),
  );
}

export interface ClosePositionAsyncInput<
  TAccountPositionNftMint extends string = string,
  TAccountPositionNftAccount extends string = string,
  TAccountPool extends string = string,
  TAccountPosition extends string = string,
  TAccountPoolAuthority extends string = string,
  TAccountRentReceiver extends string = string,
  TAccountOwner extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> {
  /** position_nft_mint */
  positionNftMint: Address<TAccountPositionNftMint>;
  /** The token account for nft */
  positionNftAccount?: Address<TAccountPositionNftAccount>;
  pool: Address<TAccountPool>;
  position: Address<TAccountPosition>;
  poolAuthority?: Address<TAccountPoolAuthority>;
  rentReceiver: Address<TAccountRentReceiver>;
  /** Owner of position */
  owner: TransactionSigner<TAccountOwner>;
  /** Program to create NFT mint/token account and transfer for token22 account */
  tokenProgram?: Address<TAccountTokenProgram>;
  eventAuthority?: Address<TAccountEventAuthority>;
  program?: Address<TAccountProgram>;
}

export async function getClosePositionInstructionAsync<
  TAccountPositionNftMint extends string,
  TAccountPositionNftAccount extends string,
  TAccountPool extends string,
  TAccountPosition extends string,
  TAccountPoolAuthority extends string,
  TAccountRentReceiver extends string,
  TAccountOwner extends string,
  TAccountTokenProgram extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof CP_AMM_PROGRAM_ADDRESS,
>(
  input: ClosePositionAsyncInput<
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountRentReceiver,
    TAccountOwner,
    TAccountTokenProgram,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress },
): Promise<
  ClosePositionInstruction<
    TProgramAddress,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountRentReceiver,
    TAccountOwner,
    TAccountTokenProgram,
    TAccountEventAuthority,
    TAccountProgram
  >
> {
  // Program address.
  const programAddress = config?.programAddress ?? CP_AMM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true,
    },
    pool: { value: input.pool ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    poolAuthority: { value: input.poolAuthority ?? null, isWritable: false },
    rentReceiver: { value: input.rentReceiver ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.positionNftAccount.value) {
    accounts.positionNftAccount.value = await findPositionNftAccountPda({
      positionNftMint: expectAddress(accounts.positionNftMint.value),
    });
  }
  if (!accounts.poolAuthority.value) {
    accounts.poolAuthority.value = await findPoolAuthorityPda();
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb" as Address<"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb">;
  }
  if (!accounts.eventAuthority.value) {
    accounts.eventAuthority.value = await findEventAuthorityPda();
  }
  if (!accounts.program.value) {
    accounts.program.value =
      "cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG" as Address<"cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.poolAuthority),
      getAccountMeta(accounts.rentReceiver),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    data: getClosePositionInstructionDataEncoder().encode({}),
    programAddress,
  } as ClosePositionInstruction<
    TProgramAddress,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountRentReceiver,
    TAccountOwner,
    TAccountTokenProgram,
    TAccountEventAuthority,
    TAccountProgram
  >);
}

export interface ClosePositionInput<
  TAccountPositionNftMint extends string = string,
  TAccountPositionNftAccount extends string = string,
  TAccountPool extends string = string,
  TAccountPosition extends string = string,
  TAccountPoolAuthority extends string = string,
  TAccountRentReceiver extends string = string,
  TAccountOwner extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> {
  /** position_nft_mint */
  positionNftMint: Address<TAccountPositionNftMint>;
  /** The token account for nft */
  positionNftAccount: Address<TAccountPositionNftAccount>;
  pool: Address<TAccountPool>;
  position: Address<TAccountPosition>;
  poolAuthority: Address<TAccountPoolAuthority>;
  rentReceiver: Address<TAccountRentReceiver>;
  /** Owner of position */
  owner: TransactionSigner<TAccountOwner>;
  /** Program to create NFT mint/token account and transfer for token22 account */
  tokenProgram?: Address<TAccountTokenProgram>;
  eventAuthority: Address<TAccountEventAuthority>;
  program?: Address<TAccountProgram>;
}

export function getClosePositionInstruction<
  TAccountPositionNftMint extends string,
  TAccountPositionNftAccount extends string,
  TAccountPool extends string,
  TAccountPosition extends string,
  TAccountPoolAuthority extends string,
  TAccountRentReceiver extends string,
  TAccountOwner extends string,
  TAccountTokenProgram extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof CP_AMM_PROGRAM_ADDRESS,
>(
  input: ClosePositionInput<
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountRentReceiver,
    TAccountOwner,
    TAccountTokenProgram,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress },
): ClosePositionInstruction<
  TProgramAddress,
  TAccountPositionNftMint,
  TAccountPositionNftAccount,
  TAccountPool,
  TAccountPosition,
  TAccountPoolAuthority,
  TAccountRentReceiver,
  TAccountOwner,
  TAccountTokenProgram,
  TAccountEventAuthority,
  TAccountProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? CP_AMM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true,
    },
    pool: { value: input.pool ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    poolAuthority: { value: input.poolAuthority ?? null, isWritable: false },
    rentReceiver: { value: input.rentReceiver ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb" as Address<"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb">;
  }
  if (!accounts.program.value) {
    accounts.program.value =
      "cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG" as Address<"cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.poolAuthority),
      getAccountMeta(accounts.rentReceiver),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    data: getClosePositionInstructionDataEncoder().encode({}),
    programAddress,
  } as ClosePositionInstruction<
    TProgramAddress,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountRentReceiver,
    TAccountOwner,
    TAccountTokenProgram,
    TAccountEventAuthority,
    TAccountProgram
  >);
}

export interface ParsedClosePositionInstruction<
  TProgram extends string = typeof CP_AMM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> {
  programAddress: Address<TProgram>;
  accounts: {
    /** position_nft_mint */
    positionNftMint: TAccountMetas[0];
    /** The token account for nft */
    positionNftAccount: TAccountMetas[1];
    pool: TAccountMetas[2];
    position: TAccountMetas[3];
    poolAuthority: TAccountMetas[4];
    rentReceiver: TAccountMetas[5];
    /** Owner of position */
    owner: TAccountMetas[6];
    /** Program to create NFT mint/token account and transfer for token22 account */
    tokenProgram: TAccountMetas[7];
    eventAuthority: TAccountMetas[8];
    program: TAccountMetas[9];
  };
  data: ClosePositionInstructionData;
}

export function parseClosePositionInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedClosePositionInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 10) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionNftMint: getNextAccount(),
      positionNftAccount: getNextAccount(),
      pool: getNextAccount(),
      position: getNextAccount(),
      poolAuthority: getNextAccount(),
      rentReceiver: getNextAccount(),
      owner: getNextAccount(),
      tokenProgram: getNextAccount(),
      eventAuthority: getNextAccount(),
      program: getNextAccount(),
    },
    data: getClosePositionInstructionDataDecoder().decode(instruction.data),
  };
}
