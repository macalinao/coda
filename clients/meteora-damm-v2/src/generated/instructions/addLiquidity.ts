/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  AccountMeta,
  AccountSignerMeta,
  Address,
  FixedSizeCodec,
  FixedSizeDecoder,
  FixedSizeEncoder,
  Instruction,
  InstructionWithAccounts,
  InstructionWithData,
  ReadonlyAccount,
  ReadonlySignerAccount,
  ReadonlyUint8Array,
  TransactionSigner,
  WritableAccount,
} from "@solana/kit";
import type { ResolvedAccount } from "../shared/index.js";
import type {
  AddLiquidityParameters,
  AddLiquidityParametersArgs,
} from "../types/index.js";
import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
} from "@solana/kit";
import { CP_AMM_PROGRAM_ADDRESS } from "../programs/index.js";
import { getAccountMetaFactory } from "../shared/index.js";
import {
  getAddLiquidityParametersDecoder,
  getAddLiquidityParametersEncoder,
} from "../types/index.js";

export const ADD_LIQUIDITY_DISCRIMINATOR: ReadonlyUint8Array = new Uint8Array([
  181, 157, 89, 67, 143, 182, 52, 72,
]);

export function getAddLiquidityDiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    ADD_LIQUIDITY_DISCRIMINATOR,
  );
}

export type AddLiquidityInstruction<
  TProgram extends string = typeof CP_AMM_PROGRAM_ADDRESS,
  TAccountPool extends string | AccountMeta = string,
  TAccountPosition extends string | AccountMeta = string,
  TAccountTokenAAccount extends string | AccountMeta = string,
  TAccountTokenBAccount extends string | AccountMeta = string,
  TAccountTokenAVault extends string | AccountMeta = string,
  TAccountTokenBVault extends string | AccountMeta = string,
  TAccountTokenAMint extends string | AccountMeta = string,
  TAccountTokenBMint extends string | AccountMeta = string,
  TAccountPositionNftAccount extends string | AccountMeta = string,
  TAccountOwner extends string | AccountMeta = string,
  TAccountTokenAProgram extends string | AccountMeta = string,
  TAccountTokenBProgram extends string | AccountMeta = string,
  TAccountEventAuthority extends string | AccountMeta = string,
  TAccountProgram extends string | AccountMeta = string,
  TRemainingAccounts extends readonly AccountMeta[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountPool extends string
        ? WritableAccount<TAccountPool>
        : TAccountPool,
      TAccountPosition extends string
        ? WritableAccount<TAccountPosition>
        : TAccountPosition,
      TAccountTokenAAccount extends string
        ? WritableAccount<TAccountTokenAAccount>
        : TAccountTokenAAccount,
      TAccountTokenBAccount extends string
        ? WritableAccount<TAccountTokenBAccount>
        : TAccountTokenBAccount,
      TAccountTokenAVault extends string
        ? WritableAccount<TAccountTokenAVault>
        : TAccountTokenAVault,
      TAccountTokenBVault extends string
        ? WritableAccount<TAccountTokenBVault>
        : TAccountTokenBVault,
      TAccountTokenAMint extends string
        ? ReadonlyAccount<TAccountTokenAMint>
        : TAccountTokenAMint,
      TAccountTokenBMint extends string
        ? ReadonlyAccount<TAccountTokenBMint>
        : TAccountTokenBMint,
      TAccountPositionNftAccount extends string
        ? ReadonlyAccount<TAccountPositionNftAccount>
        : TAccountPositionNftAccount,
      TAccountOwner extends string
        ? ReadonlySignerAccount<TAccountOwner> &
            AccountSignerMeta<TAccountOwner>
        : TAccountOwner,
      TAccountTokenAProgram extends string
        ? ReadonlyAccount<TAccountTokenAProgram>
        : TAccountTokenAProgram,
      TAccountTokenBProgram extends string
        ? ReadonlyAccount<TAccountTokenBProgram>
        : TAccountTokenBProgram,
      TAccountEventAuthority extends string
        ? ReadonlyAccount<TAccountEventAuthority>
        : TAccountEventAuthority,
      TAccountProgram extends string
        ? ReadonlyAccount<TAccountProgram>
        : TAccountProgram,
      ...TRemainingAccounts,
    ]
  >;

export interface AddLiquidityInstructionData {
  discriminator: ReadonlyUint8Array;
  params: AddLiquidityParameters;
}

export interface AddLiquidityInstructionDataArgs {
  params: AddLiquidityParametersArgs;
}

export function getAddLiquidityInstructionDataEncoder(): FixedSizeEncoder<AddLiquidityInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["params", getAddLiquidityParametersEncoder()],
    ]),
    (value) => ({ ...value, discriminator: ADD_LIQUIDITY_DISCRIMINATOR }),
  );
}

export function getAddLiquidityInstructionDataDecoder(): FixedSizeDecoder<AddLiquidityInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["params", getAddLiquidityParametersDecoder()],
  ]);
}

export function getAddLiquidityInstructionDataCodec(): FixedSizeCodec<
  AddLiquidityInstructionDataArgs,
  AddLiquidityInstructionData
> {
  return combineCodec(
    getAddLiquidityInstructionDataEncoder(),
    getAddLiquidityInstructionDataDecoder(),
  );
}

export interface AddLiquidityAsyncInput<
  TAccountPool extends string = string,
  TAccountPosition extends string = string,
  TAccountTokenAAccount extends string = string,
  TAccountTokenBAccount extends string = string,
  TAccountTokenAVault extends string = string,
  TAccountTokenBVault extends string = string,
  TAccountTokenAMint extends string = string,
  TAccountTokenBMint extends string = string,
  TAccountPositionNftAccount extends string = string,
  TAccountOwner extends string = string,
  TAccountTokenAProgram extends string = string,
  TAccountTokenBProgram extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> {
  pool: Address<TAccountPool>;
  position: Address<TAccountPosition>;
  /** The user token a account */
  tokenAAccount: Address<TAccountTokenAAccount>;
  /** The user token b account */
  tokenBAccount: Address<TAccountTokenBAccount>;
  /** The vault token account for input token */
  tokenAVault: Address<TAccountTokenAVault>;
  /** The vault token account for output token */
  tokenBVault: Address<TAccountTokenBVault>;
  /** The mint of token a */
  tokenAMint: Address<TAccountTokenAMint>;
  /** The mint of token b */
  tokenBMint: Address<TAccountTokenBMint>;
  /** The token account for nft */
  positionNftAccount: Address<TAccountPositionNftAccount>;
  /** owner of position */
  owner: TransactionSigner<TAccountOwner>;
  /** Token a program */
  tokenAProgram: Address<TAccountTokenAProgram>;
  /** Token b program */
  tokenBProgram: Address<TAccountTokenBProgram>;
  eventAuthority?: Address<TAccountEventAuthority>;
  program: Address<TAccountProgram>;
  params: AddLiquidityInstructionDataArgs["params"];
}

export async function getAddLiquidityInstructionAsync<
  TAccountPool extends string,
  TAccountPosition extends string,
  TAccountTokenAAccount extends string,
  TAccountTokenBAccount extends string,
  TAccountTokenAVault extends string,
  TAccountTokenBVault extends string,
  TAccountTokenAMint extends string,
  TAccountTokenBMint extends string,
  TAccountPositionNftAccount extends string,
  TAccountOwner extends string,
  TAccountTokenAProgram extends string,
  TAccountTokenBProgram extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof CP_AMM_PROGRAM_ADDRESS,
>(
  input: AddLiquidityAsyncInput<
    TAccountPool,
    TAccountPosition,
    TAccountTokenAAccount,
    TAccountTokenBAccount,
    TAccountTokenAVault,
    TAccountTokenBVault,
    TAccountTokenAMint,
    TAccountTokenBMint,
    TAccountPositionNftAccount,
    TAccountOwner,
    TAccountTokenAProgram,
    TAccountTokenBProgram,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress },
): Promise<
  AddLiquidityInstruction<
    TProgramAddress,
    TAccountPool,
    TAccountPosition,
    TAccountTokenAAccount,
    TAccountTokenBAccount,
    TAccountTokenAVault,
    TAccountTokenBVault,
    TAccountTokenAMint,
    TAccountTokenBMint,
    TAccountPositionNftAccount,
    TAccountOwner,
    TAccountTokenAProgram,
    TAccountTokenBProgram,
    TAccountEventAuthority,
    TAccountProgram
  >
> {
  // Program address.
  const programAddress = config?.programAddress ?? CP_AMM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    pool: { value: input.pool ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    tokenAAccount: { value: input.tokenAAccount ?? null, isWritable: true },
    tokenBAccount: { value: input.tokenBAccount ?? null, isWritable: true },
    tokenAVault: { value: input.tokenAVault ?? null, isWritable: true },
    tokenBVault: { value: input.tokenBVault ?? null, isWritable: true },
    tokenAMint: { value: input.tokenAMint ?? null, isWritable: false },
    tokenBMint: { value: input.tokenBMint ?? null, isWritable: false },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: false,
    },
    owner: { value: input.owner ?? null, isWritable: false },
    tokenAProgram: { value: input.tokenAProgram ?? null, isWritable: false },
    tokenBProgram: { value: input.tokenBProgram ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.eventAuthority.value) {
    accounts.eventAuthority.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111, 114,
            105, 116, 121,
          ]),
        ),
      ],
    });
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.tokenAAccount),
      getAccountMeta(accounts.tokenBAccount),
      getAccountMeta(accounts.tokenAVault),
      getAccountMeta(accounts.tokenBVault),
      getAccountMeta(accounts.tokenAMint),
      getAccountMeta(accounts.tokenBMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.tokenAProgram),
      getAccountMeta(accounts.tokenBProgram),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    data: getAddLiquidityInstructionDataEncoder().encode(
      args as AddLiquidityInstructionDataArgs,
    ),
    programAddress,
  } as AddLiquidityInstruction<
    TProgramAddress,
    TAccountPool,
    TAccountPosition,
    TAccountTokenAAccount,
    TAccountTokenBAccount,
    TAccountTokenAVault,
    TAccountTokenBVault,
    TAccountTokenAMint,
    TAccountTokenBMint,
    TAccountPositionNftAccount,
    TAccountOwner,
    TAccountTokenAProgram,
    TAccountTokenBProgram,
    TAccountEventAuthority,
    TAccountProgram
  >);
}

export interface AddLiquidityInput<
  TAccountPool extends string = string,
  TAccountPosition extends string = string,
  TAccountTokenAAccount extends string = string,
  TAccountTokenBAccount extends string = string,
  TAccountTokenAVault extends string = string,
  TAccountTokenBVault extends string = string,
  TAccountTokenAMint extends string = string,
  TAccountTokenBMint extends string = string,
  TAccountPositionNftAccount extends string = string,
  TAccountOwner extends string = string,
  TAccountTokenAProgram extends string = string,
  TAccountTokenBProgram extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> {
  pool: Address<TAccountPool>;
  position: Address<TAccountPosition>;
  /** The user token a account */
  tokenAAccount: Address<TAccountTokenAAccount>;
  /** The user token b account */
  tokenBAccount: Address<TAccountTokenBAccount>;
  /** The vault token account for input token */
  tokenAVault: Address<TAccountTokenAVault>;
  /** The vault token account for output token */
  tokenBVault: Address<TAccountTokenBVault>;
  /** The mint of token a */
  tokenAMint: Address<TAccountTokenAMint>;
  /** The mint of token b */
  tokenBMint: Address<TAccountTokenBMint>;
  /** The token account for nft */
  positionNftAccount: Address<TAccountPositionNftAccount>;
  /** owner of position */
  owner: TransactionSigner<TAccountOwner>;
  /** Token a program */
  tokenAProgram: Address<TAccountTokenAProgram>;
  /** Token b program */
  tokenBProgram: Address<TAccountTokenBProgram>;
  eventAuthority: Address<TAccountEventAuthority>;
  program: Address<TAccountProgram>;
  params: AddLiquidityInstructionDataArgs["params"];
}

export function getAddLiquidityInstruction<
  TAccountPool extends string,
  TAccountPosition extends string,
  TAccountTokenAAccount extends string,
  TAccountTokenBAccount extends string,
  TAccountTokenAVault extends string,
  TAccountTokenBVault extends string,
  TAccountTokenAMint extends string,
  TAccountTokenBMint extends string,
  TAccountPositionNftAccount extends string,
  TAccountOwner extends string,
  TAccountTokenAProgram extends string,
  TAccountTokenBProgram extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof CP_AMM_PROGRAM_ADDRESS,
>(
  input: AddLiquidityInput<
    TAccountPool,
    TAccountPosition,
    TAccountTokenAAccount,
    TAccountTokenBAccount,
    TAccountTokenAVault,
    TAccountTokenBVault,
    TAccountTokenAMint,
    TAccountTokenBMint,
    TAccountPositionNftAccount,
    TAccountOwner,
    TAccountTokenAProgram,
    TAccountTokenBProgram,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress },
): AddLiquidityInstruction<
  TProgramAddress,
  TAccountPool,
  TAccountPosition,
  TAccountTokenAAccount,
  TAccountTokenBAccount,
  TAccountTokenAVault,
  TAccountTokenBVault,
  TAccountTokenAMint,
  TAccountTokenBMint,
  TAccountPositionNftAccount,
  TAccountOwner,
  TAccountTokenAProgram,
  TAccountTokenBProgram,
  TAccountEventAuthority,
  TAccountProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? CP_AMM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    pool: { value: input.pool ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    tokenAAccount: { value: input.tokenAAccount ?? null, isWritable: true },
    tokenBAccount: { value: input.tokenBAccount ?? null, isWritable: true },
    tokenAVault: { value: input.tokenAVault ?? null, isWritable: true },
    tokenBVault: { value: input.tokenBVault ?? null, isWritable: true },
    tokenAMint: { value: input.tokenAMint ?? null, isWritable: false },
    tokenBMint: { value: input.tokenBMint ?? null, isWritable: false },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: false,
    },
    owner: { value: input.owner ?? null, isWritable: false },
    tokenAProgram: { value: input.tokenAProgram ?? null, isWritable: false },
    tokenBProgram: { value: input.tokenBProgram ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.tokenAAccount),
      getAccountMeta(accounts.tokenBAccount),
      getAccountMeta(accounts.tokenAVault),
      getAccountMeta(accounts.tokenBVault),
      getAccountMeta(accounts.tokenAMint),
      getAccountMeta(accounts.tokenBMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.tokenAProgram),
      getAccountMeta(accounts.tokenBProgram),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    data: getAddLiquidityInstructionDataEncoder().encode(
      args as AddLiquidityInstructionDataArgs,
    ),
    programAddress,
  } as AddLiquidityInstruction<
    TProgramAddress,
    TAccountPool,
    TAccountPosition,
    TAccountTokenAAccount,
    TAccountTokenBAccount,
    TAccountTokenAVault,
    TAccountTokenBVault,
    TAccountTokenAMint,
    TAccountTokenBMint,
    TAccountPositionNftAccount,
    TAccountOwner,
    TAccountTokenAProgram,
    TAccountTokenBProgram,
    TAccountEventAuthority,
    TAccountProgram
  >);
}

export interface ParsedAddLiquidityInstruction<
  TProgram extends string = typeof CP_AMM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> {
  programAddress: Address<TProgram>;
  accounts: {
    pool: TAccountMetas[0];
    position: TAccountMetas[1];
    /** The user token a account */
    tokenAAccount: TAccountMetas[2];
    /** The user token b account */
    tokenBAccount: TAccountMetas[3];
    /** The vault token account for input token */
    tokenAVault: TAccountMetas[4];
    /** The vault token account for output token */
    tokenBVault: TAccountMetas[5];
    /** The mint of token a */
    tokenAMint: TAccountMetas[6];
    /** The mint of token b */
    tokenBMint: TAccountMetas[7];
    /** The token account for nft */
    positionNftAccount: TAccountMetas[8];
    /** owner of position */
    owner: TAccountMetas[9];
    /** Token a program */
    tokenAProgram: TAccountMetas[10];
    /** Token b program */
    tokenBProgram: TAccountMetas[11];
    eventAuthority: TAccountMetas[12];
    program: TAccountMetas[13];
  };
  data: AddLiquidityInstructionData;
}

export function parseAddLiquidityInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedAddLiquidityInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 14) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      pool: getNextAccount(),
      position: getNextAccount(),
      tokenAAccount: getNextAccount(),
      tokenBAccount: getNextAccount(),
      tokenAVault: getNextAccount(),
      tokenBVault: getNextAccount(),
      tokenAMint: getNextAccount(),
      tokenBMint: getNextAccount(),
      positionNftAccount: getNextAccount(),
      owner: getNextAccount(),
      tokenAProgram: getNextAccount(),
      tokenBProgram: getNextAccount(),
      eventAuthority: getNextAccount(),
      program: getNextAccount(),
    },
    data: getAddLiquidityInstructionDataDecoder().decode(instruction.data),
  };
}
