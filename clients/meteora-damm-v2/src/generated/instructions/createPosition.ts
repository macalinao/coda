/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  AccountMeta,
  AccountSignerMeta,
  Address,
  FixedSizeCodec,
  FixedSizeDecoder,
  FixedSizeEncoder,
  Instruction,
  InstructionWithAccounts,
  InstructionWithData,
  ReadonlyAccount,
  ReadonlyUint8Array,
  TransactionSigner,
  WritableAccount,
  WritableSignerAccount,
} from "@solana/kit";
import type { ResolvedAccount } from "../shared/index.js";
import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
} from "@solana/kit";
import { CP_AMM_PROGRAM_ADDRESS } from "../programs/index.js";
import { expectAddress, getAccountMetaFactory } from "../shared/index.js";

export const CREATE_POSITION_DISCRIMINATOR: ReadonlyUint8Array = new Uint8Array(
  [48, 215, 197, 153, 96, 203, 180, 133],
);

export function getCreatePositionDiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    CREATE_POSITION_DISCRIMINATOR,
  );
}

export type CreatePositionInstruction<
  TProgram extends string = typeof CP_AMM_PROGRAM_ADDRESS,
  TAccountOwner extends string | AccountMeta = string,
  TAccountPositionNftMint extends string | AccountMeta = string,
  TAccountPositionNftAccount extends string | AccountMeta = string,
  TAccountPool extends string | AccountMeta = string,
  TAccountPosition extends string | AccountMeta = string,
  TAccountPoolAuthority extends
    | string
    | AccountMeta = "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC",
  TAccountPayer extends string | AccountMeta = string,
  TAccountTokenProgram extends
    | string
    | AccountMeta = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
  TAccountSystemProgram extends
    | string
    | AccountMeta = "11111111111111111111111111111111",
  TAccountEventAuthority extends string | AccountMeta = string,
  TAccountProgram extends string | AccountMeta = string,
  TRemainingAccounts extends readonly AccountMeta[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountOwner extends string
        ? ReadonlyAccount<TAccountOwner>
        : TAccountOwner,
      TAccountPositionNftMint extends string
        ? WritableSignerAccount<TAccountPositionNftMint> &
            AccountSignerMeta<TAccountPositionNftMint>
        : TAccountPositionNftMint,
      TAccountPositionNftAccount extends string
        ? WritableAccount<TAccountPositionNftAccount>
        : TAccountPositionNftAccount,
      TAccountPool extends string
        ? WritableAccount<TAccountPool>
        : TAccountPool,
      TAccountPosition extends string
        ? WritableAccount<TAccountPosition>
        : TAccountPosition,
      TAccountPoolAuthority extends string
        ? ReadonlyAccount<TAccountPoolAuthority>
        : TAccountPoolAuthority,
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountEventAuthority extends string
        ? ReadonlyAccount<TAccountEventAuthority>
        : TAccountEventAuthority,
      TAccountProgram extends string
        ? ReadonlyAccount<TAccountProgram>
        : TAccountProgram,
      ...TRemainingAccounts,
    ]
  >;

export interface CreatePositionInstructionData {
  discriminator: ReadonlyUint8Array;
}

export interface CreatePositionInstructionDataArgs {}

export function getCreatePositionInstructionDataEncoder(): FixedSizeEncoder<CreatePositionInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]),
    (value) => ({ ...value, discriminator: CREATE_POSITION_DISCRIMINATOR }),
  );
}

export function getCreatePositionInstructionDataDecoder(): FixedSizeDecoder<CreatePositionInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
  ]);
}

export function getCreatePositionInstructionDataCodec(): FixedSizeCodec<
  CreatePositionInstructionDataArgs,
  CreatePositionInstructionData
> {
  return combineCodec(
    getCreatePositionInstructionDataEncoder(),
    getCreatePositionInstructionDataDecoder(),
  );
}

export interface CreatePositionAsyncInput<
  TAccountOwner extends string = string,
  TAccountPositionNftMint extends string = string,
  TAccountPositionNftAccount extends string = string,
  TAccountPool extends string = string,
  TAccountPosition extends string = string,
  TAccountPoolAuthority extends string = string,
  TAccountPayer extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> {
  owner: Address<TAccountOwner>;
  /** position_nft_mint */
  positionNftMint: TransactionSigner<TAccountPositionNftMint>;
  /** position nft account */
  positionNftAccount?: Address<TAccountPositionNftAccount>;
  pool: Address<TAccountPool>;
  position?: Address<TAccountPosition>;
  poolAuthority?: Address<TAccountPoolAuthority>;
  /** Address paying to create the position. Can be anyone */
  payer: TransactionSigner<TAccountPayer>;
  /** Program to create NFT mint/token account and transfer for token22 account */
  tokenProgram?: Address<TAccountTokenProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
  eventAuthority?: Address<TAccountEventAuthority>;
  program: Address<TAccountProgram>;
}

export async function getCreatePositionInstructionAsync<
  TAccountOwner extends string,
  TAccountPositionNftMint extends string,
  TAccountPositionNftAccount extends string,
  TAccountPool extends string,
  TAccountPosition extends string,
  TAccountPoolAuthority extends string,
  TAccountPayer extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof CP_AMM_PROGRAM_ADDRESS,
>(
  input: CreatePositionAsyncInput<
    TAccountOwner,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountPayer,
    TAccountTokenProgram,
    TAccountSystemProgram,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress },
): Promise<
  CreatePositionInstruction<
    TProgramAddress,
    TAccountOwner,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountPayer,
    TAccountTokenProgram,
    TAccountSystemProgram,
    TAccountEventAuthority,
    TAccountProgram
  >
> {
  // Program address.
  const programAddress = config?.programAddress ?? CP_AMM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: false },
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true,
    },
    pool: { value: input.pool ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    poolAuthority: { value: input.poolAuthority ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.positionNftAccount.value) {
    accounts.positionNftAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            112, 111, 115, 105, 116, 105, 111, 110, 95, 110, 102, 116, 95, 97,
            99, 99, 111, 117, 110, 116,
          ]),
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.positionNftMint.value),
        ),
      ],
    });
  }
  if (!accounts.position.value) {
    accounts.position.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([112, 111, 115, 105, 116, 105, 111, 110]),
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.positionNftMint.value),
        ),
      ],
    });
  }
  if (!accounts.poolAuthority.value) {
    accounts.poolAuthority.value =
      "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC" as Address<"HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC">;
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb" as Address<"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb">;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }
  if (!accounts.eventAuthority.value) {
    accounts.eventAuthority.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111, 114,
            105, 116, 121,
          ]),
        ),
      ],
    });
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.poolAuthority),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    data: getCreatePositionInstructionDataEncoder().encode({}),
    programAddress,
  } as CreatePositionInstruction<
    TProgramAddress,
    TAccountOwner,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountPayer,
    TAccountTokenProgram,
    TAccountSystemProgram,
    TAccountEventAuthority,
    TAccountProgram
  >);
}

export interface CreatePositionInput<
  TAccountOwner extends string = string,
  TAccountPositionNftMint extends string = string,
  TAccountPositionNftAccount extends string = string,
  TAccountPool extends string = string,
  TAccountPosition extends string = string,
  TAccountPoolAuthority extends string = string,
  TAccountPayer extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> {
  owner: Address<TAccountOwner>;
  /** position_nft_mint */
  positionNftMint: TransactionSigner<TAccountPositionNftMint>;
  /** position nft account */
  positionNftAccount: Address<TAccountPositionNftAccount>;
  pool: Address<TAccountPool>;
  position: Address<TAccountPosition>;
  poolAuthority?: Address<TAccountPoolAuthority>;
  /** Address paying to create the position. Can be anyone */
  payer: TransactionSigner<TAccountPayer>;
  /** Program to create NFT mint/token account and transfer for token22 account */
  tokenProgram?: Address<TAccountTokenProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
  eventAuthority: Address<TAccountEventAuthority>;
  program: Address<TAccountProgram>;
}

export function getCreatePositionInstruction<
  TAccountOwner extends string,
  TAccountPositionNftMint extends string,
  TAccountPositionNftAccount extends string,
  TAccountPool extends string,
  TAccountPosition extends string,
  TAccountPoolAuthority extends string,
  TAccountPayer extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof CP_AMM_PROGRAM_ADDRESS,
>(
  input: CreatePositionInput<
    TAccountOwner,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountPayer,
    TAccountTokenProgram,
    TAccountSystemProgram,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress },
): CreatePositionInstruction<
  TProgramAddress,
  TAccountOwner,
  TAccountPositionNftMint,
  TAccountPositionNftAccount,
  TAccountPool,
  TAccountPosition,
  TAccountPoolAuthority,
  TAccountPayer,
  TAccountTokenProgram,
  TAccountSystemProgram,
  TAccountEventAuthority,
  TAccountProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? CP_AMM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: false },
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true,
    },
    pool: { value: input.pool ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    poolAuthority: { value: input.poolAuthority ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.poolAuthority.value) {
    accounts.poolAuthority.value =
      "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC" as Address<"HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC">;
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb" as Address<"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb">;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.poolAuthority),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    data: getCreatePositionInstructionDataEncoder().encode({}),
    programAddress,
  } as CreatePositionInstruction<
    TProgramAddress,
    TAccountOwner,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountPayer,
    TAccountTokenProgram,
    TAccountSystemProgram,
    TAccountEventAuthority,
    TAccountProgram
  >);
}

export interface ParsedCreatePositionInstruction<
  TProgram extends string = typeof CP_AMM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> {
  programAddress: Address<TProgram>;
  accounts: {
    owner: TAccountMetas[0];
    /** position_nft_mint */
    positionNftMint: TAccountMetas[1];
    /** position nft account */
    positionNftAccount: TAccountMetas[2];
    pool: TAccountMetas[3];
    position: TAccountMetas[4];
    poolAuthority: TAccountMetas[5];
    /** Address paying to create the position. Can be anyone */
    payer: TAccountMetas[6];
    /** Program to create NFT mint/token account and transfer for token22 account */
    tokenProgram: TAccountMetas[7];
    systemProgram: TAccountMetas[8];
    eventAuthority: TAccountMetas[9];
    program: TAccountMetas[10];
  };
  data: CreatePositionInstructionData;
}

export function parseCreatePositionInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedCreatePositionInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      owner: getNextAccount(),
      positionNftMint: getNextAccount(),
      positionNftAccount: getNextAccount(),
      pool: getNextAccount(),
      position: getNextAccount(),
      poolAuthority: getNextAccount(),
      payer: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      eventAuthority: getNextAccount(),
      program: getNextAccount(),
    },
    data: getCreatePositionInstructionDataDecoder().decode(instruction.data),
  };
}
