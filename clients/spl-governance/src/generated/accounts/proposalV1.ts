/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  Account,
  Address,
  Codec,
  Decoder,
  EncodedAccount,
  Encoder,
  FetchAccountConfig,
  FetchAccountsConfig,
  MaybeAccount,
  MaybeEncodedAccount,
  Option,
  OptionOrNullable,
} from "@solana/kit";
import type { ProposalSeeds } from "../pdas/index.js";
import type {
  InstructionExecutionFlags,
  InstructionExecutionFlagsArgs,
  ProposalState,
  ProposalStateArgs,
  Slot,
  SlotArgs,
  UnixTimestamp,
  UnixTimestampArgs,
  VoteThreshold,
  VoteThresholdArgs,
} from "../types/index.js";
import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  getAddressDecoder,
  getAddressEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  getU16Decoder,
  getU16Encoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  transformEncoder,
} from "@solana/kit";
import { findProposalPda } from "../pdas/index.js";
import {
  GovernanceAccountType,
  getGovernanceAccountTypeDecoder,
  getGovernanceAccountTypeEncoder,
  getInstructionExecutionFlagsDecoder,
  getInstructionExecutionFlagsEncoder,
  getProposalStateDecoder,
  getProposalStateEncoder,
  getSlotDecoder,
  getSlotEncoder,
  getUnixTimestampDecoder,
  getUnixTimestampEncoder,
  getVoteThresholdDecoder,
  getVoteThresholdEncoder,
} from "../types/index.js";

export const PROPOSAL_V1_ACCOUNT_TYPE = GovernanceAccountType.ProposalV1;

export function getProposalV1AccountTypeBytes() {
  return getGovernanceAccountTypeEncoder().encode(PROPOSAL_V1_ACCOUNT_TYPE);
}

export interface ProposalV1 {
  accountType: GovernanceAccountType;
  governance: Address;
  governingTokenMint: Address;
  state: ProposalState;
  tokenOwnerRecord: Address;
  signatoriesCount: number;
  signatoriesSignedOffCount: number;
  yesVotesCount: bigint;
  noVotesCount: bigint;
  instructionsExecutedCount: number;
  instructionsCount: number;
  instructionsNextIndex: number;
  draftAt: UnixTimestamp;
  signingOffAt: Option<UnixTimestamp>;
  votingAt: Option<UnixTimestamp>;
  votingAtSlot: Option<Slot>;
  votingCompletedAt: Option<UnixTimestamp>;
  executingAt: Option<UnixTimestamp>;
  closedAt: Option<UnixTimestamp>;
  executionFlags: InstructionExecutionFlags;
  maxVoteWeight: Option<bigint>;
  voteThreshold: Option<VoteThreshold>;
  name: string;
  descriptionLink: string;
}

export interface ProposalV1Args {
  governance: Address;
  governingTokenMint: Address;
  state: ProposalStateArgs;
  tokenOwnerRecord: Address;
  signatoriesCount: number;
  signatoriesSignedOffCount: number;
  yesVotesCount: number | bigint;
  noVotesCount: number | bigint;
  instructionsExecutedCount: number;
  instructionsCount: number;
  instructionsNextIndex: number;
  draftAt: UnixTimestampArgs;
  signingOffAt: OptionOrNullable<UnixTimestampArgs>;
  votingAt: OptionOrNullable<UnixTimestampArgs>;
  votingAtSlot: OptionOrNullable<SlotArgs>;
  votingCompletedAt: OptionOrNullable<UnixTimestampArgs>;
  executingAt: OptionOrNullable<UnixTimestampArgs>;
  closedAt: OptionOrNullable<UnixTimestampArgs>;
  executionFlags: InstructionExecutionFlagsArgs;
  maxVoteWeight: OptionOrNullable<number | bigint>;
  voteThreshold: OptionOrNullable<VoteThresholdArgs>;
  name: string;
  descriptionLink: string;
}

export function getProposalV1Encoder(): Encoder<ProposalV1Args> {
  return transformEncoder(
    getStructEncoder([
      ["accountType", getGovernanceAccountTypeEncoder()],
      ["governance", getAddressEncoder()],
      ["governingTokenMint", getAddressEncoder()],
      ["state", getProposalStateEncoder()],
      ["tokenOwnerRecord", getAddressEncoder()],
      ["signatoriesCount", getU8Encoder()],
      ["signatoriesSignedOffCount", getU8Encoder()],
      ["yesVotesCount", getU64Encoder()],
      ["noVotesCount", getU64Encoder()],
      ["instructionsExecutedCount", getU16Encoder()],
      ["instructionsCount", getU16Encoder()],
      ["instructionsNextIndex", getU16Encoder()],
      ["draftAt", getUnixTimestampEncoder()],
      ["signingOffAt", getOptionEncoder(getUnixTimestampEncoder())],
      ["votingAt", getOptionEncoder(getUnixTimestampEncoder())],
      ["votingAtSlot", getOptionEncoder(getSlotEncoder())],
      ["votingCompletedAt", getOptionEncoder(getUnixTimestampEncoder())],
      ["executingAt", getOptionEncoder(getUnixTimestampEncoder())],
      ["closedAt", getOptionEncoder(getUnixTimestampEncoder())],
      ["executionFlags", getInstructionExecutionFlagsEncoder()],
      ["maxVoteWeight", getOptionEncoder(getU64Encoder())],
      ["voteThreshold", getOptionEncoder(getVoteThresholdEncoder())],
      ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
      [
        "descriptionLink",
        addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),
      ],
    ]),
    (value) => ({ ...value, accountType: PROPOSAL_V1_ACCOUNT_TYPE }),
  );
}

export function getProposalV1Decoder(): Decoder<ProposalV1> {
  return getStructDecoder([
    ["accountType", getGovernanceAccountTypeDecoder()],
    ["governance", getAddressDecoder()],
    ["governingTokenMint", getAddressDecoder()],
    ["state", getProposalStateDecoder()],
    ["tokenOwnerRecord", getAddressDecoder()],
    ["signatoriesCount", getU8Decoder()],
    ["signatoriesSignedOffCount", getU8Decoder()],
    ["yesVotesCount", getU64Decoder()],
    ["noVotesCount", getU64Decoder()],
    ["instructionsExecutedCount", getU16Decoder()],
    ["instructionsCount", getU16Decoder()],
    ["instructionsNextIndex", getU16Decoder()],
    ["draftAt", getUnixTimestampDecoder()],
    ["signingOffAt", getOptionDecoder(getUnixTimestampDecoder())],
    ["votingAt", getOptionDecoder(getUnixTimestampDecoder())],
    ["votingAtSlot", getOptionDecoder(getSlotDecoder())],
    ["votingCompletedAt", getOptionDecoder(getUnixTimestampDecoder())],
    ["executingAt", getOptionDecoder(getUnixTimestampDecoder())],
    ["closedAt", getOptionDecoder(getUnixTimestampDecoder())],
    ["executionFlags", getInstructionExecutionFlagsDecoder()],
    ["maxVoteWeight", getOptionDecoder(getU64Decoder())],
    ["voteThreshold", getOptionDecoder(getVoteThresholdDecoder())],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "descriptionLink",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),
    ],
  ]);
}

export function getProposalV1Codec(): Codec<ProposalV1Args, ProposalV1> {
  return combineCodec(getProposalV1Encoder(), getProposalV1Decoder());
}

export function decodeProposalV1<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<ProposalV1, TAddress>;
export function decodeProposalV1<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<ProposalV1, TAddress>;
export function decodeProposalV1<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<ProposalV1, TAddress> | MaybeAccount<ProposalV1, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getProposalV1Decoder(),
  );
}

export async function fetchProposalV1<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<ProposalV1, TAddress>> {
  const maybeAccount = await fetchMaybeProposalV1(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeProposalV1<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<ProposalV1, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeProposalV1(maybeAccount);
}

export async function fetchAllProposalV1(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<Account<ProposalV1>[]> {
  const maybeAccounts = await fetchAllMaybeProposalV1(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeProposalV1(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<ProposalV1>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeProposalV1(maybeAccount));
}

export async function fetchProposalV1FromSeeds(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  seeds: ProposalSeeds,
  config: FetchAccountConfig & { programAddress?: Address } = {},
): Promise<Account<ProposalV1>> {
  const maybeAccount = await fetchMaybeProposalV1FromSeeds(rpc, seeds, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeProposalV1FromSeeds(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  seeds: ProposalSeeds,
  config: FetchAccountConfig & { programAddress?: Address } = {},
): Promise<MaybeAccount<ProposalV1>> {
  const { programAddress, ...fetchConfig } = config;
  const [address] = await findProposalPda(seeds, { programAddress });
  return await fetchMaybeProposalV1(rpc, address, fetchConfig);
}
