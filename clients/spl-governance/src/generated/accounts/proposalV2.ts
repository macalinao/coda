/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  Account,
  Address,
  Codec,
  Decoder,
  EncodedAccount,
  Encoder,
  FetchAccountConfig,
  FetchAccountsConfig,
  MaybeAccount,
  MaybeEncodedAccount,
  Option,
  OptionOrNullable,
  ReadonlyUint8Array,
} from "@solana/kit";
import type { ProposalSeeds } from "../pdas/index.js";
import type {
  GovernanceAccountType,
  GovernanceAccountTypeArgs,
  InstructionExecutionFlags,
  InstructionExecutionFlagsArgs,
  ProposalOption,
  ProposalOptionArgs,
  ProposalState,
  ProposalStateArgs,
  Slot,
  SlotArgs,
  UnixTimestamp,
  UnixTimestampArgs,
  VoteThreshold,
  VoteThresholdArgs,
  VoteType,
  VoteTypeArgs,
} from "../types/index.js";
import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  transformEncoder,
} from "@solana/kit";
import { findProposalPda } from "../pdas/index.js";
import {
  getGovernanceAccountTypeDecoder,
  getGovernanceAccountTypeEncoder,
  getInstructionExecutionFlagsDecoder,
  getInstructionExecutionFlagsEncoder,
  getProposalOptionDecoder,
  getProposalOptionEncoder,
  getProposalStateDecoder,
  getProposalStateEncoder,
  getSlotDecoder,
  getSlotEncoder,
  getUnixTimestampDecoder,
  getUnixTimestampEncoder,
  getVoteThresholdDecoder,
  getVoteThresholdEncoder,
  getVoteTypeDecoder,
  getVoteTypeEncoder,
} from "../types/index.js";

export const PROPOSAL_V2_DISCRIMINATOR: ReadonlyUint8Array = new Uint8Array([
  30, 68, 195, 218, 88, 123, 211, 172,
]);

export function getProposalV2DiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(PROPOSAL_V2_DISCRIMINATOR);
}

export interface ProposalV2 {
  discriminator: ReadonlyUint8Array;
  accountType: GovernanceAccountType;
  governance: Address;
  governingTokenMint: Address;
  state: ProposalState;
  tokenOwnerRecord: Address;
  signatoriesCount: number;
  signatoriesSignedOffCount: number;
  voteType: VoteType;
  options: ProposalOption[];
  denyVoteWeight: Option<bigint>;
  reserved1: number;
  abstainVoteWeight: Option<bigint>;
  startVotingAt: Option<UnixTimestamp>;
  draftAt: UnixTimestamp;
  signingOffAt: Option<UnixTimestamp>;
  votingAt: Option<UnixTimestamp>;
  votingAtSlot: Option<Slot>;
  votingCompletedAt: Option<UnixTimestamp>;
  executingAt: Option<UnixTimestamp>;
  closedAt: Option<UnixTimestamp>;
  executionFlags: InstructionExecutionFlags;
  maxVoteWeight: Option<bigint>;
  maxVotingTime: Option<number>;
  voteThreshold: Option<VoteThreshold>;
  reserved: number[];
  name: string;
  descriptionLink: string;
  vetoVoteWeight: bigint;
}

export interface ProposalV2Args {
  accountType: GovernanceAccountTypeArgs;
  governance: Address;
  governingTokenMint: Address;
  state: ProposalStateArgs;
  tokenOwnerRecord: Address;
  signatoriesCount: number;
  signatoriesSignedOffCount: number;
  voteType: VoteTypeArgs;
  options: ProposalOptionArgs[];
  denyVoteWeight: OptionOrNullable<number | bigint>;
  reserved1: number;
  abstainVoteWeight: OptionOrNullable<number | bigint>;
  startVotingAt: OptionOrNullable<UnixTimestampArgs>;
  draftAt: UnixTimestampArgs;
  signingOffAt: OptionOrNullable<UnixTimestampArgs>;
  votingAt: OptionOrNullable<UnixTimestampArgs>;
  votingAtSlot: OptionOrNullable<SlotArgs>;
  votingCompletedAt: OptionOrNullable<UnixTimestampArgs>;
  executingAt: OptionOrNullable<UnixTimestampArgs>;
  closedAt: OptionOrNullable<UnixTimestampArgs>;
  executionFlags: InstructionExecutionFlagsArgs;
  maxVoteWeight: OptionOrNullable<number | bigint>;
  maxVotingTime: OptionOrNullable<number>;
  voteThreshold: OptionOrNullable<VoteThresholdArgs>;
  reserved: number[];
  name: string;
  descriptionLink: string;
  vetoVoteWeight: number | bigint;
}

export function getProposalV2Encoder(): Encoder<ProposalV2Args> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["accountType", getGovernanceAccountTypeEncoder()],
      ["governance", getAddressEncoder()],
      ["governingTokenMint", getAddressEncoder()],
      ["state", getProposalStateEncoder()],
      ["tokenOwnerRecord", getAddressEncoder()],
      ["signatoriesCount", getU8Encoder()],
      ["signatoriesSignedOffCount", getU8Encoder()],
      ["voteType", getVoteTypeEncoder()],
      ["options", getArrayEncoder(getProposalOptionEncoder())],
      ["denyVoteWeight", getOptionEncoder(getU64Encoder())],
      ["reserved1", getU8Encoder()],
      ["abstainVoteWeight", getOptionEncoder(getU64Encoder())],
      ["startVotingAt", getOptionEncoder(getUnixTimestampEncoder())],
      ["draftAt", getUnixTimestampEncoder()],
      ["signingOffAt", getOptionEncoder(getUnixTimestampEncoder())],
      ["votingAt", getOptionEncoder(getUnixTimestampEncoder())],
      ["votingAtSlot", getOptionEncoder(getSlotEncoder())],
      ["votingCompletedAt", getOptionEncoder(getUnixTimestampEncoder())],
      ["executingAt", getOptionEncoder(getUnixTimestampEncoder())],
      ["closedAt", getOptionEncoder(getUnixTimestampEncoder())],
      ["executionFlags", getInstructionExecutionFlagsEncoder()],
      ["maxVoteWeight", getOptionEncoder(getU64Encoder())],
      ["maxVotingTime", getOptionEncoder(getU32Encoder())],
      ["voteThreshold", getOptionEncoder(getVoteThresholdEncoder())],
      ["reserved", getArrayEncoder(getU8Encoder(), { size: 64 })],
      ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
      [
        "descriptionLink",
        addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),
      ],
      ["vetoVoteWeight", getU64Encoder()],
    ]),
    (value) => ({ ...value, discriminator: PROPOSAL_V2_DISCRIMINATOR }),
  );
}

export function getProposalV2Decoder(): Decoder<ProposalV2> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["accountType", getGovernanceAccountTypeDecoder()],
    ["governance", getAddressDecoder()],
    ["governingTokenMint", getAddressDecoder()],
    ["state", getProposalStateDecoder()],
    ["tokenOwnerRecord", getAddressDecoder()],
    ["signatoriesCount", getU8Decoder()],
    ["signatoriesSignedOffCount", getU8Decoder()],
    ["voteType", getVoteTypeDecoder()],
    ["options", getArrayDecoder(getProposalOptionDecoder())],
    ["denyVoteWeight", getOptionDecoder(getU64Decoder())],
    ["reserved1", getU8Decoder()],
    ["abstainVoteWeight", getOptionDecoder(getU64Decoder())],
    ["startVotingAt", getOptionDecoder(getUnixTimestampDecoder())],
    ["draftAt", getUnixTimestampDecoder()],
    ["signingOffAt", getOptionDecoder(getUnixTimestampDecoder())],
    ["votingAt", getOptionDecoder(getUnixTimestampDecoder())],
    ["votingAtSlot", getOptionDecoder(getSlotDecoder())],
    ["votingCompletedAt", getOptionDecoder(getUnixTimestampDecoder())],
    ["executingAt", getOptionDecoder(getUnixTimestampDecoder())],
    ["closedAt", getOptionDecoder(getUnixTimestampDecoder())],
    ["executionFlags", getInstructionExecutionFlagsDecoder()],
    ["maxVoteWeight", getOptionDecoder(getU64Decoder())],
    ["maxVotingTime", getOptionDecoder(getU32Decoder())],
    ["voteThreshold", getOptionDecoder(getVoteThresholdDecoder())],
    ["reserved", getArrayDecoder(getU8Decoder(), { size: 64 })],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "descriptionLink",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),
    ],
    ["vetoVoteWeight", getU64Decoder()],
  ]);
}

export function getProposalV2Codec(): Codec<ProposalV2Args, ProposalV2> {
  return combineCodec(getProposalV2Encoder(), getProposalV2Decoder());
}

export function decodeProposalV2<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<ProposalV2, TAddress>;
export function decodeProposalV2<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<ProposalV2, TAddress>;
export function decodeProposalV2<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<ProposalV2, TAddress> | MaybeAccount<ProposalV2, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getProposalV2Decoder(),
  );
}

export async function fetchProposalV2<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<ProposalV2, TAddress>> {
  const maybeAccount = await fetchMaybeProposalV2(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeProposalV2<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<ProposalV2, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeProposalV2(maybeAccount);
}

export async function fetchAllProposalV2(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<Account<ProposalV2>[]> {
  const maybeAccounts = await fetchAllMaybeProposalV2(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeProposalV2(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Address[],
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<ProposalV2>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeProposalV2(maybeAccount));
}

export async function fetchProposalV2FromSeeds(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  seeds: ProposalSeeds,
  config: FetchAccountConfig & { programAddress?: Address } = {},
): Promise<Account<ProposalV2>> {
  const maybeAccount = await fetchMaybeProposalV2FromSeeds(rpc, seeds, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeProposalV2FromSeeds(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  seeds: ProposalSeeds,
  config: FetchAccountConfig & { programAddress?: Address } = {},
): Promise<MaybeAccount<ProposalV2>> {
  const { programAddress, ...fetchConfig } = config;
  const [address] = await findProposalPda(seeds, { programAddress });
  return await fetchMaybeProposalV2(rpc, address, fetchConfig);
}
