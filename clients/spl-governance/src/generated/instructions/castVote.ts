/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  AccountMeta,
  AccountSignerMeta,
  Address,
  Codec,
  Decoder,
  Encoder,
  Instruction,
  InstructionWithAccounts,
  InstructionWithData,
  ReadonlyAccount,
  ReadonlySignerAccount,
  ReadonlyUint8Array,
  TransactionSigner,
  WritableAccount,
} from "@solana/kit";
import type { ResolvedAccount } from "../shared/index.js";
import type { Vote, VoteArgs } from "../types/index.js";
import {
  combineCodec,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
} from "@solana/kit";
import { SPL_GOVERNANCE_PROGRAM_ADDRESS } from "../programs/index.js";
import { getAccountMetaFactory } from "../shared/index.js";
import { getVoteDecoder, getVoteEncoder } from "../types/index.js";

export const CAST_VOTE_DISCRIMINATOR = 13;

export function getCastVoteDiscriminatorBytes(): ReadonlyUint8Array {
  return getU8Encoder().encode(CAST_VOTE_DISCRIMINATOR);
}

export type CastVoteInstruction<
  TProgram extends string = typeof SPL_GOVERNANCE_PROGRAM_ADDRESS,
  TAccountRealmAccount extends string | AccountMeta = string,
  TAccountGovernanceAccount extends string | AccountMeta = string,
  TAccountProposalAccount extends string | AccountMeta = string,
  TAccountProposalTokenOwnerRecord extends string | AccountMeta = string,
  TAccountVoterTokenOwnerRecord extends string | AccountMeta = string,
  TAccountGovernanceAuthority extends string | AccountMeta = string,
  TAccountProposalVoteRecord extends string | AccountMeta = string,
  TAccountGoverningTokenMint extends string | AccountMeta = string,
  TAccountPayer extends string | AccountMeta = string,
  TAccountSystemProgram extends
    | string
    | AccountMeta = "11111111111111111111111111111111",
  TAccountRealmConfigAccount extends string | AccountMeta = string,
  TAccountVoterWeightRecord extends string | AccountMeta = string,
  TAccountMaxVoterWeightRecord extends string | AccountMeta = string,
  TRemainingAccounts extends readonly AccountMeta[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountRealmAccount extends string
        ? ReadonlyAccount<TAccountRealmAccount>
        : TAccountRealmAccount,
      TAccountGovernanceAccount extends string
        ? WritableAccount<TAccountGovernanceAccount>
        : TAccountGovernanceAccount,
      TAccountProposalAccount extends string
        ? WritableAccount<TAccountProposalAccount>
        : TAccountProposalAccount,
      TAccountProposalTokenOwnerRecord extends string
        ? WritableAccount<TAccountProposalTokenOwnerRecord>
        : TAccountProposalTokenOwnerRecord,
      TAccountVoterTokenOwnerRecord extends string
        ? WritableAccount<TAccountVoterTokenOwnerRecord>
        : TAccountVoterTokenOwnerRecord,
      TAccountGovernanceAuthority extends string
        ? ReadonlySignerAccount<TAccountGovernanceAuthority> &
            AccountSignerMeta<TAccountGovernanceAuthority>
        : TAccountGovernanceAuthority,
      TAccountProposalVoteRecord extends string
        ? WritableAccount<TAccountProposalVoteRecord>
        : TAccountProposalVoteRecord,
      TAccountGoverningTokenMint extends string
        ? ReadonlyAccount<TAccountGoverningTokenMint>
        : TAccountGoverningTokenMint,
      TAccountPayer extends string
        ? ReadonlySignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountRealmConfigAccount extends string
        ? ReadonlyAccount<TAccountRealmConfigAccount>
        : TAccountRealmConfigAccount,
      TAccountVoterWeightRecord extends string
        ? ReadonlyAccount<TAccountVoterWeightRecord>
        : TAccountVoterWeightRecord,
      TAccountMaxVoterWeightRecord extends string
        ? ReadonlyAccount<TAccountMaxVoterWeightRecord>
        : TAccountMaxVoterWeightRecord,
      ...TRemainingAccounts,
    ]
  >;

export interface CastVoteInstructionData {
  discriminator: number;
  vote: Vote;
}

export interface CastVoteInstructionDataArgs {
  vote: VoteArgs;
}

export function getCastVoteInstructionDataEncoder(): Encoder<CastVoteInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", getU8Encoder()],
      ["vote", getVoteEncoder()],
    ]),
    (value) => ({ ...value, discriminator: CAST_VOTE_DISCRIMINATOR }),
  );
}

export function getCastVoteInstructionDataDecoder(): Decoder<CastVoteInstructionData> {
  return getStructDecoder([
    ["discriminator", getU8Decoder()],
    ["vote", getVoteDecoder()],
  ]);
}

export function getCastVoteInstructionDataCodec(): Codec<
  CastVoteInstructionDataArgs,
  CastVoteInstructionData
> {
  return combineCodec(
    getCastVoteInstructionDataEncoder(),
    getCastVoteInstructionDataDecoder(),
  );
}

export interface CastVoteInput<
  TAccountRealmAccount extends string = string,
  TAccountGovernanceAccount extends string = string,
  TAccountProposalAccount extends string = string,
  TAccountProposalTokenOwnerRecord extends string = string,
  TAccountVoterTokenOwnerRecord extends string = string,
  TAccountGovernanceAuthority extends string = string,
  TAccountProposalVoteRecord extends string = string,
  TAccountGoverningTokenMint extends string = string,
  TAccountPayer extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountRealmConfigAccount extends string = string,
  TAccountVoterWeightRecord extends string = string,
  TAccountMaxVoterWeightRecord extends string = string,
> {
  realmAccount: Address<TAccountRealmAccount>;
  governanceAccount: Address<TAccountGovernanceAccount>;
  proposalAccount: Address<TAccountProposalAccount>;
  /** TokenOwnerRecord of the Proposal owner */
  proposalTokenOwnerRecord: Address<TAccountProposalTokenOwnerRecord>;
  /** TokenOwnerRecord of the voter. PDA seeds: ['governance',realm, vote_governing_token_mint, governing_token_owner] */
  voterTokenOwnerRecord: Address<TAccountVoterTokenOwnerRecord>;
  /** Governance Authority (Token Owner or Governance Delegate) */
  governanceAuthority: TransactionSigner<TAccountGovernanceAuthority>;
  /** Proposal VoteRecord account. PDA seeds: ['governance',proposal,token_owner_record] */
  proposalVoteRecord: Address<TAccountProposalVoteRecord>;
  /**
   * The Governing Token Mint which is used to cast the vote (vote_governing_token_mint).
   *     The voting token mint is the governing_token_mint of the Proposal for Approve, Deny and Abstain votes.
   *     For Veto vote the voting token mint is the mint of the opposite voting population.
   *     Council mint to veto Community proposals and Community mint to veto Council proposals
   *     Note: In the current version only Council veto is supported
   */
  governingTokenMint: Address<TAccountGoverningTokenMint>;
  payer: TransactionSigner<TAccountPayer>;
  systemProgram?: Address<TAccountSystemProgram>;
  /** RealmConfig account. PDA seeds: ['realm-config', realm] */
  realmConfigAccount: Address<TAccountRealmConfigAccount>;
  /** Optional Voter Weight Record */
  voterWeightRecord?: Address<TAccountVoterWeightRecord>;
  /** Optional Max Voter Weight Record */
  maxVoterWeightRecord?: Address<TAccountMaxVoterWeightRecord>;
  vote: CastVoteInstructionDataArgs["vote"];
}

export function getCastVoteInstruction<
  TAccountRealmAccount extends string,
  TAccountGovernanceAccount extends string,
  TAccountProposalAccount extends string,
  TAccountProposalTokenOwnerRecord extends string,
  TAccountVoterTokenOwnerRecord extends string,
  TAccountGovernanceAuthority extends string,
  TAccountProposalVoteRecord extends string,
  TAccountGoverningTokenMint extends string,
  TAccountPayer extends string,
  TAccountSystemProgram extends string,
  TAccountRealmConfigAccount extends string,
  TAccountVoterWeightRecord extends string,
  TAccountMaxVoterWeightRecord extends string,
  TProgramAddress extends Address = typeof SPL_GOVERNANCE_PROGRAM_ADDRESS,
>(
  input: CastVoteInput<
    TAccountRealmAccount,
    TAccountGovernanceAccount,
    TAccountProposalAccount,
    TAccountProposalTokenOwnerRecord,
    TAccountVoterTokenOwnerRecord,
    TAccountGovernanceAuthority,
    TAccountProposalVoteRecord,
    TAccountGoverningTokenMint,
    TAccountPayer,
    TAccountSystemProgram,
    TAccountRealmConfigAccount,
    TAccountVoterWeightRecord,
    TAccountMaxVoterWeightRecord
  >,
  config?: { programAddress?: TProgramAddress },
): CastVoteInstruction<
  TProgramAddress,
  TAccountRealmAccount,
  TAccountGovernanceAccount,
  TAccountProposalAccount,
  TAccountProposalTokenOwnerRecord,
  TAccountVoterTokenOwnerRecord,
  TAccountGovernanceAuthority,
  TAccountProposalVoteRecord,
  TAccountGoverningTokenMint,
  TAccountPayer,
  TAccountSystemProgram,
  TAccountRealmConfigAccount,
  TAccountVoterWeightRecord,
  TAccountMaxVoterWeightRecord
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? SPL_GOVERNANCE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    realmAccount: { value: input.realmAccount ?? null, isWritable: false },
    governanceAccount: {
      value: input.governanceAccount ?? null,
      isWritable: true,
    },
    proposalAccount: { value: input.proposalAccount ?? null, isWritable: true },
    proposalTokenOwnerRecord: {
      value: input.proposalTokenOwnerRecord ?? null,
      isWritable: true,
    },
    voterTokenOwnerRecord: {
      value: input.voterTokenOwnerRecord ?? null,
      isWritable: true,
    },
    governanceAuthority: {
      value: input.governanceAuthority ?? null,
      isWritable: false,
    },
    proposalVoteRecord: {
      value: input.proposalVoteRecord ?? null,
      isWritable: true,
    },
    governingTokenMint: {
      value: input.governingTokenMint ?? null,
      isWritable: false,
    },
    payer: { value: input.payer ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    realmConfigAccount: {
      value: input.realmConfigAccount ?? null,
      isWritable: false,
    },
    voterWeightRecord: {
      value: input.voterWeightRecord ?? null,
      isWritable: false,
    },
    maxVoterWeightRecord: {
      value: input.maxVoterWeightRecord ?? null,
      isWritable: false,
    },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.realmAccount),
      getAccountMeta(accounts.governanceAccount),
      getAccountMeta(accounts.proposalAccount),
      getAccountMeta(accounts.proposalTokenOwnerRecord),
      getAccountMeta(accounts.voterTokenOwnerRecord),
      getAccountMeta(accounts.governanceAuthority),
      getAccountMeta(accounts.proposalVoteRecord),
      getAccountMeta(accounts.governingTokenMint),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.realmConfigAccount),
      getAccountMeta(accounts.voterWeightRecord),
      getAccountMeta(accounts.maxVoterWeightRecord),
    ],
    data: getCastVoteInstructionDataEncoder().encode(
      args as CastVoteInstructionDataArgs,
    ),
    programAddress,
  } as CastVoteInstruction<
    TProgramAddress,
    TAccountRealmAccount,
    TAccountGovernanceAccount,
    TAccountProposalAccount,
    TAccountProposalTokenOwnerRecord,
    TAccountVoterTokenOwnerRecord,
    TAccountGovernanceAuthority,
    TAccountProposalVoteRecord,
    TAccountGoverningTokenMint,
    TAccountPayer,
    TAccountSystemProgram,
    TAccountRealmConfigAccount,
    TAccountVoterWeightRecord,
    TAccountMaxVoterWeightRecord
  >);
}

export interface ParsedCastVoteInstruction<
  TProgram extends string = typeof SPL_GOVERNANCE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> {
  programAddress: Address<TProgram>;
  accounts: {
    realmAccount: TAccountMetas[0];
    governanceAccount: TAccountMetas[1];
    proposalAccount: TAccountMetas[2];
    /** TokenOwnerRecord of the Proposal owner */
    proposalTokenOwnerRecord: TAccountMetas[3];
    /** TokenOwnerRecord of the voter. PDA seeds: ['governance',realm, vote_governing_token_mint, governing_token_owner] */
    voterTokenOwnerRecord: TAccountMetas[4];
    /** Governance Authority (Token Owner or Governance Delegate) */
    governanceAuthority: TAccountMetas[5];
    /** Proposal VoteRecord account. PDA seeds: ['governance',proposal,token_owner_record] */
    proposalVoteRecord: TAccountMetas[6];
    /**
     * The Governing Token Mint which is used to cast the vote (vote_governing_token_mint).
     *     The voting token mint is the governing_token_mint of the Proposal for Approve, Deny and Abstain votes.
     *     For Veto vote the voting token mint is the mint of the opposite voting population.
     *     Council mint to veto Community proposals and Community mint to veto Council proposals
     *     Note: In the current version only Council veto is supported
     */
    governingTokenMint: TAccountMetas[7];
    payer: TAccountMetas[8];
    systemProgram: TAccountMetas[9];
    /** RealmConfig account. PDA seeds: ['realm-config', realm] */
    realmConfigAccount: TAccountMetas[10];
    /** Optional Voter Weight Record */
    voterWeightRecord?: TAccountMetas[11] | undefined;
    /** Optional Max Voter Weight Record */
    maxVoterWeightRecord?: TAccountMetas[12] | undefined;
  };
  data: CastVoteInstructionData;
}

export function parseCastVoteInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedCastVoteInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 13) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === SPL_GOVERNANCE_PROGRAM_ADDRESS
      ? undefined
      : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      realmAccount: getNextAccount(),
      governanceAccount: getNextAccount(),
      proposalAccount: getNextAccount(),
      proposalTokenOwnerRecord: getNextAccount(),
      voterTokenOwnerRecord: getNextAccount(),
      governanceAuthority: getNextAccount(),
      proposalVoteRecord: getNextAccount(),
      governingTokenMint: getNextAccount(),
      payer: getNextAccount(),
      systemProgram: getNextAccount(),
      realmConfigAccount: getNextAccount(),
      voterWeightRecord: getNextOptionalAccount(),
      maxVoterWeightRecord: getNextOptionalAccount(),
    },
    data: getCastVoteInstructionDataDecoder().decode(instruction.data),
  };
}
