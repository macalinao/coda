/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  AccountMeta,
  AccountSignerMeta,
  Address,
  Codec,
  Decoder,
  Encoder,
  Instruction,
  InstructionWithAccounts,
  InstructionWithData,
  ReadonlyAccount,
  ReadonlySignerAccount,
  ReadonlyUint8Array,
  TransactionSigner,
  WritableAccount,
} from "@solana/kit";
import type { ResolvedAccount } from "../shared/index.js";
import type { VoteType, VoteTypeArgs } from "../types/index.js";
import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU32Decoder,
  getU32Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  transformEncoder,
} from "@solana/kit";
import { SPL_GOVERNANCE_PROGRAM_ADDRESS } from "../programs/index.js";
import { getAccountMetaFactory } from "../shared/index.js";
import { getVoteTypeDecoder, getVoteTypeEncoder } from "../types/index.js";

export const CREATE_PROPOSAL_DISCRIMINATOR: ReadonlyUint8Array = new Uint8Array(
  [132, 116, 68, 174, 216, 160, 198, 22],
);

export function getCreateProposalDiscriminatorBytes(): ReadonlyUint8Array {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    CREATE_PROPOSAL_DISCRIMINATOR,
  );
}

export type CreateProposalInstruction<
  TProgram extends string = typeof SPL_GOVERNANCE_PROGRAM_ADDRESS,
  TAccountRealmAccount extends string | AccountMeta = string,
  TAccountProposalAccount extends string | AccountMeta = string,
  TAccountGovernanceAccount extends string | AccountMeta = string,
  TAccountTokenOwnerRecord extends string | AccountMeta = string,
  TAccountGoverningTokenMint extends string | AccountMeta = string,
  TAccountGovernanceAuthority extends string | AccountMeta = string,
  TAccountPayer extends string | AccountMeta = string,
  TAccountSystemProgram extends
    | string
    | AccountMeta = "11111111111111111111111111111111",
  TAccountRealmConfig extends string | AccountMeta = string,
  TAccountVoterWeightRecord extends string | AccountMeta = string,
  TAccountProposalDepositAccount extends string | AccountMeta = string,
  TRemainingAccounts extends readonly AccountMeta[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountRealmAccount extends string
        ? ReadonlyAccount<TAccountRealmAccount>
        : TAccountRealmAccount,
      TAccountProposalAccount extends string
        ? WritableAccount<TAccountProposalAccount>
        : TAccountProposalAccount,
      TAccountGovernanceAccount extends string
        ? WritableAccount<TAccountGovernanceAccount>
        : TAccountGovernanceAccount,
      TAccountTokenOwnerRecord extends string
        ? WritableAccount<TAccountTokenOwnerRecord>
        : TAccountTokenOwnerRecord,
      TAccountGoverningTokenMint extends string
        ? ReadonlyAccount<TAccountGoverningTokenMint>
        : TAccountGoverningTokenMint,
      TAccountGovernanceAuthority extends string
        ? ReadonlySignerAccount<TAccountGovernanceAuthority> &
            AccountSignerMeta<TAccountGovernanceAuthority>
        : TAccountGovernanceAuthority,
      TAccountPayer extends string
        ? ReadonlySignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountRealmConfig extends string
        ? ReadonlyAccount<TAccountRealmConfig>
        : TAccountRealmConfig,
      TAccountVoterWeightRecord extends string
        ? WritableAccount<TAccountVoterWeightRecord>
        : TAccountVoterWeightRecord,
      TAccountProposalDepositAccount extends string
        ? ReadonlyAccount<TAccountProposalDepositAccount>
        : TAccountProposalDepositAccount,
      ...TRemainingAccounts,
    ]
  >;

export interface CreateProposalInstructionData {
  discriminator: ReadonlyUint8Array;
  name: string;
  descriptionLink: string;
  voteType: VoteType;
  options: string[];
  useDenyOption: boolean;
  proposalSeed: Address;
}

export interface CreateProposalInstructionDataArgs {
  name: string;
  descriptionLink: string;
  voteType: VoteTypeArgs;
  options: string[];
  useDenyOption: boolean;
  proposalSeed: Address;
}

export function getCreateProposalInstructionDataEncoder(): Encoder<CreateProposalInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
      [
        "descriptionLink",
        addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),
      ],
      ["voteType", getVoteTypeEncoder()],
      [
        "options",
        getArrayEncoder(
          addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),
        ),
      ],
      ["useDenyOption", getBooleanEncoder()],
      ["proposalSeed", getAddressEncoder()],
    ]),
    (value) => ({ ...value, discriminator: CREATE_PROPOSAL_DISCRIMINATOR }),
  );
}

export function getCreateProposalInstructionDataDecoder(): Decoder<CreateProposalInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "descriptionLink",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),
    ],
    ["voteType", getVoteTypeDecoder()],
    [
      "options",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())),
    ],
    ["useDenyOption", getBooleanDecoder()],
    ["proposalSeed", getAddressDecoder()],
  ]);
}

export function getCreateProposalInstructionDataCodec(): Codec<
  CreateProposalInstructionDataArgs,
  CreateProposalInstructionData
> {
  return combineCodec(
    getCreateProposalInstructionDataEncoder(),
    getCreateProposalInstructionDataDecoder(),
  );
}

export interface CreateProposalInput<
  TAccountRealmAccount extends string = string,
  TAccountProposalAccount extends string = string,
  TAccountGovernanceAccount extends string = string,
  TAccountTokenOwnerRecord extends string = string,
  TAccountGoverningTokenMint extends string = string,
  TAccountGovernanceAuthority extends string = string,
  TAccountPayer extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountRealmConfig extends string = string,
  TAccountVoterWeightRecord extends string = string,
  TAccountProposalDepositAccount extends string = string,
> {
  /** Realm account the created Proposal belongs to */
  realmAccount: Address<TAccountRealmAccount>;
  /** Proposal account. PDA seeds ['governance',governance, governing_token_mint, proposal_index] */
  proposalAccount: Address<TAccountProposalAccount>;
  /** Governance account */
  governanceAccount: Address<TAccountGovernanceAccount>;
  /** TokenOwnerRecord account of the Proposal owner */
  tokenOwnerRecord: Address<TAccountTokenOwnerRecord>;
  /** Token Mint the Proposal is created for */
  governingTokenMint: Address<TAccountGoverningTokenMint>;
  /** Governance Authority (Token Owner or Governance Delegate) */
  governanceAuthority: TransactionSigner<TAccountGovernanceAuthority>;
  payer: TransactionSigner<TAccountPayer>;
  systemProgram?: Address<TAccountSystemProgram>;
  /** RealmConfig account. PDA seeds: ['realm-config', realm] */
  realmConfig: Address<TAccountRealmConfig>;
  /** Optional Voter Weight Record */
  voterWeightRecord?: Address<TAccountVoterWeightRecord>;
  /** Optional Proposal deposit is required when there are more active 
        proposals than the configured deposit exempt amount. 
        PDA seeds: ['proposal-deposit', proposal, deposit payer] */
  proposalDepositAccount?: Address<TAccountProposalDepositAccount>;
  name: CreateProposalInstructionDataArgs["name"];
  descriptionLink: CreateProposalInstructionDataArgs["descriptionLink"];
  voteType: CreateProposalInstructionDataArgs["voteType"];
  options: CreateProposalInstructionDataArgs["options"];
  useDenyOption: CreateProposalInstructionDataArgs["useDenyOption"];
  proposalSeed: CreateProposalInstructionDataArgs["proposalSeed"];
}

export function getCreateProposalInstruction<
  TAccountRealmAccount extends string,
  TAccountProposalAccount extends string,
  TAccountGovernanceAccount extends string,
  TAccountTokenOwnerRecord extends string,
  TAccountGoverningTokenMint extends string,
  TAccountGovernanceAuthority extends string,
  TAccountPayer extends string,
  TAccountSystemProgram extends string,
  TAccountRealmConfig extends string,
  TAccountVoterWeightRecord extends string,
  TAccountProposalDepositAccount extends string,
  TProgramAddress extends Address = typeof SPL_GOVERNANCE_PROGRAM_ADDRESS,
>(
  input: CreateProposalInput<
    TAccountRealmAccount,
    TAccountProposalAccount,
    TAccountGovernanceAccount,
    TAccountTokenOwnerRecord,
    TAccountGoverningTokenMint,
    TAccountGovernanceAuthority,
    TAccountPayer,
    TAccountSystemProgram,
    TAccountRealmConfig,
    TAccountVoterWeightRecord,
    TAccountProposalDepositAccount
  >,
  config?: { programAddress?: TProgramAddress },
): CreateProposalInstruction<
  TProgramAddress,
  TAccountRealmAccount,
  TAccountProposalAccount,
  TAccountGovernanceAccount,
  TAccountTokenOwnerRecord,
  TAccountGoverningTokenMint,
  TAccountGovernanceAuthority,
  TAccountPayer,
  TAccountSystemProgram,
  TAccountRealmConfig,
  TAccountVoterWeightRecord,
  TAccountProposalDepositAccount
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? SPL_GOVERNANCE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    realmAccount: { value: input.realmAccount ?? null, isWritable: false },
    proposalAccount: { value: input.proposalAccount ?? null, isWritable: true },
    governanceAccount: {
      value: input.governanceAccount ?? null,
      isWritable: true,
    },
    tokenOwnerRecord: {
      value: input.tokenOwnerRecord ?? null,
      isWritable: true,
    },
    governingTokenMint: {
      value: input.governingTokenMint ?? null,
      isWritable: false,
    },
    governanceAuthority: {
      value: input.governanceAuthority ?? null,
      isWritable: false,
    },
    payer: { value: input.payer ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    realmConfig: { value: input.realmConfig ?? null, isWritable: false },
    voterWeightRecord: {
      value: input.voterWeightRecord ?? null,
      isWritable: true,
    },
    proposalDepositAccount: {
      value: input.proposalDepositAccount ?? null,
      isWritable: false,
    },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.realmAccount),
      getAccountMeta(accounts.proposalAccount),
      getAccountMeta(accounts.governanceAccount),
      getAccountMeta(accounts.tokenOwnerRecord),
      getAccountMeta(accounts.governingTokenMint),
      getAccountMeta(accounts.governanceAuthority),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.realmConfig),
      getAccountMeta(accounts.voterWeightRecord),
      getAccountMeta(accounts.proposalDepositAccount),
    ],
    data: getCreateProposalInstructionDataEncoder().encode(
      args as CreateProposalInstructionDataArgs,
    ),
    programAddress,
  } as CreateProposalInstruction<
    TProgramAddress,
    TAccountRealmAccount,
    TAccountProposalAccount,
    TAccountGovernanceAccount,
    TAccountTokenOwnerRecord,
    TAccountGoverningTokenMint,
    TAccountGovernanceAuthority,
    TAccountPayer,
    TAccountSystemProgram,
    TAccountRealmConfig,
    TAccountVoterWeightRecord,
    TAccountProposalDepositAccount
  >);
}

export interface ParsedCreateProposalInstruction<
  TProgram extends string = typeof SPL_GOVERNANCE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> {
  programAddress: Address<TProgram>;
  accounts: {
    /** Realm account the created Proposal belongs to */
    realmAccount: TAccountMetas[0];
    /** Proposal account. PDA seeds ['governance',governance, governing_token_mint, proposal_index] */
    proposalAccount: TAccountMetas[1];
    /** Governance account */
    governanceAccount: TAccountMetas[2];
    /** TokenOwnerRecord account of the Proposal owner */
    tokenOwnerRecord: TAccountMetas[3];
    /** Token Mint the Proposal is created for */
    governingTokenMint: TAccountMetas[4];
    /** Governance Authority (Token Owner or Governance Delegate) */
    governanceAuthority: TAccountMetas[5];
    payer: TAccountMetas[6];
    systemProgram: TAccountMetas[7];
    /** RealmConfig account. PDA seeds: ['realm-config', realm] */
    realmConfig: TAccountMetas[8];
    /** Optional Voter Weight Record */
    voterWeightRecord?: TAccountMetas[9] | undefined;
    /** Optional Proposal deposit is required when there are more active 
        proposals than the configured deposit exempt amount. 
        PDA seeds: ['proposal-deposit', proposal, deposit payer] */
    proposalDepositAccount?: TAccountMetas[10] | undefined;
  };
  data: CreateProposalInstructionData;
}

export function parseCreateProposalInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedCreateProposalInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === SPL_GOVERNANCE_PROGRAM_ADDRESS
      ? undefined
      : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      realmAccount: getNextAccount(),
      proposalAccount: getNextAccount(),
      governanceAccount: getNextAccount(),
      tokenOwnerRecord: getNextAccount(),
      governingTokenMint: getNextAccount(),
      governanceAuthority: getNextAccount(),
      payer: getNextAccount(),
      systemProgram: getNextAccount(),
      realmConfig: getNextAccount(),
      voterWeightRecord: getNextOptionalAccount(),
      proposalDepositAccount: getNextOptionalAccount(),
    },
    data: getCreateProposalInstructionDataDecoder().decode(instruction.data),
  };
}
