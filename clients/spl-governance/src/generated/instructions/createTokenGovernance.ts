/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  AccountMeta,
  AccountSignerMeta,
  Address,
  Codec,
  Decoder,
  Encoder,
  Instruction,
  InstructionWithAccounts,
  InstructionWithData,
  ReadonlyAccount,
  ReadonlySignerAccount,
  ReadonlyUint8Array,
  TransactionSigner,
  WritableAccount,
} from "@solana/kit";
import type { ResolvedAccount } from "../shared/index.js";
import type { GovernanceConfig, GovernanceConfigArgs } from "../types/index.js";
import {
  combineCodec,
  getBooleanDecoder,
  getBooleanEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
} from "@solana/kit";
import { SPL_GOVERNANCE_PROGRAM_ADDRESS } from "../programs/index.js";
import { getAccountMetaFactory } from "../shared/index.js";
import {
  getGovernanceConfigDecoder,
  getGovernanceConfigEncoder,
} from "../types/index.js";

export const CREATE_TOKEN_GOVERNANCE_DISCRIMINATOR = 18;

export function getCreateTokenGovernanceDiscriminatorBytes(): ReadonlyUint8Array {
  return getU8Encoder().encode(CREATE_TOKEN_GOVERNANCE_DISCRIMINATOR);
}

export type CreateTokenGovernanceInstruction<
  TProgram extends string = typeof SPL_GOVERNANCE_PROGRAM_ADDRESS,
  TAccountRealmAccount extends string | AccountMeta = string,
  TAccountTokenGovernanceAccount extends string | AccountMeta = string,
  TAccountTokenAccount extends string | AccountMeta = string,
  TAccountTokenAccountAuthority extends string | AccountMeta = string,
  TAccountGoverningTokenOwnerRecord extends string | AccountMeta = string,
  TAccountPayer extends string | AccountMeta = string,
  TAccountTokenProgram extends string | AccountMeta = string,
  TAccountSystemProgram extends
    | string
    | AccountMeta = "11111111111111111111111111111111",
  TAccountGovernanceAuthority extends string | AccountMeta = string,
  TAccountRealmConfig extends string | AccountMeta = string,
  TAccountVoterWeightRecord extends string | AccountMeta = string,
  TRemainingAccounts extends readonly AccountMeta[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountRealmAccount extends string
        ? ReadonlyAccount<TAccountRealmAccount>
        : TAccountRealmAccount,
      TAccountTokenGovernanceAccount extends string
        ? WritableAccount<TAccountTokenGovernanceAccount>
        : TAccountTokenGovernanceAccount,
      TAccountTokenAccount extends string
        ? WritableAccount<TAccountTokenAccount>
        : TAccountTokenAccount,
      TAccountTokenAccountAuthority extends string
        ? ReadonlySignerAccount<TAccountTokenAccountAuthority> &
            AccountSignerMeta<TAccountTokenAccountAuthority>
        : TAccountTokenAccountAuthority,
      TAccountGoverningTokenOwnerRecord extends string
        ? ReadonlyAccount<TAccountGoverningTokenOwnerRecord>
        : TAccountGoverningTokenOwnerRecord,
      TAccountPayer extends string
        ? ReadonlySignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountGovernanceAuthority extends string
        ? ReadonlySignerAccount<TAccountGovernanceAuthority> &
            AccountSignerMeta<TAccountGovernanceAuthority>
        : TAccountGovernanceAuthority,
      TAccountRealmConfig extends string
        ? ReadonlyAccount<TAccountRealmConfig>
        : TAccountRealmConfig,
      TAccountVoterWeightRecord extends string
        ? ReadonlyAccount<TAccountVoterWeightRecord>
        : TAccountVoterWeightRecord,
      ...TRemainingAccounts,
    ]
  >;

export interface CreateTokenGovernanceInstructionData {
  discriminator: number;
  config: GovernanceConfig;
  transferAccountAuthorities: boolean;
}

export interface CreateTokenGovernanceInstructionDataArgs {
  config: GovernanceConfigArgs;
  transferAccountAuthorities: boolean;
}

export function getCreateTokenGovernanceInstructionDataEncoder(): Encoder<CreateTokenGovernanceInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", getU8Encoder()],
      ["config", getGovernanceConfigEncoder()],
      ["transferAccountAuthorities", getBooleanEncoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: CREATE_TOKEN_GOVERNANCE_DISCRIMINATOR,
    }),
  );
}

export function getCreateTokenGovernanceInstructionDataDecoder(): Decoder<CreateTokenGovernanceInstructionData> {
  return getStructDecoder([
    ["discriminator", getU8Decoder()],
    ["config", getGovernanceConfigDecoder()],
    ["transferAccountAuthorities", getBooleanDecoder()],
  ]);
}

export function getCreateTokenGovernanceInstructionDataCodec(): Codec<
  CreateTokenGovernanceInstructionDataArgs,
  CreateTokenGovernanceInstructionData
> {
  return combineCodec(
    getCreateTokenGovernanceInstructionDataEncoder(),
    getCreateTokenGovernanceInstructionDataDecoder(),
  );
}

export interface CreateTokenGovernanceInput<
  TAccountRealmAccount extends string = string,
  TAccountTokenGovernanceAccount extends string = string,
  TAccountTokenAccount extends string = string,
  TAccountTokenAccountAuthority extends string = string,
  TAccountGoverningTokenOwnerRecord extends string = string,
  TAccountPayer extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountGovernanceAuthority extends string = string,
  TAccountRealmConfig extends string = string,
  TAccountVoterWeightRecord extends string = string,
> {
  /** Realm account the created Governance belongs to */
  realmAccount: Address<TAccountRealmAccount>;
  /** Token Governance account. seeds=['token-governance', realm, governed_token] */
  tokenGovernanceAccount: Address<TAccountTokenGovernanceAccount>;
  /** Token account governed by this Governance account */
  tokenAccount: Address<TAccountTokenAccount>;
  /** Current token account authority (AccountOwner and optionally CloseAccount */
  tokenAccountAuthority: TransactionSigner<TAccountTokenAccountAuthority>;
  /** Governing TokenOwnerRecord account (Used only if not signed by RealmAuthority */
  governingTokenOwnerRecord: Address<TAccountGoverningTokenOwnerRecord>;
  payer: TransactionSigner<TAccountPayer>;
  tokenProgram: Address<TAccountTokenProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
  governanceAuthority: TransactionSigner<TAccountGovernanceAuthority>;
  /** seeds=['realm-config', realm] */
  realmConfig: Address<TAccountRealmConfig>;
  /** Optional Voter Weight Record */
  voterWeightRecord?: Address<TAccountVoterWeightRecord>;
  config: CreateTokenGovernanceInstructionDataArgs["config"];
  transferAccountAuthorities: CreateTokenGovernanceInstructionDataArgs["transferAccountAuthorities"];
}

export function getCreateTokenGovernanceInstruction<
  TAccountRealmAccount extends string,
  TAccountTokenGovernanceAccount extends string,
  TAccountTokenAccount extends string,
  TAccountTokenAccountAuthority extends string,
  TAccountGoverningTokenOwnerRecord extends string,
  TAccountPayer extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TAccountGovernanceAuthority extends string,
  TAccountRealmConfig extends string,
  TAccountVoterWeightRecord extends string,
  TProgramAddress extends Address = typeof SPL_GOVERNANCE_PROGRAM_ADDRESS,
>(
  input: CreateTokenGovernanceInput<
    TAccountRealmAccount,
    TAccountTokenGovernanceAccount,
    TAccountTokenAccount,
    TAccountTokenAccountAuthority,
    TAccountGoverningTokenOwnerRecord,
    TAccountPayer,
    TAccountTokenProgram,
    TAccountSystemProgram,
    TAccountGovernanceAuthority,
    TAccountRealmConfig,
    TAccountVoterWeightRecord
  >,
  config?: { programAddress?: TProgramAddress },
): CreateTokenGovernanceInstruction<
  TProgramAddress,
  TAccountRealmAccount,
  TAccountTokenGovernanceAccount,
  TAccountTokenAccount,
  TAccountTokenAccountAuthority,
  TAccountGoverningTokenOwnerRecord,
  TAccountPayer,
  TAccountTokenProgram,
  TAccountSystemProgram,
  TAccountGovernanceAuthority,
  TAccountRealmConfig,
  TAccountVoterWeightRecord
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? SPL_GOVERNANCE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    realmAccount: { value: input.realmAccount ?? null, isWritable: false },
    tokenGovernanceAccount: {
      value: input.tokenGovernanceAccount ?? null,
      isWritable: true,
    },
    tokenAccount: { value: input.tokenAccount ?? null, isWritable: true },
    tokenAccountAuthority: {
      value: input.tokenAccountAuthority ?? null,
      isWritable: false,
    },
    governingTokenOwnerRecord: {
      value: input.governingTokenOwnerRecord ?? null,
      isWritable: false,
    },
    payer: { value: input.payer ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    governanceAuthority: {
      value: input.governanceAuthority ?? null,
      isWritable: false,
    },
    realmConfig: { value: input.realmConfig ?? null, isWritable: false },
    voterWeightRecord: {
      value: input.voterWeightRecord ?? null,
      isWritable: false,
    },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.realmAccount),
      getAccountMeta(accounts.tokenGovernanceAccount),
      getAccountMeta(accounts.tokenAccount),
      getAccountMeta(accounts.tokenAccountAuthority),
      getAccountMeta(accounts.governingTokenOwnerRecord),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.governanceAuthority),
      getAccountMeta(accounts.realmConfig),
      getAccountMeta(accounts.voterWeightRecord),
    ],
    data: getCreateTokenGovernanceInstructionDataEncoder().encode(
      args as CreateTokenGovernanceInstructionDataArgs,
    ),
    programAddress,
  } as CreateTokenGovernanceInstruction<
    TProgramAddress,
    TAccountRealmAccount,
    TAccountTokenGovernanceAccount,
    TAccountTokenAccount,
    TAccountTokenAccountAuthority,
    TAccountGoverningTokenOwnerRecord,
    TAccountPayer,
    TAccountTokenProgram,
    TAccountSystemProgram,
    TAccountGovernanceAuthority,
    TAccountRealmConfig,
    TAccountVoterWeightRecord
  >);
}

export interface ParsedCreateTokenGovernanceInstruction<
  TProgram extends string = typeof SPL_GOVERNANCE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> {
  programAddress: Address<TProgram>;
  accounts: {
    /** Realm account the created Governance belongs to */
    realmAccount: TAccountMetas[0];
    /** Token Governance account. seeds=['token-governance', realm, governed_token] */
    tokenGovernanceAccount: TAccountMetas[1];
    /** Token account governed by this Governance account */
    tokenAccount: TAccountMetas[2];
    /** Current token account authority (AccountOwner and optionally CloseAccount */
    tokenAccountAuthority: TAccountMetas[3];
    /** Governing TokenOwnerRecord account (Used only if not signed by RealmAuthority */
    governingTokenOwnerRecord: TAccountMetas[4];
    payer: TAccountMetas[5];
    tokenProgram: TAccountMetas[6];
    systemProgram: TAccountMetas[7];
    governanceAuthority: TAccountMetas[8];
    /** seeds=['realm-config', realm] */
    realmConfig: TAccountMetas[9];
    /** Optional Voter Weight Record */
    voterWeightRecord?: TAccountMetas[10] | undefined;
  };
  data: CreateTokenGovernanceInstructionData;
}

export function parseCreateTokenGovernanceInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedCreateTokenGovernanceInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === SPL_GOVERNANCE_PROGRAM_ADDRESS
      ? undefined
      : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      realmAccount: getNextAccount(),
      tokenGovernanceAccount: getNextAccount(),
      tokenAccount: getNextAccount(),
      tokenAccountAuthority: getNextAccount(),
      governingTokenOwnerRecord: getNextAccount(),
      payer: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      governanceAuthority: getNextAccount(),
      realmConfig: getNextAccount(),
      voterWeightRecord: getNextOptionalAccount(),
    },
    data: getCreateTokenGovernanceInstructionDataDecoder().decode(
      instruction.data,
    ),
  };
}
