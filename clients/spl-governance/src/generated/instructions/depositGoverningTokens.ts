/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type {
  AccountMeta,
  AccountSignerMeta,
  Address,
  FixedSizeCodec,
  FixedSizeDecoder,
  FixedSizeEncoder,
  Instruction,
  InstructionWithAccounts,
  InstructionWithData,
  ReadonlyAccount,
  ReadonlySignerAccount,
  ReadonlyUint8Array,
  TransactionSigner,
  WritableAccount,
  WritableSignerAccount,
} from "@solana/kit";
import type { ResolvedAccount } from "../shared/index.js";
import {
  combineCodec,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
} from "@solana/kit";
import { SPL_GOVERNANCE_PROGRAM_ADDRESS } from "../programs/index.js";
import { getAccountMetaFactory } from "../shared/index.js";

export const DEPOSIT_GOVERNING_TOKENS_DISCRIMINATOR = 1;

export function getDepositGoverningTokensDiscriminatorBytes(): ReadonlyUint8Array {
  return getU8Encoder().encode(DEPOSIT_GOVERNING_TOKENS_DISCRIMINATOR);
}

export type DepositGoverningTokensInstruction<
  TProgram extends string = typeof SPL_GOVERNANCE_PROGRAM_ADDRESS,
  TAccountRealmAccount extends string | AccountMeta = string,
  TAccountGoverningTokenHoldingAccount extends string | AccountMeta = string,
  TAccountGoverningTokenSourceAccount extends string | AccountMeta = string,
  TAccountGoverningTokenOwnerAccount extends string | AccountMeta = string,
  TAccountGoverningTokenSourceAccountAuthority extends
    | string
    | AccountMeta = string,
  TAccountTokenOwnerRecord extends string | AccountMeta = string,
  TAccountPayer extends string | AccountMeta = string,
  TAccountSystemProgram extends
    | string
    | AccountMeta = "11111111111111111111111111111111",
  TAccountTokenProgram extends string | AccountMeta = string,
  TAccountRealmConfigAccount extends string | AccountMeta = string,
  TRemainingAccounts extends readonly AccountMeta[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountRealmAccount extends string
        ? ReadonlyAccount<TAccountRealmAccount>
        : TAccountRealmAccount,
      TAccountGoverningTokenHoldingAccount extends string
        ? WritableAccount<TAccountGoverningTokenHoldingAccount>
        : TAccountGoverningTokenHoldingAccount,
      TAccountGoverningTokenSourceAccount extends string
        ? WritableAccount<TAccountGoverningTokenSourceAccount>
        : TAccountGoverningTokenSourceAccount,
      TAccountGoverningTokenOwnerAccount extends string
        ? ReadonlySignerAccount<TAccountGoverningTokenOwnerAccount> &
            AccountSignerMeta<TAccountGoverningTokenOwnerAccount>
        : TAccountGoverningTokenOwnerAccount,
      TAccountGoverningTokenSourceAccountAuthority extends string
        ? ReadonlySignerAccount<TAccountGoverningTokenSourceAccountAuthority> &
            AccountSignerMeta<TAccountGoverningTokenSourceAccountAuthority>
        : TAccountGoverningTokenSourceAccountAuthority,
      TAccountTokenOwnerRecord extends string
        ? WritableAccount<TAccountTokenOwnerRecord>
        : TAccountTokenOwnerRecord,
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountRealmConfigAccount extends string
        ? ReadonlyAccount<TAccountRealmConfigAccount>
        : TAccountRealmConfigAccount,
      ...TRemainingAccounts,
    ]
  >;

export interface DepositGoverningTokensInstructionData {
  discriminator: number;
  amount: bigint;
}

export interface DepositGoverningTokensInstructionDataArgs {
  amount: number | bigint;
}

export function getDepositGoverningTokensInstructionDataEncoder(): FixedSizeEncoder<DepositGoverningTokensInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", getU8Encoder()],
      ["amount", getU64Encoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: DEPOSIT_GOVERNING_TOKENS_DISCRIMINATOR,
    }),
  );
}

export function getDepositGoverningTokensInstructionDataDecoder(): FixedSizeDecoder<DepositGoverningTokensInstructionData> {
  return getStructDecoder([
    ["discriminator", getU8Decoder()],
    ["amount", getU64Decoder()],
  ]);
}

export function getDepositGoverningTokensInstructionDataCodec(): FixedSizeCodec<
  DepositGoverningTokensInstructionDataArgs,
  DepositGoverningTokensInstructionData
> {
  return combineCodec(
    getDepositGoverningTokensInstructionDataEncoder(),
    getDepositGoverningTokensInstructionDataDecoder(),
  );
}

export interface DepositGoverningTokensInput<
  TAccountRealmAccount extends string = string,
  TAccountGoverningTokenHoldingAccount extends string = string,
  TAccountGoverningTokenSourceAccount extends string = string,
  TAccountGoverningTokenOwnerAccount extends string = string,
  TAccountGoverningTokenSourceAccountAuthority extends string = string,
  TAccountTokenOwnerRecord extends string = string,
  TAccountPayer extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountRealmConfigAccount extends string = string,
> {
  realmAccount: Address<TAccountRealmAccount>;
  /** seeds=['governance', realm, governing_token_mint] */
  governingTokenHoldingAccount: Address<TAccountGoverningTokenHoldingAccount>;
  /** It can either be spl-token TokenAccount or MintAccount. Tokens will be transferred or minted to the holding account */
  governingTokenSourceAccount: Address<TAccountGoverningTokenSourceAccount>;
  governingTokenOwnerAccount: TransactionSigner<TAccountGoverningTokenOwnerAccount>;
  /** It should be owner for TokenAccount and mint_authority for MintAccount */
  governingTokenSourceAccountAuthority: TransactionSigner<TAccountGoverningTokenSourceAccountAuthority>;
  /** seeds=['governance', realm, governing_token_mint, governing_token_owner] */
  tokenOwnerRecord: Address<TAccountTokenOwnerRecord>;
  payer: TransactionSigner<TAccountPayer>;
  systemProgram?: Address<TAccountSystemProgram>;
  tokenProgram: Address<TAccountTokenProgram>;
  /** seeds=['realm-config', realm] */
  realmConfigAccount: Address<TAccountRealmConfigAccount>;
  amount: DepositGoverningTokensInstructionDataArgs["amount"];
}

export function getDepositGoverningTokensInstruction<
  TAccountRealmAccount extends string,
  TAccountGoverningTokenHoldingAccount extends string,
  TAccountGoverningTokenSourceAccount extends string,
  TAccountGoverningTokenOwnerAccount extends string,
  TAccountGoverningTokenSourceAccountAuthority extends string,
  TAccountTokenOwnerRecord extends string,
  TAccountPayer extends string,
  TAccountSystemProgram extends string,
  TAccountTokenProgram extends string,
  TAccountRealmConfigAccount extends string,
  TProgramAddress extends Address = typeof SPL_GOVERNANCE_PROGRAM_ADDRESS,
>(
  input: DepositGoverningTokensInput<
    TAccountRealmAccount,
    TAccountGoverningTokenHoldingAccount,
    TAccountGoverningTokenSourceAccount,
    TAccountGoverningTokenOwnerAccount,
    TAccountGoverningTokenSourceAccountAuthority,
    TAccountTokenOwnerRecord,
    TAccountPayer,
    TAccountSystemProgram,
    TAccountTokenProgram,
    TAccountRealmConfigAccount
  >,
  config?: { programAddress?: TProgramAddress },
): DepositGoverningTokensInstruction<
  TProgramAddress,
  TAccountRealmAccount,
  TAccountGoverningTokenHoldingAccount,
  TAccountGoverningTokenSourceAccount,
  TAccountGoverningTokenOwnerAccount,
  TAccountGoverningTokenSourceAccountAuthority,
  TAccountTokenOwnerRecord,
  TAccountPayer,
  TAccountSystemProgram,
  TAccountTokenProgram,
  TAccountRealmConfigAccount
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? SPL_GOVERNANCE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    realmAccount: { value: input.realmAccount ?? null, isWritable: false },
    governingTokenHoldingAccount: {
      value: input.governingTokenHoldingAccount ?? null,
      isWritable: true,
    },
    governingTokenSourceAccount: {
      value: input.governingTokenSourceAccount ?? null,
      isWritable: true,
    },
    governingTokenOwnerAccount: {
      value: input.governingTokenOwnerAccount ?? null,
      isWritable: false,
    },
    governingTokenSourceAccountAuthority: {
      value: input.governingTokenSourceAccountAuthority ?? null,
      isWritable: false,
    },
    tokenOwnerRecord: {
      value: input.tokenOwnerRecord ?? null,
      isWritable: true,
    },
    payer: { value: input.payer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    realmConfigAccount: {
      value: input.realmConfigAccount ?? null,
      isWritable: false,
    },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.realmAccount),
      getAccountMeta(accounts.governingTokenHoldingAccount),
      getAccountMeta(accounts.governingTokenSourceAccount),
      getAccountMeta(accounts.governingTokenOwnerAccount),
      getAccountMeta(accounts.governingTokenSourceAccountAuthority),
      getAccountMeta(accounts.tokenOwnerRecord),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.realmConfigAccount),
    ],
    data: getDepositGoverningTokensInstructionDataEncoder().encode(
      args as DepositGoverningTokensInstructionDataArgs,
    ),
    programAddress,
  } as DepositGoverningTokensInstruction<
    TProgramAddress,
    TAccountRealmAccount,
    TAccountGoverningTokenHoldingAccount,
    TAccountGoverningTokenSourceAccount,
    TAccountGoverningTokenOwnerAccount,
    TAccountGoverningTokenSourceAccountAuthority,
    TAccountTokenOwnerRecord,
    TAccountPayer,
    TAccountSystemProgram,
    TAccountTokenProgram,
    TAccountRealmConfigAccount
  >);
}

export interface ParsedDepositGoverningTokensInstruction<
  TProgram extends string = typeof SPL_GOVERNANCE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> {
  programAddress: Address<TProgram>;
  accounts: {
    realmAccount: TAccountMetas[0];
    /** seeds=['governance', realm, governing_token_mint] */
    governingTokenHoldingAccount: TAccountMetas[1];
    /** It can either be spl-token TokenAccount or MintAccount. Tokens will be transferred or minted to the holding account */
    governingTokenSourceAccount: TAccountMetas[2];
    governingTokenOwnerAccount: TAccountMetas[3];
    /** It should be owner for TokenAccount and mint_authority for MintAccount */
    governingTokenSourceAccountAuthority: TAccountMetas[4];
    /** seeds=['governance', realm, governing_token_mint, governing_token_owner] */
    tokenOwnerRecord: TAccountMetas[5];
    payer: TAccountMetas[6];
    systemProgram: TAccountMetas[7];
    tokenProgram: TAccountMetas[8];
    /** seeds=['realm-config', realm] */
    realmConfigAccount: TAccountMetas[9];
  };
  data: DepositGoverningTokensInstructionData;
}

export function parseDepositGoverningTokensInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedDepositGoverningTokensInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 10) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      realmAccount: getNextAccount(),
      governingTokenHoldingAccount: getNextAccount(),
      governingTokenSourceAccount: getNextAccount(),
      governingTokenOwnerAccount: getNextAccount(),
      governingTokenSourceAccountAuthority: getNextAccount(),
      tokenOwnerRecord: getNextAccount(),
      payer: getNextAccount(),
      systemProgram: getNextAccount(),
      tokenProgram: getNextAccount(),
      realmConfigAccount: getNextAccount(),
    },
    data: getDepositGoverningTokensInstructionDataDecoder().decode(
      instruction.data,
    ),
  };
}
